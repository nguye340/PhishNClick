/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@rive-app";
exports.ids = ["vendor-chunks/@rive-app"];
exports.modules = {

/***/ "(ssr)/./node_modules/@rive-app/canvas/rive.js":
/*!***********************************************!*\
  !*** ./node_modules/@rive-app/canvas/rive.js ***!
  \***********************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_540__) => {\n\n__nested_webpack_require_540__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_540__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\nvar Rive = (() => {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  \n  return (\nfunction(moduleArg = {}) {\n\nvar m = moduleArg, aa, ba;\nm.ready = new Promise((a, b) => {\n  aa = a;\n  ba = b;\n});\nfunction fa() {\n  function a(g) {\n    const n = d;\n    c = b = 0;\n    d = new Map();\n    n.forEach(p => {\n      try {\n        p(g);\n      } catch (l) {\n        console.error(l);\n      }\n    });\n    this.ob();\n    e && e.Tb();\n  }\n  let b = 0, c = 0, d = new Map(), e = null, f = null;\n  this.requestAnimationFrame = function(g) {\n    b || (b = requestAnimationFrame(a.bind(this)));\n    const n = ++c;\n    d.set(n, g);\n    return n;\n  };\n  this.cancelAnimationFrame = function(g) {\n    d.delete(g);\n    b && 0 == d.size && (cancelAnimationFrame(b), b = 0);\n  };\n  this.Rb = function(g) {\n    f && (document.body.remove(f), f = null);\n    g || (f = document.createElement(\"div\"), f.style.backgroundColor = \"black\", f.style.position = \"fixed\", f.style.right = 0, f.style.top = 0, f.style.color = \"white\", f.style.padding = \"4px\", f.innerHTML = \"RIVE FPS\", g = function(n) {\n      f.innerHTML = \"RIVE FPS \" + n.toFixed(1);\n    }, document.body.appendChild(f));\n    e = new function() {\n      let n = 0, p = 0;\n      this.Tb = function() {\n        var l = performance.now();\n        p ? (++n, l -= p, 1000 < l && (g(1000 * n / l), n = p = 0)) : (p = l, n = 0);\n      };\n    }();\n  };\n  this.Ob = function() {\n    f && (document.body.remove(f), f = null);\n    e = null;\n  };\n  this.ob = function() {\n  };\n}\nfunction ha(a) {\n  console.assert(!0);\n  const b = new Map();\n  let c = -Infinity;\n  this.push = function(d) {\n    d = d + ((1 << a) - 1) >> a;\n    b.has(d) && clearTimeout(b.get(d));\n    b.set(d, setTimeout(function() {\n      b.delete(d);\n      0 == b.length ? c = -Infinity : d == c && (c = Math.max(...b.keys()), console.assert(c < d));\n    }, 1000));\n    c = Math.max(d, c);\n    return c << a;\n  };\n}\nconst ia = m.onRuntimeInitialized;\nm.onRuntimeInitialized = function() {\n  ia && ia();\n  let a = m.decodeAudio;\n  m.decodeAudio = function(e, f) {\n    e = a(e);\n    f(e);\n  };\n  let b = m.decodeFont;\n  m.decodeFont = function(e, f) {\n    e = b(e);\n    f(e);\n  };\n  const c = m.FileAssetLoader;\n  m.ptrToAsset = e => {\n    let f = m.ptrToFileAsset(e);\n    return f.isImage ? m.ptrToImageAsset(e) : f.isFont ? m.ptrToFontAsset(e) : f.isAudio ? m.ptrToAudioAsset(e) : f;\n  };\n  m.CustomFileAssetLoader = c.extend(\"CustomFileAssetLoader\", {__construct:function({loadContents:e}) {\n    this.__parent.__construct.call(this);\n    this.Gb = e;\n  }, loadContents:function(e, f) {\n    e = m.ptrToAsset(e);\n    return this.Gb(e, f);\n  },});\n  m.CDNFileAssetLoader = c.extend(\"CDNFileAssetLoader\", {__construct:function() {\n    this.__parent.__construct.call(this);\n  }, loadContents:function(e) {\n    let f = m.ptrToAsset(e);\n    e = f.cdnUuid;\n    if (\"\" === e) {\n      return !1;\n    }\n    (function(g, n) {\n      var p = new XMLHttpRequest();\n      p.responseType = \"arraybuffer\";\n      p.onreadystatechange = function() {\n        4 == p.readyState && 200 == p.status && n(p);\n      };\n      p.open(\"GET\", g, !0);\n      p.send(null);\n    })(f.cdnBaseUrl + \"/\" + e, g => {\n      f.decode(new Uint8Array(g.response));\n    });\n    return !0;\n  },});\n  m.FallbackFileAssetLoader = c.extend(\"FallbackFileAssetLoader\", {__construct:function() {\n    this.__parent.__construct.call(this);\n    this.kb = [];\n  }, addLoader:function(e) {\n    this.kb.push(e);\n  }, loadContents:function(e, f) {\n    for (let g of this.kb) {\n      if (g.loadContents(e, f)) {\n        return !0;\n      }\n    }\n    return !1;\n  },});\n  let d = m.computeAlignment;\n  m.computeAlignment = function(e, f, g, n, p = 1.0) {\n    return d.call(this, e, f, g, n, p);\n  };\n};\nconst ja = \"createConicGradient createImageData createLinearGradient createPattern createRadialGradient getContextAttributes getImageData getLineDash getTransform isContextLost isPointInPath isPointInStroke measureText\".split(\" \"), ka = new function() {\n  function a() {\n    if (!b) {\n      var k = document.createElement(\"canvas\"), t = {alpha:1, depth:0, stencil:0, antialias:0, premultipliedAlpha:1, preserveDrawingBuffer:0, powerPreference:\"high-performance\", failIfMajorPerformanceCaveat:0, enableExtensionsByDefault:1, explicitSwapControl:1, renderViaOffscreenBackBuffer:1,};\n      let r;\n      if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {\n        if (r = k.getContext(\"webgl\", t), c = 1, !r) {\n          return console.log(\"No WebGL support. Image mesh will not be drawn.\"), !1;\n        }\n      } else {\n        if (r = k.getContext(\"webgl2\", t)) {\n          c = 2;\n        } else {\n          if (r = k.getContext(\"webgl\", t)) {\n            c = 1;\n          } else {\n            return console.log(\"No WebGL support. Image mesh will not be drawn.\"), !1;\n          }\n        }\n      }\n      r = new Proxy(r, {get(D, w) {\n        if (D.isContextLost()) {\n          if (p || (console.error(\"Cannot render the mesh because the GL Context was lost. Tried to invoke \", w), p = !0), \"function\" === typeof D[w]) {\n            return function() {\n            };\n          }\n        } else {\n          return \"function\" === typeof D[w] ? function(...M) {\n            return D[w].apply(D, M);\n          } : D[w];\n        }\n      }, set(D, w, M) {\n        if (D.isContextLost()) {\n          p || (console.error(\"Cannot render the mesh because the GL Context was lost. Tried to set property \" + w), p = !0);\n        } else {\n          return D[w] = M, !0;\n        }\n      },});\n      d = Math.min(r.getParameter(r.MAX_RENDERBUFFER_SIZE), r.getParameter(r.MAX_TEXTURE_SIZE));\n      function B(D, w, M) {\n        w = r.createShader(w);\n        r.shaderSource(w, M);\n        r.compileShader(w);\n        M = r.getShaderInfoLog(w);\n        if (0 < (M || \"\").length) {\n          throw M;\n        }\n        r.attachShader(D, w);\n      }\n      k = r.createProgram();\n      B(k, r.VERTEX_SHADER, \"attribute vec2 vertex;\\n                attribute vec2 uv;\\n                uniform vec4 mat;\\n                uniform vec2 translate;\\n                varying vec2 st;\\n                void main() {\\n                    st = uv;\\n                    gl_Position = vec4(mat2(mat) * vertex + translate, 0, 1);\\n                }\");\n      B(k, r.FRAGMENT_SHADER, \"precision highp float;\\n                uniform sampler2D image;\\n                varying vec2 st;\\n                void main() {\\n                    gl_FragColor = texture2D(image, st);\\n                }\");\n      r.bindAttribLocation(k, 0, \"vertex\");\n      r.bindAttribLocation(k, 1, \"uv\");\n      r.linkProgram(k);\n      t = r.getProgramInfoLog(k);\n      if (0 < (t || \"\").trim().length) {\n        throw t;\n      }\n      e = r.getUniformLocation(k, \"mat\");\n      f = r.getUniformLocation(k, \"translate\");\n      r.useProgram(k);\n      r.bindBuffer(r.ARRAY_BUFFER, r.createBuffer());\n      r.enableVertexAttribArray(0);\n      r.enableVertexAttribArray(1);\n      r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, r.createBuffer());\n      r.uniform1i(r.getUniformLocation(k, \"image\"), 0);\n      r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);\n      b = r;\n    }\n    return !0;\n  }\n  let b = null, c = 0, d = 0, e = null, f = null, g = 0, n = 0, p = !1;\n  a();\n  this.hc = function() {\n    a();\n    return d;\n  };\n  this.Mb = function(k) {\n    b.deleteTexture && b.deleteTexture(k);\n  };\n  this.Lb = function(k) {\n    if (!a()) {\n      return null;\n    }\n    const t = b.createTexture();\n    if (!t) {\n      return null;\n    }\n    b.bindTexture(b.TEXTURE_2D, t);\n    b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, k);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);\n    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);\n    2 == c ? (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR_MIPMAP_LINEAR), b.generateMipmap(b.TEXTURE_2D)) : b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);\n    return t;\n  };\n  const l = new ha(8), u = new ha(8), v = new ha(10), x = new ha(10);\n  this.Qb = function(k, t, r, B, D) {\n    if (a()) {\n      var w = l.push(k), M = u.push(t);\n      if (b.canvas) {\n        if (b.canvas.width != w || b.canvas.height != M) {\n          b.canvas.width = w, b.canvas.height = M;\n        }\n        b.viewport(0, M - t, k, t);\n        b.disable(b.SCISSOR_TEST);\n        b.clearColor(0, 0, 0, 0);\n        b.clear(b.COLOR_BUFFER_BIT);\n        b.enable(b.SCISSOR_TEST);\n        r.sort((H, ca) => ca.wb - H.wb);\n        w = v.push(B);\n        g != w && (b.bufferData(b.ARRAY_BUFFER, 8 * w, b.DYNAMIC_DRAW), g = w);\n        w = 0;\n        for (var T of r) {\n          b.bufferSubData(b.ARRAY_BUFFER, w, T.Ta), w += 4 * T.Ta.length;\n        }\n        console.assert(w == 4 * B);\n        for (var da of r) {\n          b.bufferSubData(b.ARRAY_BUFFER, w, da.Db), w += 4 * da.Db.length;\n        }\n        console.assert(w == 8 * B);\n        w = x.push(D);\n        n != w && (b.bufferData(b.ELEMENT_ARRAY_BUFFER, 2 * w, b.DYNAMIC_DRAW), n = w);\n        T = 0;\n        for (var ra of r) {\n          b.bufferSubData(b.ELEMENT_ARRAY_BUFFER, T, ra.indices), T += 2 * ra.indices.length;\n        }\n        console.assert(T == 2 * D);\n        ra = 0;\n        da = !0;\n        w = T = 0;\n        for (const H of r) {\n          H.image.Ka != ra && (b.bindTexture(b.TEXTURE_2D, H.image.Ja || null), ra = H.image.Ka);\n          H.mc ? (b.scissor(H.Ya, M - H.Za - H.jb, H.Ac, H.jb), da = !0) : da && (b.scissor(0, M - t, k, t), da = !1);\n          r = 2 / k;\n          const ca = -2 / t;\n          b.uniform4f(e, H.ha[0] * r * H.Ba, H.ha[1] * ca * H.Ca, H.ha[2] * r * H.Ba, H.ha[3] * ca * H.Ca);\n          b.uniform2f(f, H.ha[4] * r * H.Ba + r * (H.Ya - H.ic * H.Ba) - 1, H.ha[5] * ca * H.Ca + ca * (H.Za - H.jc * H.Ca) + 1);\n          b.vertexAttribPointer(0, 2, b.FLOAT, !1, 0, w);\n          b.vertexAttribPointer(1, 2, b.FLOAT, !1, 0, w + 4 * B);\n          b.drawElements(b.TRIANGLES, H.indices.length, b.UNSIGNED_SHORT, T);\n          w += 4 * H.Ta.length;\n          T += 2 * H.indices.length;\n        }\n        console.assert(w == 4 * B);\n        console.assert(T == 2 * D);\n      }\n    }\n  };\n  this.canvas = function() {\n    return a() && b.canvas;\n  };\n}(), la = m.onRuntimeInitialized;\nm.onRuntimeInitialized = function() {\n  function a(q) {\n    switch(q) {\n      case l.srcOver:\n        return \"source-over\";\n      case l.screen:\n        return \"screen\";\n      case l.overlay:\n        return \"overlay\";\n      case l.darken:\n        return \"darken\";\n      case l.lighten:\n        return \"lighten\";\n      case l.colorDodge:\n        return \"color-dodge\";\n      case l.colorBurn:\n        return \"color-burn\";\n      case l.hardLight:\n        return \"hard-light\";\n      case l.softLight:\n        return \"soft-light\";\n      case l.difference:\n        return \"difference\";\n      case l.exclusion:\n        return \"exclusion\";\n      case l.multiply:\n        return \"multiply\";\n      case l.hue:\n        return \"hue\";\n      case l.saturation:\n        return \"saturation\";\n      case l.color:\n        return \"color\";\n      case l.luminosity:\n        return \"luminosity\";\n    }\n  }\n  function b(q) {\n    return \"rgba(\" + ((16711680 & q) >>> 16) + \",\" + ((65280 & q) >>> 8) + \",\" + ((255 & q) >>> 0) + \",\" + ((4278190080 & q) >>> 24) / 255 + \")\";\n  }\n  function c() {\n    0 < M.length && (ka.Qb(w.drawWidth(), w.drawHeight(), M, T, da), M = [], da = T = 0, w.reset(512, 512));\n    for (const q of D) {\n      for (const y of q.H) {\n        y();\n      }\n      q.H = [];\n    }\n    D.clear();\n  }\n  la && la();\n  var d = m.RenderPaintStyle;\n  const e = m.RenderPath, f = m.RenderPaint, g = m.Renderer, n = m.StrokeCap, p = m.StrokeJoin, l = m.BlendMode, u = d.fill, v = d.stroke, x = m.FillRule.evenOdd;\n  let k = 1;\n  var t = m.RenderImage.extend(\"CanvasRenderImage\", {__construct:function({la:q, xa:y} = {}) {\n    this.__parent.__construct.call(this);\n    this.Ka = k;\n    k = k + 1 & 2147483647 || 1;\n    this.la = q;\n    this.xa = y;\n  }, __destruct:function() {\n    this.Ja && (ka.Mb(this.Ja), URL.revokeObjectURL(this.Wa));\n    this.__parent.__destruct.call(this);\n  }, decode:function(q) {\n    var y = this;\n    y.xa && y.xa(y);\n    var F = new Image();\n    y.Wa = URL.createObjectURL(new Blob([q], {type:\"image/png\",}));\n    F.onload = function() {\n      y.Fb = F;\n      y.Ja = ka.Lb(F);\n      y.size(F.width, F.height);\n      y.la && y.la(y);\n    };\n    F.src = y.Wa;\n  },}), r = e.extend(\"CanvasRenderPath\", {__construct:function() {\n    this.__parent.__construct.call(this);\n    this.T = new Path2D();\n  }, rewind:function() {\n    this.T = new Path2D();\n  }, addPath:function(q, y, F, G, A, I, J) {\n    var K = this.T, X = K.addPath;\n    q = q.T;\n    const Q = new DOMMatrix();\n    Q.a = y;\n    Q.b = F;\n    Q.c = G;\n    Q.d = A;\n    Q.e = I;\n    Q.f = J;\n    X.call(K, q, Q);\n  }, fillRule:function(q) {\n    this.Va = q;\n  }, moveTo:function(q, y) {\n    this.T.moveTo(q, y);\n  }, lineTo:function(q, y) {\n    this.T.lineTo(q, y);\n  }, cubicTo:function(q, y, F, G, A, I) {\n    this.T.bezierCurveTo(q, y, F, G, A, I);\n  }, close:function() {\n    this.T.closePath();\n  },}), B = f.extend(\"CanvasRenderPaint\", {color:function(q) {\n    this.Xa = b(q);\n  }, thickness:function(q) {\n    this.Ib = q;\n  }, join:function(q) {\n    switch(q) {\n      case p.miter:\n        this.Ia = \"miter\";\n        break;\n      case p.round:\n        this.Ia = \"round\";\n        break;\n      case p.bevel:\n        this.Ia = \"bevel\";\n    }\n  }, cap:function(q) {\n    switch(q) {\n      case n.butt:\n        this.Ha = \"butt\";\n        break;\n      case n.round:\n        this.Ha = \"round\";\n        break;\n      case n.square:\n        this.Ha = \"square\";\n    }\n  }, style:function(q) {\n    this.Hb = q;\n  }, blendMode:function(q) {\n    this.Eb = a(q);\n  }, clearGradient:function() {\n    this.ja = null;\n  }, linearGradient:function(q, y, F, G) {\n    this.ja = {yb:q, zb:y, bb:F, cb:G, Ra:[],};\n  }, radialGradient:function(q, y, F, G) {\n    this.ja = {yb:q, zb:y, bb:F, cb:G, Ra:[], ec:!0,};\n  }, addStop:function(q, y) {\n    this.ja.Ra.push({color:q, stop:y,});\n  }, completeGradient:function() {\n  }, draw:function(q, y, F) {\n    let G = this.Hb;\n    var A = this.Xa, I = this.ja;\n    q.globalCompositeOperation = this.Eb;\n    if (null != I) {\n      A = I.yb;\n      var J = I.zb;\n      const X = I.bb;\n      var K = I.cb;\n      const Q = I.Ra;\n      I.ec ? (I = X - A, K -= J, A = q.createRadialGradient(A, J, 0, A, J, Math.sqrt(I * I + K * K))) : A = q.createLinearGradient(A, J, X, K);\n      for (let ea = 0, R = Q.length; ea < R; ea++) {\n        J = Q[ea], A.addColorStop(J.stop, b(J.color));\n      }\n      this.Xa = A;\n      this.ja = null;\n    }\n    switch(G) {\n      case v:\n        q.strokeStyle = A;\n        q.lineWidth = this.Ib;\n        q.lineCap = this.Ha;\n        q.lineJoin = this.Ia;\n        q.stroke(y);\n        break;\n      case u:\n        q.fillStyle = A, q.fill(y, F);\n    }\n  },});\n  const D = new Set();\n  let w = null, M = [], T = 0, da = 0;\n  var ra = m.CanvasRenderer = g.extend(\"Renderer\", {__construct:function(q) {\n    this.__parent.__construct.call(this);\n    this.S = [1, 0, 0, 1, 0, 0];\n    this.C = q.getContext(\"2d\");\n    this.Ua = q;\n    this.H = [];\n  }, save:function() {\n    this.S.push(...this.S.slice(this.S.length - 6));\n    this.H.push(this.C.save.bind(this.C));\n  }, restore:function() {\n    const q = this.S.length - 6;\n    if (6 > q) {\n      throw \"restore() called without matching save().\";\n    }\n    this.S.splice(q);\n    this.H.push(this.C.restore.bind(this.C));\n  }, transform:function(q, y, F, G, A, I) {\n    const J = this.S, K = J.length - 6;\n    J.splice(K, 6, J[K] * q + J[K + 2] * y, J[K + 1] * q + J[K + 3] * y, J[K] * F + J[K + 2] * G, J[K + 1] * F + J[K + 3] * G, J[K] * A + J[K + 2] * I + J[K + 4], J[K + 1] * A + J[K + 3] * I + J[K + 5]);\n    this.H.push(this.C.transform.bind(this.C, q, y, F, G, A, I));\n  }, rotate:function(q) {\n    const y = Math.sin(q);\n    q = Math.cos(q);\n    this.transform(q, y, -y, q, 0, 0);\n  }, _drawPath:function(q, y) {\n    this.H.push(y.draw.bind(y, this.C, q.T, q.Va === x ? \"evenodd\" : \"nonzero\"));\n  }, _drawRiveImage:function(q, y, F) {\n    var G = q.Fb;\n    if (G) {\n      var A = this.C, I = a(y);\n      this.H.push(function() {\n        A.globalCompositeOperation = I;\n        A.globalAlpha = F;\n        A.drawImage(G, 0, 0);\n        A.globalAlpha = 1;\n      });\n    }\n  }, _getMatrix:function(q) {\n    const y = this.S, F = y.length - 6;\n    for (let G = 0; 6 > G; ++G) {\n      q[G] = y[F + G];\n    }\n  }, _drawImageMesh:function(q, y, F, G, A, I, J, K, X, Q) {\n    var ea = this.C.canvas.width, R = this.C.canvas.height;\n    const Yb = X - J, Zb = Q - K;\n    J = Math.max(J, 0);\n    K = Math.max(K, 0);\n    X = Math.min(X, ea);\n    Q = Math.min(Q, R);\n    const Ga = X - J, Ha = Q - K;\n    console.assert(Ga <= Math.min(Yb, ea));\n    console.assert(Ha <= Math.min(Zb, R));\n    if (!(0 >= Ga || 0 >= Ha)) {\n      X = Ga < Yb || Ha < Zb;\n      ea = Q = 1;\n      var sa = Math.ceil(Ga * Q), ta = Math.ceil(Ha * ea);\n      R = ka.hc();\n      sa > R && (Q *= R / sa, sa = R);\n      ta > R && (ea *= R / ta, ta = R);\n      w || (w = new m.DynamicRectanizer(R), w.reset(512, 512));\n      R = w.addRect(sa, ta);\n      0 > R && (c(), D.add(this), R = w.addRect(sa, ta), console.assert(0 <= R));\n      var $b = R & 65535, ac = R >> 16;\n      M.push({ha:this.S.slice(this.S.length - 6), image:q, Ya:$b, Za:ac, ic:J, jc:K, Ac:sa, jb:ta, Ba:Q, Ca:ea, Ta:new Float32Array(G), Db:new Float32Array(A), indices:new Uint16Array(I), mc:X, wb:q.Ka << 1 | (X ? 1 : 0),});\n      T += G.length;\n      da += I.length;\n      var za = this.C, qd = a(y);\n      this.H.push(function() {\n        za.save();\n        za.resetTransform();\n        za.globalCompositeOperation = qd;\n        za.globalAlpha = F;\n        const bc = ka.canvas();\n        bc && za.drawImage(bc, $b, ac, sa, ta, J, K, Ga, Ha);\n        za.restore();\n      });\n    }\n  }, _clipPath:function(q) {\n    this.H.push(this.C.clip.bind(this.C, q.T, q.Va === x ? \"evenodd\" : \"nonzero\"));\n  }, clear:function() {\n    D.add(this);\n    this.H.push(this.C.clearRect.bind(this.C, 0, 0, this.Ua.width, this.Ua.height));\n  }, flush:function() {\n  }, translate:function(q, y) {\n    this.transform(1, 0, 0, 1, q, y);\n  },});\n  m.makeRenderer = function(q) {\n    const y = new ra(q), F = y.C;\n    return new Proxy(y, {get(G, A) {\n      if (\"function\" === typeof G[A]) {\n        return function(...I) {\n          return G[A].apply(G, I);\n        };\n      }\n      if (\"function\" === typeof F[A]) {\n        if (-1 < ja.indexOf(A)) {\n          throw Error(\"RiveException: Method call to '\" + A + \"()' is not allowed, as the renderer cannot immediately pass through the return                 values of any canvas 2d context methods.\");\n        }\n        return function(...I) {\n          y.H.push(F[A].bind(F, ...I));\n        };\n      }\n      return G[A];\n    }, set(G, A, I) {\n      if (A in F) {\n        return y.H.push(() => {\n          F[A] = I;\n        }), !0;\n      }\n    },});\n  };\n  m.decodeImage = function(q, y) {\n    (new t({la:y})).decode(q);\n  };\n  m.renderFactory = {makeRenderPaint:function() {\n    return new B();\n  }, makeRenderPath:function() {\n    return new r();\n  }, makeRenderImage:function() {\n    let q = ca;\n    return new t({xa:() => {\n      q.total++;\n    }, la:() => {\n      q.loaded++;\n      if (q.loaded === q.total) {\n        const y = q.ready;\n        y && (y(), q.ready = null);\n      }\n    },});\n  },};\n  let H = m.load, ca = null;\n  m.load = function(q, y, F = !0) {\n    const G = new m.FallbackFileAssetLoader();\n    void 0 !== y && G.addLoader(y);\n    F && (y = new m.CDNFileAssetLoader(), G.addLoader(y));\n    return new Promise(function(A) {\n      let I = null;\n      ca = {total:0, loaded:0, ready:function() {\n        A(I);\n      },};\n      I = H(q, G);\n      0 == ca.total && A(I);\n    });\n  };\n  let rd = m.RendererWrapper.prototype.align;\n  m.RendererWrapper.prototype.align = function(q, y, F, G, A = 1.0) {\n    rd.call(this, q, y, F, G, A);\n  };\n  d = new fa();\n  m.requestAnimationFrame = d.requestAnimationFrame.bind(d);\n  m.cancelAnimationFrame = d.cancelAnimationFrame.bind(d);\n  m.enableFPSCounter = d.Rb.bind(d);\n  m.disableFPSCounter = d.Ob;\n  d.ob = c;\n  m.resolveAnimationFrame = c;\n  m.cleanup = function() {\n    w && w.delete();\n  };\n};\nvar ma = Object.assign({}, m), na = \"./this.program\", oa = \"object\" == typeof window, pa = \"function\" == typeof importScripts, qa = \"\", ua, va;\nif (oa || pa) {\n  pa ? qa = self.location.href : \"undefined\" != typeof document && document.currentScript && (qa = document.currentScript.src), _scriptDir && (qa = _scriptDir), 0 !== qa.indexOf(\"blob:\") ? qa = qa.substr(0, qa.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : qa = \"\", pa && (va = a => {\n    var b = new XMLHttpRequest();\n    b.open(\"GET\", a, !1);\n    b.responseType = \"arraybuffer\";\n    b.send(null);\n    return new Uint8Array(b.response);\n  }), ua = (a, b, c) => {\n    var d = new XMLHttpRequest();\n    d.open(\"GET\", a, !0);\n    d.responseType = \"arraybuffer\";\n    d.onload = () => {\n      200 == d.status || 0 == d.status && d.response ? b(d.response) : c();\n    };\n    d.onerror = c;\n    d.send(null);\n  };\n}\nvar wa = m.print || console.log.bind(console), xa = m.printErr || console.error.bind(console);\nObject.assign(m, ma);\nma = null;\nm.thisProgram && (na = m.thisProgram);\nvar ya;\nm.wasmBinary && (ya = m.wasmBinary);\nvar noExitRuntime = m.noExitRuntime || !0;\n\"object\" != typeof WebAssembly && Aa(\"no native wasm support detected\");\nvar Ba, z, Ca = !1, C, E, Da, Ea, L, N, Fa, Ia;\nfunction Ja() {\n  var a = Ba.buffer;\n  m.HEAP8 = C = new Int8Array(a);\n  m.HEAP16 = Da = new Int16Array(a);\n  m.HEAP32 = L = new Int32Array(a);\n  m.HEAPU8 = E = new Uint8Array(a);\n  m.HEAPU16 = Ea = new Uint16Array(a);\n  m.HEAPU32 = N = new Uint32Array(a);\n  m.HEAPF32 = Fa = new Float32Array(a);\n  m.HEAPF64 = Ia = new Float64Array(a);\n}\nvar Ka, La = [], Ma = [], Na = [];\nfunction Oa() {\n  var a = m.preRun.shift();\n  La.unshift(a);\n}\nvar Pa = 0, Qa = null, Ra = null;\nfunction Aa(a) {\n  if (m.onAbort) {\n    m.onAbort(a);\n  }\n  a = \"Aborted(\" + a + \")\";\n  xa(a);\n  Ca = !0;\n  a = new WebAssembly.RuntimeError(a + \". Build with -sASSERTIONS for more info.\");\n  ba(a);\n  throw a;\n}\nfunction Sa(a) {\n  return a.startsWith(\"data:application/octet-stream;base64,\");\n}\nvar Ta;\nTa = \"canvas_advanced.wasm\";\nif (!Sa(Ta)) {\n  var Ua = Ta;\n  Ta = m.locateFile ? m.locateFile(Ua, qa) : qa + Ua;\n}\nfunction Va(a) {\n  if (a == Ta && ya) {\n    return new Uint8Array(ya);\n  }\n  if (va) {\n    return va(a);\n  }\n  throw \"both async and sync fetching of the wasm failed\";\n}\nfunction Wa(a) {\n  if (!ya && (oa || pa)) {\n    if (\"function\" == typeof fetch && !a.startsWith(\"file://\")) {\n      return fetch(a, {credentials:\"same-origin\"}).then(b => {\n        if (!b.ok) {\n          throw \"failed to load wasm binary file at '\" + a + \"'\";\n        }\n        return b.arrayBuffer();\n      }).catch(() => Va(a));\n    }\n    if (ua) {\n      return new Promise((b, c) => {\n        ua(a, d => b(new Uint8Array(d)), c);\n      });\n    }\n  }\n  return Promise.resolve().then(() => Va(a));\n}\nfunction Xa(a, b, c) {\n  return Wa(a).then(d => WebAssembly.instantiate(d, b)).then(d => d).then(c, d => {\n    xa(\"failed to asynchronously prepare wasm: \" + d);\n    Aa(d);\n  });\n}\nfunction Ya(a, b) {\n  var c = Ta;\n  return ya || \"function\" != typeof WebAssembly.instantiateStreaming || Sa(c) || c.startsWith(\"file://\") || \"function\" != typeof fetch ? Xa(c, a, b) : fetch(c, {credentials:\"same-origin\"}).then(d => WebAssembly.instantiateStreaming(d, a).then(b, function(e) {\n    xa(\"wasm streaming compile failed: \" + e);\n    xa(\"falling back to ArrayBuffer instantiation\");\n    return Xa(c, a, b);\n  }));\n}\nvar Za, $a, db = {449484:(a, b, c, d, e) => {\n  if (\"undefined\" === typeof window || void 0 === (window.AudioContext || window.webkitAudioContext)) {\n    return 0;\n  }\n  if (\"undefined\" === typeof window.h) {\n    window.h = {Aa:0};\n    window.h.I = {};\n    window.h.I.ya = a;\n    window.h.I.capture = b;\n    window.h.I.La = c;\n    window.h.ga = {};\n    window.h.ga.stopped = d;\n    window.h.ga.xb = e;\n    let f = window.h;\n    f.D = [];\n    f.yc = function(g) {\n      for (var n = 0; n < f.D.length; ++n) {\n        if (null == f.D[n]) {\n          return f.D[n] = g, n;\n        }\n      }\n      f.D.push(g);\n      return f.D.length - 1;\n    };\n    f.Cb = function(g) {\n      for (f.D[g] = null; 0 < f.D.length;) {\n        if (null == f.D[f.D.length - 1]) {\n          f.D.pop();\n        } else {\n          break;\n        }\n      }\n    };\n    f.Sc = function(g) {\n      for (var n = 0; n < f.D.length; ++n) {\n        if (f.D[n] == g) {\n          return f.Cb(n);\n        }\n      }\n    };\n    f.ra = function(g) {\n      return f.D[g];\n    };\n    f.Bb = [\"touchend\", \"click\"];\n    f.unlock = function() {\n      for (var g = 0; g < f.D.length; ++g) {\n        var n = f.D[g];\n        null != n && null != n.J && n.state === f.ga.xb && n.J.resume().then(() => {\n          ab(n.pb);\n        }, p => {\n          console.error(\"Failed to resume audiocontext\", p);\n        });\n      }\n      f.Bb.map(function(p) {\n        document.removeEventListener(p, f.unlock, !0);\n      });\n    };\n    f.Bb.map(function(g) {\n      document.addEventListener(g, f.unlock, !0);\n    });\n  }\n  window.h.Aa += 1;\n  return 1;\n}, 451662:() => {\n  \"undefined\" !== typeof window.h && (--window.h.Aa, 0 === window.h.Aa && delete window.h);\n}, 451826:() => void 0 !== navigator.mediaDevices && void 0 !== navigator.mediaDevices.getUserMedia, 451930:() => {\n  try {\n    var a = new (window.AudioContext || window.webkitAudioContext)(), b = a.sampleRate;\n    a.close();\n    return b;\n  } catch (c) {\n    return 0;\n  }\n}, 452101:(a, b, c, d, e, f) => {\n  if (\"undefined\" === typeof window.h) {\n    return -1;\n  }\n  var g = {}, n = {};\n  a == window.h.I.ya && 0 != c && (n.sampleRate = c);\n  g.J = new (window.AudioContext || window.webkitAudioContext)(n);\n  g.J.suspend();\n  g.state = window.h.ga.stopped;\n  c = 0;\n  a != window.h.I.ya && (c = b);\n  g.Z = g.J.createScriptProcessor(d, c, b);\n  g.Z.onaudioprocess = function(p) {\n    if (null == g.sa || 0 == g.sa.length) {\n      g.sa = new Float32Array(Fa.buffer, e, d * b);\n    }\n    if (a == window.h.I.capture || a == window.h.I.La) {\n      for (var l = 0; l < b; l += 1) {\n        for (var u = p.inputBuffer.getChannelData(l), v = g.sa, x = 0; x < d; x += 1) {\n          v[x * b + l] = u[x];\n        }\n      }\n      bb(f, d, e);\n    }\n    if (a == window.h.I.ya || a == window.h.I.La) {\n      for (cb(f, d, e), l = 0; l < p.outputBuffer.numberOfChannels; ++l) {\n        for (u = p.outputBuffer.getChannelData(l), v = g.sa, x = 0; x < d; x += 1) {\n          u[x] = v[x * b + l];\n        }\n      }\n    } else {\n      for (l = 0; l < p.outputBuffer.numberOfChannels; ++l) {\n        p.outputBuffer.getChannelData(l).fill(0.0);\n      }\n    }\n  };\n  a != window.h.I.capture && a != window.h.I.La || navigator.mediaDevices.getUserMedia({audio:!0, video:!1}).then(function(p) {\n    g.Da = g.J.createMediaStreamSource(p);\n    g.Da.connect(g.Z);\n    g.Z.connect(g.J.destination);\n  }).catch(function(p) {\n    console.log(\"Failed to get user media: \" + p);\n  });\n  a == window.h.I.ya && g.Z.connect(g.J.destination);\n  g.pb = f;\n  return window.h.yc(g);\n}, 454978:a => window.h.ra(a).J.sampleRate, 455051:a => {\n  a = window.h.ra(a);\n  void 0 !== a.Z && (a.Z.onaudioprocess = function() {\n  }, a.Z.disconnect(), a.Z = void 0);\n  void 0 !== a.Da && (a.Da.disconnect(), a.Da = void 0);\n  a.J.close();\n  a.J = void 0;\n  a.pb = void 0;\n}, 455451:a => {\n  window.h.Cb(a);\n}, 455501:a => {\n  a = window.h.ra(a);\n  a.J.resume();\n  a.state = window.h.ga.xb;\n}, 455640:a => {\n  a = window.h.ra(a);\n  a.J.suspend();\n  a.state = window.h.ga.stopped;\n}}, eb = a => {\n  for (; 0 < a.length;) {\n    a.shift()(m);\n  }\n}, fb = (a, b) => {\n  for (var c = 0, d = a.length - 1; 0 <= d; d--) {\n    var e = a[d];\n    \".\" === e ? a.splice(d, 1) : \"..\" === e ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);\n  }\n  if (b) {\n    for (; c; c--) {\n      a.unshift(\"..\");\n    }\n  }\n  return a;\n}, gb = a => {\n  var b = \"/\" === a.charAt(0), c = \"/\" === a.substr(-1);\n  (a = fb(a.split(\"/\").filter(d => !!d), !b).join(\"/\")) || b || (a = \".\");\n  a && c && (a += \"/\");\n  return (b ? \"/\" : \"\") + a;\n}, hb = a => {\n  var b = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/.exec(a).slice(1);\n  a = b[0];\n  b = b[1];\n  if (!a && !b) {\n    return \".\";\n  }\n  b && (b = b.substr(0, b.length - 1));\n  return a + b;\n}, ib = a => {\n  if (\"/\" === a) {\n    return \"/\";\n  }\n  a = gb(a);\n  a = a.replace(/\\/$/, \"\");\n  var b = a.lastIndexOf(\"/\");\n  return -1 === b ? a : a.substr(b + 1);\n}, jb = () => {\n  if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) {\n    return a => crypto.getRandomValues(a);\n  }\n  Aa(\"initRandomDevice\");\n}, kb = a => (kb = jb())(a);\nfunction lb() {\n  for (var a = \"\", b = !1, c = arguments.length - 1; -1 <= c && !b; c--) {\n    b = 0 <= c ? arguments[c] : \"/\";\n    if (\"string\" != typeof b) {\n      throw new TypeError(\"Arguments to path.resolve must be strings\");\n    }\n    if (!b) {\n      return \"\";\n    }\n    a = b + \"/\" + a;\n    b = \"/\" === b.charAt(0);\n  }\n  a = fb(a.split(\"/\").filter(d => !!d), !b).join(\"/\");\n  return (b ? \"/\" : \"\") + a || \".\";\n}\nvar mb = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0, nb = (a, b, c) => {\n  var d = b + c;\n  for (c = b; a[c] && !(c >= d);) {\n    ++c;\n  }\n  if (16 < c - b && a.buffer && mb) {\n    return mb.decode(a.subarray(b, c));\n  }\n  for (d = \"\"; b < c;) {\n    var e = a[b++];\n    if (e & 128) {\n      var f = a[b++] & 63;\n      if (192 == (e & 224)) {\n        d += String.fromCharCode((e & 31) << 6 | f);\n      } else {\n        var g = a[b++] & 63;\n        e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | g : (e & 7) << 18 | f << 12 | g << 6 | a[b++] & 63;\n        65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));\n      }\n    } else {\n      d += String.fromCharCode(e);\n    }\n  }\n  return d;\n}, ob = [], pb = a => {\n  for (var b = 0, c = 0; c < a.length; ++c) {\n    var d = a.charCodeAt(c);\n    127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;\n  }\n  return b;\n}, qb = (a, b, c, d) => {\n  if (!(0 < d)) {\n    return 0;\n  }\n  var e = c;\n  d = c + d - 1;\n  for (var f = 0; f < a.length; ++f) {\n    var g = a.charCodeAt(f);\n    if (55296 <= g && 57343 >= g) {\n      var n = a.charCodeAt(++f);\n      g = 65536 + ((g & 1023) << 10) | n & 1023;\n    }\n    if (127 >= g) {\n      if (c >= d) {\n        break;\n      }\n      b[c++] = g;\n    } else {\n      if (2047 >= g) {\n        if (c + 1 >= d) {\n          break;\n        }\n        b[c++] = 192 | g >> 6;\n      } else {\n        if (65535 >= g) {\n          if (c + 2 >= d) {\n            break;\n          }\n          b[c++] = 224 | g >> 12;\n        } else {\n          if (c + 3 >= d) {\n            break;\n          }\n          b[c++] = 240 | g >> 18;\n          b[c++] = 128 | g >> 12 & 63;\n        }\n        b[c++] = 128 | g >> 6 & 63;\n      }\n      b[c++] = 128 | g & 63;\n    }\n  }\n  b[c] = 0;\n  return c - e;\n};\nfunction rb(a, b) {\n  var c = Array(pb(a) + 1);\n  a = qb(a, c, 0, c.length);\n  b && (c.length = a);\n  return c;\n}\nvar sb = [];\nfunction tb(a, b) {\n  sb[a] = {input:[], F:[], V:b};\n  ub(a, vb);\n}\nvar vb = {open:function(a) {\n  var b = sb[a.node.za];\n  if (!b) {\n    throw new O(43);\n  }\n  a.s = b;\n  a.seekable = !1;\n}, close:function(a) {\n  a.s.V.qa(a.s);\n}, qa:function(a) {\n  a.s.V.qa(a.s);\n}, read:function(a, b, c, d) {\n  if (!a.s || !a.s.V.ib) {\n    throw new O(60);\n  }\n  for (var e = 0, f = 0; f < d; f++) {\n    try {\n      var g = a.s.V.ib(a.s);\n    } catch (n) {\n      throw new O(29);\n    }\n    if (void 0 === g && 0 === e) {\n      throw new O(6);\n    }\n    if (null === g || void 0 === g) {\n      break;\n    }\n    e++;\n    b[c + f] = g;\n  }\n  e && (a.node.timestamp = Date.now());\n  return e;\n}, write:function(a, b, c, d) {\n  if (!a.s || !a.s.V.Oa) {\n    throw new O(60);\n  }\n  try {\n    for (var e = 0; e < d; e++) {\n      a.s.V.Oa(a.s, b[c + e]);\n    }\n  } catch (f) {\n    throw new O(29);\n  }\n  d && (a.node.timestamp = Date.now());\n  return e;\n},}, wb = {ib:function() {\n  a: {\n    if (!ob.length) {\n      var a = null;\n      \"undefined\" != typeof window && \"function\" == typeof window.prompt ? (a = window.prompt(\"Input: \"), null !== a && (a += \"\\n\")) : \"function\" == typeof readline && (a = readline(), null !== a && (a += \"\\n\"));\n      if (!a) {\n        a = null;\n        break a;\n      }\n      ob = rb(a, !0);\n    }\n    a = ob.shift();\n  }\n  return a;\n}, Oa:function(a, b) {\n  null === b || 10 === b ? (wa(nb(a.F, 0)), a.F = []) : 0 != b && a.F.push(b);\n}, qa:function(a) {\n  a.F && 0 < a.F.length && (wa(nb(a.F, 0)), a.F = []);\n}, bc:function() {\n  return {Fc:25856, Hc:5, Ec:191, Gc:35387, Dc:[3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]};\n}, cc:function() {\n  return 0;\n}, dc:function() {\n  return [24, 80];\n},}, xb = {Oa:function(a, b) {\n  null === b || 10 === b ? (xa(nb(a.F, 0)), a.F = []) : 0 != b && a.F.push(b);\n}, qa:function(a) {\n  a.F && 0 < a.F.length && (xa(nb(a.F, 0)), a.F = []);\n},};\nfunction yb(a, b) {\n  var c = a.j ? a.j.length : 0;\n  c >= b || (b = Math.max(b, c * (1048576 > c ? 2.0 : 1.125) >>> 0), 0 != c && (b = Math.max(b, 256)), c = a.j, a.j = new Uint8Array(b), 0 < a.v && a.j.set(c.subarray(0, a.v), 0));\n}\nvar P = {O:null, U() {\n  return P.createNode(null, \"/\", 16895, 0);\n}, createNode(a, b, c, d) {\n  if (24576 === (c & 61440) || 4096 === (c & 61440)) {\n    throw new O(63);\n  }\n  P.O || (P.O = {dir:{node:{Y:P.l.Y, P:P.l.P, ka:P.l.ka, va:P.l.va, ub:P.l.ub, Ab:P.l.Ab, vb:P.l.vb, sb:P.l.sb, Ea:P.l.Ea}, stream:{ba:P.m.ba}}, file:{node:{Y:P.l.Y, P:P.l.P}, stream:{ba:P.m.ba, read:P.m.read, write:P.m.write, pa:P.m.pa, lb:P.m.lb, nb:P.m.nb}}, link:{node:{Y:P.l.Y, P:P.l.P, ma:P.l.ma}, stream:{}}, $a:{node:{Y:P.l.Y, P:P.l.P}, stream:zb}});\n  c = Ab(a, b, c, d);\n  16384 === (c.mode & 61440) ? (c.l = P.O.dir.node, c.m = P.O.dir.stream, c.j = {}) : 32768 === (c.mode & 61440) ? (c.l = P.O.file.node, c.m = P.O.file.stream, c.v = 0, c.j = null) : 40960 === (c.mode & 61440) ? (c.l = P.O.link.node, c.m = P.O.link.stream) : 8192 === (c.mode & 61440) && (c.l = P.O.$a.node, c.m = P.O.$a.stream);\n  c.timestamp = Date.now();\n  a && (a.j[b] = c, a.timestamp = c.timestamp);\n  return c;\n}, Kc(a) {\n  return a.j ? a.j.subarray ? a.j.subarray(0, a.v) : new Uint8Array(a.j) : new Uint8Array(0);\n}, l:{Y(a) {\n  var b = {};\n  b.Jc = 8192 === (a.mode & 61440) ? a.id : 1;\n  b.Mc = a.id;\n  b.mode = a.mode;\n  b.Oc = 1;\n  b.uid = 0;\n  b.Lc = 0;\n  b.za = a.za;\n  16384 === (a.mode & 61440) ? b.size = 4096 : 32768 === (a.mode & 61440) ? b.size = a.v : 40960 === (a.mode & 61440) ? b.size = a.link.length : b.size = 0;\n  b.Bc = new Date(a.timestamp);\n  b.Nc = new Date(a.timestamp);\n  b.Ic = new Date(a.timestamp);\n  b.Jb = 4096;\n  b.Cc = Math.ceil(b.size / b.Jb);\n  return b;\n}, P(a, b) {\n  void 0 !== b.mode && (a.mode = b.mode);\n  void 0 !== b.timestamp && (a.timestamp = b.timestamp);\n  if (void 0 !== b.size && (b = b.size, a.v != b)) {\n    if (0 == b) {\n      a.j = null, a.v = 0;\n    } else {\n      var c = a.j;\n      a.j = new Uint8Array(b);\n      c && a.j.set(c.subarray(0, Math.min(b, a.v)));\n      a.v = b;\n    }\n  }\n}, ka() {\n  throw Bb[44];\n}, va(a, b, c, d) {\n  return P.createNode(a, b, c, d);\n}, ub(a, b, c) {\n  if (16384 === (a.mode & 61440)) {\n    try {\n      var d = Cb(b, c);\n    } catch (f) {\n    }\n    if (d) {\n      for (var e in d.j) {\n        throw new O(55);\n      }\n    }\n  }\n  delete a.parent.j[a.name];\n  a.parent.timestamp = Date.now();\n  a.name = c;\n  b.j[c] = a;\n  b.timestamp = a.parent.timestamp;\n  a.parent = b;\n}, Ab(a, b) {\n  delete a.j[b];\n  a.timestamp = Date.now();\n}, vb(a, b) {\n  var c = Cb(a, b), d;\n  for (d in c.j) {\n    throw new O(55);\n  }\n  delete a.j[b];\n  a.timestamp = Date.now();\n}, sb(a) {\n  var b = [\".\", \"..\"], c;\n  for (c in a.j) {\n    a.j.hasOwnProperty(c) && b.push(c);\n  }\n  return b;\n}, Ea(a, b, c) {\n  a = P.createNode(a, b, 41471, 0);\n  a.link = c;\n  return a;\n}, ma(a) {\n  if (40960 !== (a.mode & 61440)) {\n    throw new O(28);\n  }\n  return a.link;\n},}, m:{read(a, b, c, d, e) {\n  var f = a.node.j;\n  if (e >= a.node.v) {\n    return 0;\n  }\n  a = Math.min(a.node.v - e, d);\n  if (8 < a && f.subarray) {\n    b.set(f.subarray(e, e + a), c);\n  } else {\n    for (d = 0; d < a; d++) {\n      b[c + d] = f[e + d];\n    }\n  }\n  return a;\n}, write(a, b, c, d, e, f) {\n  b.buffer === C.buffer && (f = !1);\n  if (!d) {\n    return 0;\n  }\n  a = a.node;\n  a.timestamp = Date.now();\n  if (b.subarray && (!a.j || a.j.subarray)) {\n    if (f) {\n      return a.j = b.subarray(c, c + d), a.v = d;\n    }\n    if (0 === a.v && 0 === e) {\n      return a.j = b.slice(c, c + d), a.v = d;\n    }\n    if (e + d <= a.v) {\n      return a.j.set(b.subarray(c, c + d), e), d;\n    }\n  }\n  yb(a, e + d);\n  if (a.j.subarray && b.subarray) {\n    a.j.set(b.subarray(c, c + d), e);\n  } else {\n    for (f = 0; f < d; f++) {\n      a.j[e + f] = b[c + f];\n    }\n  }\n  a.v = Math.max(a.v, e + d);\n  return d;\n}, ba(a, b, c) {\n  1 === c ? b += a.position : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.v);\n  if (0 > b) {\n    throw new O(28);\n  }\n  return b;\n}, pa(a, b, c) {\n  yb(a.node, b + c);\n  a.node.v = Math.max(a.node.v, b + c);\n}, lb(a, b, c, d, e) {\n  if (32768 !== (a.node.mode & 61440)) {\n    throw new O(43);\n  }\n  a = a.node.j;\n  if (e & 2 || a.buffer !== C.buffer) {\n    if (0 < c || c + b < a.length) {\n      a.subarray ? a = a.subarray(c, c + b) : a = Array.prototype.slice.call(a, c, c + b);\n    }\n    c = !0;\n    Aa();\n    b = void 0;\n    if (!b) {\n      throw new O(48);\n    }\n    C.set(a, b);\n  } else {\n    c = !1, b = a.byteOffset;\n  }\n  return {o:b, M:c};\n}, nb(a, b, c, d) {\n  P.m.write(a, b, 0, d, c, !1);\n  return 0;\n},},};\nfunction Db(a, b) {\n  var c = 0;\n  a && (c |= 365);\n  b && (c |= 146);\n  return c;\n}\nvar Eb = null, Fb = {}, Gb = [], Hb = 1, Ib = null, Jb = !0, O = null, Bb = {}, Lb = (a, b = {}) => {\n  a = lb(a);\n  if (!a) {\n    return {path:\"\", node:null};\n  }\n  b = Object.assign({gb:!0, Qa:0}, b);\n  if (8 < b.Qa) {\n    throw new O(32);\n  }\n  a = a.split(\"/\").filter(g => !!g);\n  for (var c = Eb, d = \"/\", e = 0; e < a.length; e++) {\n    var f = e === a.length - 1;\n    if (f && b.parent) {\n      break;\n    }\n    c = Cb(c, a[e]);\n    d = gb(d + \"/\" + a[e]);\n    c.wa && (!f || f && b.gb) && (c = c.wa.root);\n    if (!f || b.fb) {\n      for (f = 0; 40960 === (c.mode & 61440);) {\n        if (c = Kb(d), d = lb(hb(d), c), c = Lb(d, {Qa:b.Qa + 1}).node, 40 < f++) {\n          throw new O(32);\n        }\n      }\n    }\n  }\n  return {path:d, node:c};\n}, Mb = a => {\n  for (var b;;) {\n    if (a === a.parent) {\n      return a = a.U.mb, b ? \"/\" !== a[a.length - 1] ? `${a}/${b}` : a + b : a;\n    }\n    b = b ? `${a.name}/${b}` : a.name;\n    a = a.parent;\n  }\n}, Nb = (a, b) => {\n  for (var c = 0, d = 0; d < b.length; d++) {\n    c = (c << 5) - c + b.charCodeAt(d) | 0;\n  }\n  return (a + c >>> 0) % Ib.length;\n}, Cb = (a, b) => {\n  var c;\n  if (c = (c = Ob(a, \"x\")) ? c : a.l.ka ? 0 : 2) {\n    throw new O(c, a);\n  }\n  for (c = Ib[Nb(a.id, b)]; c; c = c.lc) {\n    var d = c.name;\n    if (c.parent.id === a.id && d === b) {\n      return c;\n    }\n  }\n  return a.l.ka(a, b);\n}, Ab = (a, b, c, d) => {\n  a = new Pb(a, b, c, d);\n  b = Nb(a.parent.id, a.name);\n  a.lc = Ib[b];\n  return Ib[b] = a;\n}, Qb = a => {\n  var b = [\"r\", \"w\", \"rw\"][a & 3];\n  a & 512 && (b += \"w\");\n  return b;\n}, Ob = (a, b) => {\n  if (Jb) {\n    return 0;\n  }\n  if (!b.includes(\"r\") || a.mode & 292) {\n    if (b.includes(\"w\") && !(a.mode & 146) || b.includes(\"x\") && !(a.mode & 73)) {\n      return 2;\n    }\n  } else {\n    return 2;\n  }\n  return 0;\n}, Rb = (a, b) => {\n  try {\n    return Cb(a, b), 20;\n  } catch (c) {\n  }\n  return Ob(a, \"wx\");\n}, Sb = () => {\n  for (var a = 0; 4096 >= a; a++) {\n    if (!Gb[a]) {\n      return a;\n    }\n  }\n  throw new O(33);\n}, Tb = a => {\n  a = Gb[a];\n  if (!a) {\n    throw new O(8);\n  }\n  return a;\n}, Vb = (a, b = -1) => {\n  Ub || (Ub = function() {\n    this.h = {};\n  }, Ub.prototype = {}, Object.defineProperties(Ub.prototype, {object:{get() {\n    return this.node;\n  }, set(c) {\n    this.node = c;\n  }}, flags:{get() {\n    return this.h.flags;\n  }, set(c) {\n    this.h.flags = c;\n  },}, position:{get() {\n    return this.h.position;\n  }, set(c) {\n    this.h.position = c;\n  },},}));\n  a = Object.assign(new Ub(), a);\n  -1 == b && (b = Sb());\n  a.X = b;\n  return Gb[b] = a;\n}, zb = {open:a => {\n  a.m = Fb[a.node.za].m;\n  a.m.open && a.m.open(a);\n}, ba:() => {\n  throw new O(70);\n},}, ub = (a, b) => {\n  Fb[a] = {m:b};\n}, Wb = (a, b) => {\n  var c = \"/\" === b, d = !b;\n  if (c && Eb) {\n    throw new O(10);\n  }\n  if (!c && !d) {\n    var e = Lb(b, {gb:!1});\n    b = e.path;\n    e = e.node;\n    if (e.wa) {\n      throw new O(10);\n    }\n    if (16384 !== (e.mode & 61440)) {\n      throw new O(54);\n    }\n  }\n  b = {type:a, Qc:{}, mb:b, kc:[]};\n  a = a.U(b);\n  a.U = b;\n  b.root = a;\n  c ? Eb = a : e && (e.wa = b, e.U && e.U.kc.push(b));\n}, S = (a, b, c) => {\n  var d = Lb(a, {parent:!0}).node;\n  a = ib(a);\n  if (!a || \".\" === a || \"..\" === a) {\n    throw new O(28);\n  }\n  var e = Rb(d, a);\n  if (e) {\n    throw new O(e);\n  }\n  if (!d.l.va) {\n    throw new O(63);\n  }\n  return d.l.va(d, a, b, c);\n}, Xb = (a, b, c) => {\n  \"undefined\" == typeof c && (c = b, b = 438);\n  S(a, b | 8192, c);\n}, cc = (a, b) => {\n  if (!lb(a)) {\n    throw new O(44);\n  }\n  var c = Lb(b, {parent:!0}).node;\n  if (!c) {\n    throw new O(44);\n  }\n  b = ib(b);\n  var d = Rb(c, b);\n  if (d) {\n    throw new O(d);\n  }\n  if (!c.l.Ea) {\n    throw new O(63);\n  }\n  c.l.Ea(c, b, a);\n}, Kb = a => {\n  a = Lb(a).node;\n  if (!a) {\n    throw new O(44);\n  }\n  if (!a.l.ma) {\n    throw new O(28);\n  }\n  return lb(Mb(a.parent), a.l.ma(a));\n}, ec = (a, b, c) => {\n  if (\"\" === a) {\n    throw new O(44);\n  }\n  if (\"string\" == typeof b) {\n    var d = {r:0, \"r+\":2, w:577, \"w+\":578, a:1089, \"a+\":1090,}[b];\n    if (\"undefined\" == typeof d) {\n      throw Error(`Unknown file open mode: ${b}`);\n    }\n    b = d;\n  }\n  c = b & 64 ? (\"undefined\" == typeof c ? 438 : c) & 4095 | 32768 : 0;\n  if (\"object\" == typeof a) {\n    var e = a;\n  } else {\n    a = gb(a);\n    try {\n      e = Lb(a, {fb:!(b & 131072)}).node;\n    } catch (f) {\n    }\n  }\n  d = !1;\n  if (b & 64) {\n    if (e) {\n      if (b & 128) {\n        throw new O(20);\n      }\n    } else {\n      e = S(a, c, 0), d = !0;\n    }\n  }\n  if (!e) {\n    throw new O(44);\n  }\n  8192 === (e.mode & 61440) && (b &= -513);\n  if (b & 65536 && 16384 !== (e.mode & 61440)) {\n    throw new O(54);\n  }\n  if (!d && (c = e ? 40960 === (e.mode & 61440) ? 32 : 16384 === (e.mode & 61440) && (\"r\" !== Qb(b) || b & 512) ? 31 : Ob(e, Qb(b)) : 44)) {\n    throw new O(c);\n  }\n  if (b & 512 && !d) {\n    c = e;\n    c = \"string\" == typeof c ? Lb(c, {fb:!0}).node : c;\n    if (!c.l.P) {\n      throw new O(63);\n    }\n    if (16384 === (c.mode & 61440)) {\n      throw new O(31);\n    }\n    if (32768 !== (c.mode & 61440)) {\n      throw new O(28);\n    }\n    if (d = Ob(c, \"w\")) {\n      throw new O(d);\n    }\n    c.l.P(c, {size:0, timestamp:Date.now()});\n  }\n  b &= -131713;\n  e = Vb({node:e, path:Mb(e), flags:b, seekable:!0, position:0, m:e.m, zc:[], error:!1});\n  e.m.open && e.m.open(e);\n  !m.logReadFiles || b & 1 || (dc || (dc = {}), a in dc || (dc[a] = 1));\n  return e;\n}, fc = (a, b, c) => {\n  if (null === a.X) {\n    throw new O(8);\n  }\n  if (!a.seekable || !a.m.ba) {\n    throw new O(70);\n  }\n  if (0 != c && 1 != c && 2 != c) {\n    throw new O(28);\n  }\n  a.position = a.m.ba(a, b, c);\n  a.zc = [];\n}, gc = () => {\n  O || (O = function(a, b) {\n    this.name = \"ErrnoError\";\n    this.node = b;\n    this.pc = function(c) {\n      this.aa = c;\n    };\n    this.pc(a);\n    this.message = \"FS error\";\n  }, O.prototype = Error(), O.prototype.constructor = O, [44].forEach(a => {\n    Bb[a] = new O(a);\n    Bb[a].stack = \"<generic error, no stack>\";\n  }));\n}, hc, jc = (a, b, c) => {\n  a = gb(\"/dev/\" + a);\n  var d = Db(!!b, !!c);\n  ic || (ic = 64);\n  var e = ic++ << 8 | 0;\n  ub(e, {open:f => {\n    f.seekable = !1;\n  }, close:() => {\n    c && c.buffer && c.buffer.length && c(10);\n  }, read:(f, g, n, p) => {\n    for (var l = 0, u = 0; u < p; u++) {\n      try {\n        var v = b();\n      } catch (x) {\n        throw new O(29);\n      }\n      if (void 0 === v && 0 === l) {\n        throw new O(6);\n      }\n      if (null === v || void 0 === v) {\n        break;\n      }\n      l++;\n      g[n + u] = v;\n    }\n    l && (f.node.timestamp = Date.now());\n    return l;\n  }, write:(f, g, n, p) => {\n    for (var l = 0; l < p; l++) {\n      try {\n        c(g[n + l]);\n      } catch (u) {\n        throw new O(29);\n      }\n    }\n    p && (f.node.timestamp = Date.now());\n    return l;\n  }});\n  Xb(a, d, e);\n}, ic, kc = {}, Ub, dc, lc = void 0;\nfunction mc() {\n  lc += 4;\n  return L[lc - 4 >> 2];\n}\nfunction nc(a) {\n  if (void 0 === a) {\n    return \"_unknown\";\n  }\n  a = a.replace(/[^a-zA-Z0-9_]/g, \"$\");\n  var b = a.charCodeAt(0);\n  return 48 <= b && 57 >= b ? `_${a}` : a;\n}\nfunction oc(a, b) {\n  a = nc(a);\n  return {[a]:function() {\n    return b.apply(this, arguments);\n  }}[a];\n}\nfunction pc() {\n  this.M = [void 0];\n  this.hb = [];\n}\nvar U = new pc(), qc = void 0;\nfunction V(a) {\n  throw new qc(a);\n}\nvar rc = a => {\n  a || V(\"Cannot use deleted val. handle = \" + a);\n  return U.get(a).value;\n}, sc = a => {\n  switch(a) {\n    case void 0:\n      return 1;\n    case null:\n      return 2;\n    case !0:\n      return 3;\n    case !1:\n      return 4;\n    default:\n      return U.pa({tb:1, value:a});\n  }\n};\nfunction tc(a) {\n  var b = Error, c = oc(a, function(d) {\n    this.name = a;\n    this.message = d;\n    d = Error(d).stack;\n    void 0 !== d && (this.stack = this.toString() + \"\\n\" + d.replace(/^Error(:[^\\n]*)?\\n/, \"\"));\n  });\n  c.prototype = Object.create(b.prototype);\n  c.prototype.constructor = c;\n  c.prototype.toString = function() {\n    return void 0 === this.message ? this.name : `${this.name}: ${this.message}`;\n  };\n  return c;\n}\nvar uc = void 0, vc = void 0;\nfunction W(a) {\n  for (var b = \"\"; E[a];) {\n    b += vc[E[a++]];\n  }\n  return b;\n}\nvar wc = [];\nfunction xc() {\n  for (; wc.length;) {\n    var a = wc.pop();\n    a.g.fa = !1;\n    a[\"delete\"]();\n  }\n}\nvar yc = void 0, zc = {};\nfunction Ac(a, b) {\n  for (void 0 === b && V(\"ptr should not be undefined\"); a.A;) {\n    b = a.na(b), a = a.A;\n  }\n  return b;\n}\nvar Bc = {};\nfunction Cc(a) {\n  a = Dc(a);\n  var b = W(a);\n  Ec(a);\n  return b;\n}\nfunction Fc(a, b) {\n  var c = Bc[a];\n  void 0 === c && V(b + \" has unknown type \" + Cc(a));\n  return c;\n}\nfunction Gc() {\n}\nvar Hc = !1;\nfunction Ic(a) {\n  --a.count.value;\n  0 === a.count.value && (a.G ? a.L.W(a.G) : a.u.i.W(a.o));\n}\nfunction Jc(a, b, c) {\n  if (b === c) {\n    return a;\n  }\n  if (void 0 === c.A) {\n    return null;\n  }\n  a = Jc(a, b, c.A);\n  return null === a ? null : c.Pb(a);\n}\nvar Kc = {};\nfunction Lc(a, b) {\n  b = Ac(a, b);\n  return zc[b];\n}\nvar Mc = void 0;\nfunction Nc(a) {\n  throw new Mc(a);\n}\nfunction Oc(a, b) {\n  b.u && b.o || Nc(\"makeClassHandle requires ptr and ptrType\");\n  !!b.L !== !!b.G && Nc(\"Both smartPtrType and smartPtr must be specified\");\n  b.count = {value:1};\n  return Pc(Object.create(a, {g:{value:b,},}));\n}\nfunction Pc(a) {\n  if (\"undefined\" === typeof FinalizationRegistry) {\n    return Pc = b => b, a;\n  }\n  Hc = new FinalizationRegistry(b => {\n    Ic(b.g);\n  });\n  Pc = b => {\n    var c = b.g;\n    c.G && Hc.register(b, {g:c}, b);\n    return b;\n  };\n  Gc = b => {\n    Hc.unregister(b);\n  };\n  return Pc(a);\n}\nvar Qc = {};\nfunction Rc(a) {\n  for (; a.length;) {\n    var b = a.pop();\n    a.pop()(b);\n  }\n}\nfunction Sc(a) {\n  return this.fromWireType(L[a >> 2]);\n}\nvar Tc = {}, Uc = {};\nfunction Y(a, b, c) {\n  function d(n) {\n    n = c(n);\n    n.length !== a.length && Nc(\"Mismatched type converter count\");\n    for (var p = 0; p < a.length; ++p) {\n      Vc(a[p], n[p]);\n    }\n  }\n  a.forEach(function(n) {\n    Uc[n] = b;\n  });\n  var e = Array(b.length), f = [], g = 0;\n  b.forEach((n, p) => {\n    Bc.hasOwnProperty(n) ? e[p] = Bc[n] : (f.push(n), Tc.hasOwnProperty(n) || (Tc[n] = []), Tc[n].push(() => {\n      e[p] = Bc[n];\n      ++g;\n      g === f.length && d(e);\n    }));\n  });\n  0 === f.length && d(e);\n}\nfunction Wc(a) {\n  switch(a) {\n    case 1:\n      return 0;\n    case 2:\n      return 1;\n    case 4:\n      return 2;\n    case 8:\n      return 3;\n    default:\n      throw new TypeError(`Unknown type size: ${a}`);\n  }\n}\nfunction Xc(a, b, c = {}) {\n  var d = b.name;\n  a || V(`type \"${d}\" must have a positive integer typeid pointer`);\n  if (Bc.hasOwnProperty(a)) {\n    if (c.$b) {\n      return;\n    }\n    V(`Cannot register type '${d}' twice`);\n  }\n  Bc[a] = b;\n  delete Uc[a];\n  Tc.hasOwnProperty(a) && (b = Tc[a], delete Tc[a], b.forEach(e => e()));\n}\nfunction Vc(a, b, c = {}) {\n  if (!(\"argPackAdvance\" in b)) {\n    throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n  }\n  Xc(a, b, c);\n}\nfunction Yc(a) {\n  V(a.g.u.i.name + \" instance already deleted\");\n}\nfunction Zc() {\n}\nfunction $c(a, b, c) {\n  if (void 0 === a[b].B) {\n    var d = a[b];\n    a[b] = function() {\n      a[b].B.hasOwnProperty(arguments.length) || V(`Function '${c}' called with an invalid number of arguments (${arguments.length}) - expects one of (${a[b].B})!`);\n      return a[b].B[arguments.length].apply(this, arguments);\n    };\n    a[b].B = [];\n    a[b].B[d.ea] = d;\n  }\n}\nfunction ad(a, b, c) {\n  m.hasOwnProperty(a) ? ((void 0 === c || void 0 !== m[a].B && void 0 !== m[a].B[c]) && V(`Cannot register public name '${a}' twice`), $c(m, a, a), m.hasOwnProperty(c) && V(`Cannot register multiple overloads of a function with the same number of arguments (${c})!`), m[a].B[c] = b) : (m[a] = b, void 0 !== c && (m[a].Pc = c));\n}\nfunction bd(a, b, c, d, e, f, g, n) {\n  this.name = a;\n  this.constructor = b;\n  this.N = c;\n  this.W = d;\n  this.A = e;\n  this.Ub = f;\n  this.na = g;\n  this.Pb = n;\n  this.qb = [];\n}\nfunction cd(a, b, c) {\n  for (; b !== c;) {\n    b.na || V(`Expected null or instance of ${c.name}, got an instance of ${b.name}`), a = b.na(a), b = b.A;\n  }\n  return a;\n}\nfunction dd(a, b) {\n  if (null === b) {\n    return this.Na && V(`null is not a valid ${this.name}`), 0;\n  }\n  b.g || V(`Cannot pass \"${ed(b)}\" as a ${this.name}`);\n  b.g.o || V(`Cannot pass deleted object as a pointer of type ${this.name}`);\n  return cd(b.g.o, b.g.u.i, this.i);\n}\nfunction fd(a, b) {\n  if (null === b) {\n    this.Na && V(`null is not a valid ${this.name}`);\n    if (this.ua) {\n      var c = this.Pa();\n      null !== a && a.push(this.W, c);\n      return c;\n    }\n    return 0;\n  }\n  b.g || V(`Cannot pass \"${ed(b)}\" as a ${this.name}`);\n  b.g.o || V(`Cannot pass deleted object as a pointer of type ${this.name}`);\n  !this.ta && b.g.u.ta && V(`Cannot convert argument of type ${b.g.L ? b.g.L.name : b.g.u.name} to parameter type ${this.name}`);\n  c = cd(b.g.o, b.g.u.i, this.i);\n  if (this.ua) {\n    switch(void 0 === b.g.G && V(\"Passing raw pointer to smart pointer is illegal\"), this.tc) {\n      case 0:\n        b.g.L === this ? c = b.g.G : V(`Cannot convert argument of type ${b.g.L ? b.g.L.name : b.g.u.name} to parameter type ${this.name}`);\n        break;\n      case 1:\n        c = b.g.G;\n        break;\n      case 2:\n        if (b.g.L === this) {\n          c = b.g.G;\n        } else {\n          var d = b.clone();\n          c = this.oc(c, sc(function() {\n            d[\"delete\"]();\n          }));\n          null !== a && a.push(this.W, c);\n        }\n        break;\n      default:\n        V(\"Unsupporting sharing policy\");\n    }\n  }\n  return c;\n}\nfunction gd(a, b) {\n  if (null === b) {\n    return this.Na && V(`null is not a valid ${this.name}`), 0;\n  }\n  b.g || V(`Cannot pass \"${ed(b)}\" as a ${this.name}`);\n  b.g.o || V(`Cannot pass deleted object as a pointer of type ${this.name}`);\n  b.g.u.ta && V(`Cannot convert argument of type ${b.g.u.name} to parameter type ${this.name}`);\n  return cd(b.g.o, b.g.u.i, this.i);\n}\nfunction hd(a, b, c, d) {\n  this.name = a;\n  this.i = b;\n  this.Na = c;\n  this.ta = d;\n  this.ua = !1;\n  this.W = this.oc = this.Pa = this.rb = this.tc = this.nc = void 0;\n  void 0 !== b.A ? this.toWireType = fd : (this.toWireType = d ? dd : gd, this.K = null);\n}\nfunction jd(a, b, c) {\n  m.hasOwnProperty(a) || Nc(\"Replacing nonexistant public symbol\");\n  void 0 !== m[a].B && void 0 !== c ? m[a].B[c] = b : (m[a] = b, m[a].ea = c);\n}\nvar kd = [], ld = a => {\n  var b = kd[a];\n  b || (a >= kd.length && (kd.length = a + 1), kd[a] = b = Ka.get(a));\n  return b;\n}, md = (a, b) => {\n  var c = [];\n  return function() {\n    c.length = 0;\n    Object.assign(c, arguments);\n    if (a.includes(\"j\")) {\n      var d = m[\"dynCall_\" + a];\n      d = c && c.length ? d.apply(null, [b].concat(c)) : d.call(null, b);\n    } else {\n      d = ld(b).apply(null, c);\n    }\n    return d;\n  };\n};\nfunction Z(a, b) {\n  a = W(a);\n  var c = a.includes(\"j\") ? md(a, b) : ld(b);\n  \"function\" != typeof c && V(`unknown function pointer with signature ${a}: ${b}`);\n  return c;\n}\nvar nd = void 0;\nfunction od(a, b) {\n  function c(f) {\n    e[f] || Bc[f] || (Uc[f] ? Uc[f].forEach(c) : (d.push(f), e[f] = !0));\n  }\n  var d = [], e = {};\n  b.forEach(c);\n  throw new nd(`${a}: ` + d.map(Cc).join([\", \"]));\n}\nfunction pd(a, b, c, d, e) {\n  var f = b.length;\n  2 > f && V(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n  var g = null !== b[1] && null !== c, n = !1;\n  for (c = 1; c < b.length; ++c) {\n    if (null !== b[c] && void 0 === b[c].K) {\n      n = !0;\n      break;\n    }\n  }\n  var p = \"void\" !== b[0].name, l = f - 2, u = Array(l), v = [], x = [];\n  return function() {\n    arguments.length !== l && V(`function ${a} called with ${arguments.length} arguments, expected ${l} args!`);\n    x.length = 0;\n    v.length = g ? 2 : 1;\n    v[0] = e;\n    if (g) {\n      var k = b[1].toWireType(x, this);\n      v[1] = k;\n    }\n    for (var t = 0; t < l; ++t) {\n      u[t] = b[t + 2].toWireType(x, arguments[t]), v.push(u[t]);\n    }\n    t = d.apply(null, v);\n    if (n) {\n      Rc(x);\n    } else {\n      for (var r = g ? 1 : 2; r < b.length; r++) {\n        var B = 1 === r ? k : u[r - 2];\n        null !== b[r].K && b[r].K(B);\n      }\n    }\n    k = p ? b[0].fromWireType(t) : void 0;\n    return k;\n  };\n}\nfunction sd(a, b) {\n  for (var c = [], d = 0; d < a; d++) {\n    c.push(N[b + 4 * d >> 2]);\n  }\n  return c;\n}\nfunction td(a, b, c) {\n  a instanceof Object || V(`${c} with invalid \"this\": ${a}`);\n  a instanceof b.i.constructor || V(`${c} incompatible with \"this\" of type ${a.constructor.name}`);\n  a.g.o || V(`cannot call emscripten binding method ${c} on deleted object`);\n  return cd(a.g.o, a.g.u.i, b.i);\n}\nfunction ud(a) {\n  a >= U.h && 0 === --U.get(a).tb && U.Zb(a);\n}\nfunction vd(a, b, c) {\n  switch(b) {\n    case 0:\n      return function(d) {\n        return this.fromWireType((c ? C : E)[d]);\n      };\n    case 1:\n      return function(d) {\n        return this.fromWireType((c ? Da : Ea)[d >> 1]);\n      };\n    case 2:\n      return function(d) {\n        return this.fromWireType((c ? L : N)[d >> 2]);\n      };\n    default:\n      throw new TypeError(\"Unknown integer type: \" + a);\n  }\n}\nfunction ed(a) {\n  if (null === a) {\n    return \"null\";\n  }\n  var b = typeof a;\n  return \"object\" === b || \"array\" === b || \"function\" === b ? a.toString() : \"\" + a;\n}\nfunction wd(a, b) {\n  switch(b) {\n    case 2:\n      return function(c) {\n        return this.fromWireType(Fa[c >> 2]);\n      };\n    case 3:\n      return function(c) {\n        return this.fromWireType(Ia[c >> 3]);\n      };\n    default:\n      throw new TypeError(\"Unknown float type: \" + a);\n  }\n}\nfunction xd(a, b, c) {\n  switch(b) {\n    case 0:\n      return c ? function(d) {\n        return C[d];\n      } : function(d) {\n        return E[d];\n      };\n    case 1:\n      return c ? function(d) {\n        return Da[d >> 1];\n      } : function(d) {\n        return Ea[d >> 1];\n      };\n    case 2:\n      return c ? function(d) {\n        return L[d >> 2];\n      } : function(d) {\n        return N[d >> 2];\n      };\n    default:\n      throw new TypeError(\"Unknown integer type: \" + a);\n  }\n}\nvar yd = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf-16le\") : void 0, zd = (a, b) => {\n  var c = a >> 1;\n  for (var d = c + b / 2; !(c >= d) && Ea[c];) {\n    ++c;\n  }\n  c <<= 1;\n  if (32 < c - a && yd) {\n    return yd.decode(E.subarray(a, c));\n  }\n  c = \"\";\n  for (d = 0; !(d >= b / 2); ++d) {\n    var e = Da[a + 2 * d >> 1];\n    if (0 == e) {\n      break;\n    }\n    c += String.fromCharCode(e);\n  }\n  return c;\n}, Ad = (a, b, c) => {\n  void 0 === c && (c = 2147483647);\n  if (2 > c) {\n    return 0;\n  }\n  c -= 2;\n  var d = b;\n  c = c < 2 * a.length ? c / 2 : a.length;\n  for (var e = 0; e < c; ++e) {\n    Da[b >> 1] = a.charCodeAt(e), b += 2;\n  }\n  Da[b >> 1] = 0;\n  return b - d;\n}, Bd = a => 2 * a.length, Cd = (a, b) => {\n  for (var c = 0, d = \"\"; !(c >= b / 4);) {\n    var e = L[a + 4 * c >> 2];\n    if (0 == e) {\n      break;\n    }\n    ++c;\n    65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);\n  }\n  return d;\n}, Dd = (a, b, c) => {\n  void 0 === c && (c = 2147483647);\n  if (4 > c) {\n    return 0;\n  }\n  var d = b;\n  c = d + c - 4;\n  for (var e = 0; e < a.length; ++e) {\n    var f = a.charCodeAt(e);\n    if (55296 <= f && 57343 >= f) {\n      var g = a.charCodeAt(++e);\n      f = 65536 + ((f & 1023) << 10) | g & 1023;\n    }\n    L[b >> 2] = f;\n    b += 4;\n    if (b + 4 > c) {\n      break;\n    }\n  }\n  L[b >> 2] = 0;\n  return b - d;\n}, Ed = a => {\n  for (var b = 0, c = 0; c < a.length; ++c) {\n    var d = a.charCodeAt(c);\n    55296 <= d && 57343 >= d && ++c;\n    b += 4;\n  }\n  return b;\n}, Fd = {};\nfunction Gd(a) {\n  var b = Fd[a];\n  return void 0 === b ? W(a) : b;\n}\nvar Hd = [];\nfunction Id(a) {\n  var b = Hd.length;\n  Hd.push(a);\n  return b;\n}\nfunction Jd(a, b) {\n  for (var c = Array(a), d = 0; d < a; ++d) {\n    c[d] = Fc(N[b + 4 * d >> 2], \"parameter \" + d);\n  }\n  return c;\n}\nvar Kd = [], Ld = [], Md = {}, Od = () => {\n  if (!Nd) {\n    var a = {USER:\"web_user\", LOGNAME:\"web_user\", PATH:\"/\", PWD:\"/\", HOME:\"/home/web_user\", LANG:(\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\", _:na || \"./this.program\"}, b;\n    for (b in Md) {\n      void 0 === Md[b] ? delete a[b] : a[b] = Md[b];\n    }\n    var c = [];\n    for (b in a) {\n      c.push(`${b}=${a[b]}`);\n    }\n    Nd = c;\n  }\n  return Nd;\n}, Nd, Pd = a => 0 === a % 4 && (0 !== a % 100 || 0 === a % 400), Qd = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Rd = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Sd = (a, b, c, d) => {\n  function e(k, t, r) {\n    for (k = \"number\" == typeof k ? k.toString() : k || \"\"; k.length < t;) {\n      k = r[0] + k;\n    }\n    return k;\n  }\n  function f(k, t) {\n    return e(k, t, \"0\");\n  }\n  function g(k, t) {\n    function r(D) {\n      return 0 > D ? -1 : 0 < D ? 1 : 0;\n    }\n    var B;\n    0 === (B = r(k.getFullYear() - t.getFullYear())) && 0 === (B = r(k.getMonth() - t.getMonth())) && (B = r(k.getDate() - t.getDate()));\n    return B;\n  }\n  function n(k) {\n    switch(k.getDay()) {\n      case 0:\n        return new Date(k.getFullYear() - 1, 11, 29);\n      case 1:\n        return k;\n      case 2:\n        return new Date(k.getFullYear(), 0, 3);\n      case 3:\n        return new Date(k.getFullYear(), 0, 2);\n      case 4:\n        return new Date(k.getFullYear(), 0, 1);\n      case 5:\n        return new Date(k.getFullYear() - 1, 11, 31);\n      case 6:\n        return new Date(k.getFullYear() - 1, 11, 30);\n    }\n  }\n  function p(k) {\n    var t = k.ca;\n    for (k = new Date((new Date(k.da + 1900, 0, 1)).getTime()); 0 < t;) {\n      var r = k.getMonth(), B = (Pd(k.getFullYear()) ? Qd : Rd)[r];\n      if (t > B - k.getDate()) {\n        t -= B - k.getDate() + 1, k.setDate(1), 11 > r ? k.setMonth(r + 1) : (k.setMonth(0), k.setFullYear(k.getFullYear() + 1));\n      } else {\n        k.setDate(k.getDate() + t);\n        break;\n      }\n    }\n    r = new Date(k.getFullYear() + 1, 0, 4);\n    t = n(new Date(k.getFullYear(), 0, 4));\n    r = n(r);\n    return 0 >= g(t, k) ? 0 >= g(r, k) ? k.getFullYear() + 1 : k.getFullYear() : k.getFullYear() - 1;\n  }\n  var l = L[d + 40 >> 2];\n  d = {wc:L[d >> 2], vc:L[d + 4 >> 2], Fa:L[d + 8 >> 2], Sa:L[d + 12 >> 2], Ga:L[d + 16 >> 2], da:L[d + 20 >> 2], R:L[d + 24 >> 2], ca:L[d + 28 >> 2], Rc:L[d + 32 >> 2], uc:L[d + 36 >> 2], xc:l ? l ? nb(E, l) : \"\" : \"\"};\n  c = c ? nb(E, c) : \"\";\n  l = {\"%c\":\"%a %b %d %H:%M:%S %Y\", \"%D\":\"%m/%d/%y\", \"%F\":\"%Y-%m-%d\", \"%h\":\"%b\", \"%r\":\"%I:%M:%S %p\", \"%R\":\"%H:%M\", \"%T\":\"%H:%M:%S\", \"%x\":\"%m/%d/%y\", \"%X\":\"%H:%M:%S\", \"%Ec\":\"%c\", \"%EC\":\"%C\", \"%Ex\":\"%m/%d/%y\", \"%EX\":\"%H:%M:%S\", \"%Ey\":\"%y\", \"%EY\":\"%Y\", \"%Od\":\"%d\", \"%Oe\":\"%e\", \"%OH\":\"%H\", \"%OI\":\"%I\", \"%Om\":\"%m\", \"%OM\":\"%M\", \"%OS\":\"%S\", \"%Ou\":\"%u\", \"%OU\":\"%U\", \"%OV\":\"%V\", \"%Ow\":\"%w\", \"%OW\":\"%W\", \"%Oy\":\"%y\",};\n  for (var u in l) {\n    c = c.replace(new RegExp(u, \"g\"), l[u]);\n  }\n  var v = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), x = \"January February March April May June July August September October November December\".split(\" \");\n  l = {\"%a\":k => v[k.R].substring(0, 3), \"%A\":k => v[k.R], \"%b\":k => x[k.Ga].substring(0, 3), \"%B\":k => x[k.Ga], \"%C\":k => f((k.da + 1900) / 100 | 0, 2), \"%d\":k => f(k.Sa, 2), \"%e\":k => e(k.Sa, 2, \" \"), \"%g\":k => p(k).toString().substring(2), \"%G\":k => p(k), \"%H\":k => f(k.Fa, 2), \"%I\":k => {\n    k = k.Fa;\n    0 == k ? k = 12 : 12 < k && (k -= 12);\n    return f(k, 2);\n  }, \"%j\":k => {\n    for (var t = 0, r = 0; r <= k.Ga - 1; t += (Pd(k.da + 1900) ? Qd : Rd)[r++]) {\n    }\n    return f(k.Sa + t, 3);\n  }, \"%m\":k => f(k.Ga + 1, 2), \"%M\":k => f(k.vc, 2), \"%n\":() => \"\\n\", \"%p\":k => 0 <= k.Fa && 12 > k.Fa ? \"AM\" : \"PM\", \"%S\":k => f(k.wc, 2), \"%t\":() => \"\\t\", \"%u\":k => k.R || 7, \"%U\":k => f(Math.floor((k.ca + 7 - k.R) / 7), 2), \"%V\":k => {\n    var t = Math.floor((k.ca + 7 - (k.R + 6) % 7) / 7);\n    2 >= (k.R + 371 - k.ca - 2) % 7 && t++;\n    if (t) {\n      53 == t && (r = (k.R + 371 - k.ca) % 7, 4 == r || 3 == r && Pd(k.da) || (t = 1));\n    } else {\n      t = 52;\n      var r = (k.R + 7 - k.ca - 1) % 7;\n      (4 == r || 5 == r && Pd(k.da % 400 - 1)) && t++;\n    }\n    return f(t, 2);\n  }, \"%w\":k => k.R, \"%W\":k => f(Math.floor((k.ca + 7 - (k.R + 6) % 7) / 7), 2), \"%y\":k => (k.da + 1900).toString().substring(2), \"%Y\":k => k.da + 1900, \"%z\":k => {\n    k = k.uc;\n    var t = 0 <= k;\n    k = Math.abs(k) / 60;\n    return (t ? \"+\" : \"-\") + String(\"0000\" + (k / 60 * 100 + k % 60)).slice(-4);\n  }, \"%Z\":k => k.xc, \"%%\":() => \"%\"};\n  c = c.replace(/%%/g, \"\\x00\\x00\");\n  for (u in l) {\n    c.includes(u) && (c = c.replace(new RegExp(u, \"g\"), l[u](d)));\n  }\n  c = c.replace(/\\0\\0/g, \"%\");\n  u = rb(c, !1);\n  if (u.length > b) {\n    return 0;\n  }\n  C.set(u, a);\n  return u.length - 1;\n};\nfunction Pb(a, b, c, d) {\n  a || (a = this);\n  this.parent = a;\n  this.U = a.U;\n  this.wa = null;\n  this.id = Hb++;\n  this.name = b;\n  this.mode = c;\n  this.l = {};\n  this.m = {};\n  this.za = d;\n}\nObject.defineProperties(Pb.prototype, {read:{get:function() {\n  return 365 === (this.mode & 365);\n}, set:function(a) {\n  a ? this.mode |= 365 : this.mode &= -366;\n}}, write:{get:function() {\n  return 146 === (this.mode & 146);\n}, set:function(a) {\n  a ? this.mode |= 146 : this.mode &= -147;\n}}});\ngc();\nIb = Array(4096);\nWb(P, \"/\");\nS(\"/tmp\", 16895, 0);\nS(\"/home\", 16895, 0);\nS(\"/home/web_user\", 16895, 0);\n(() => {\n  S(\"/dev\", 16895, 0);\n  ub(259, {read:() => 0, write:(d, e, f, g) => g,});\n  Xb(\"/dev/null\", 259);\n  tb(1280, wb);\n  tb(1536, xb);\n  Xb(\"/dev/tty\", 1280);\n  Xb(\"/dev/tty1\", 1536);\n  var a = new Uint8Array(1024), b = 0, c = () => {\n    0 === b && (b = kb(a).byteLength);\n    return a[--b];\n  };\n  jc(\"random\", c);\n  jc(\"urandom\", c);\n  S(\"/dev/shm\", 16895, 0);\n  S(\"/dev/shm/tmp\", 16895, 0);\n})();\n(() => {\n  S(\"/proc\", 16895, 0);\n  var a = S(\"/proc/self\", 16895, 0);\n  S(\"/proc/self/fd\", 16895, 0);\n  Wb({U:() => {\n    var b = Ab(a, \"fd\", 16895, 73);\n    b.l = {ka:(c, d) => {\n      var e = Tb(+d);\n      c = {parent:null, U:{mb:\"fake\"}, l:{ma:() => e.path},};\n      return c.parent = c;\n    }};\n    return b;\n  }}, \"/proc/self/fd\");\n})();\nObject.assign(pc.prototype, {get(a) {\n  return this.M[a];\n}, has(a) {\n  return void 0 !== this.M[a];\n}, pa(a) {\n  var b = this.hb.pop() || this.M.length;\n  this.M[b] = a;\n  return b;\n}, Zb(a) {\n  this.M[a] = void 0;\n  this.hb.push(a);\n}});\nqc = m.BindingError = class extends Error {\n  constructor(a) {\n    super(a);\n    this.name = \"BindingError\";\n  }\n};\nU.M.push({value:void 0}, {value:null}, {value:!0}, {value:!1},);\nU.h = U.M.length;\nm.count_emval_handles = function() {\n  for (var a = 0, b = U.h; b < U.M.length; ++b) {\n    void 0 !== U.M[b] && ++a;\n  }\n  return a;\n};\nuc = m.PureVirtualError = tc(\"PureVirtualError\");\nfor (var Td = Array(256), Ud = 0; 256 > Ud; ++Ud) {\n  Td[Ud] = String.fromCharCode(Ud);\n}\nvc = Td;\nm.getInheritedInstanceCount = function() {\n  return Object.keys(zc).length;\n};\nm.getLiveInheritedInstances = function() {\n  var a = [], b;\n  for (b in zc) {\n    zc.hasOwnProperty(b) && a.push(zc[b]);\n  }\n  return a;\n};\nm.flushPendingDeletes = xc;\nm.setDelayFunction = function(a) {\n  yc = a;\n  wc.length && yc && yc(xc);\n};\nMc = m.InternalError = class extends Error {\n  constructor(a) {\n    super(a);\n    this.name = \"InternalError\";\n  }\n};\nZc.prototype.isAliasOf = function(a) {\n  if (!(this instanceof Zc && a instanceof Zc)) {\n    return !1;\n  }\n  var b = this.g.u.i, c = this.g.o, d = a.g.u.i;\n  for (a = a.g.o; b.A;) {\n    c = b.na(c), b = b.A;\n  }\n  for (; d.A;) {\n    a = d.na(a), d = d.A;\n  }\n  return b === d && c === a;\n};\nZc.prototype.clone = function() {\n  this.g.o || Yc(this);\n  if (this.g.ia) {\n    return this.g.count.value += 1, this;\n  }\n  var a = Pc, b = Object, c = b.create, d = Object.getPrototypeOf(this), e = this.g;\n  a = a(c.call(b, d, {g:{value:{count:e.count, fa:e.fa, ia:e.ia, o:e.o, u:e.u, G:e.G, L:e.L,},}}));\n  a.g.count.value += 1;\n  a.g.fa = !1;\n  return a;\n};\nZc.prototype[\"delete\"] = function() {\n  this.g.o || Yc(this);\n  this.g.fa && !this.g.ia && V(\"Object already scheduled for deletion\");\n  Gc(this);\n  Ic(this.g);\n  this.g.ia || (this.g.G = void 0, this.g.o = void 0);\n};\nZc.prototype.isDeleted = function() {\n  return !this.g.o;\n};\nZc.prototype.deleteLater = function() {\n  this.g.o || Yc(this);\n  this.g.fa && !this.g.ia && V(\"Object already scheduled for deletion\");\n  wc.push(this);\n  1 === wc.length && yc && yc(xc);\n  this.g.fa = !0;\n  return this;\n};\nhd.prototype.Vb = function(a) {\n  this.rb && (a = this.rb(a));\n  return a;\n};\nhd.prototype.ab = function(a) {\n  this.W && this.W(a);\n};\nhd.prototype.argPackAdvance = 8;\nhd.prototype.readValueFromPointer = Sc;\nhd.prototype.deleteObject = function(a) {\n  if (null !== a) {\n    a[\"delete\"]();\n  }\n};\nhd.prototype.fromWireType = function(a) {\n  function b() {\n    return this.ua ? Oc(this.i.N, {u:this.nc, o:c, L:this, G:a,}) : Oc(this.i.N, {u:this, o:a,});\n  }\n  var c = this.Vb(a);\n  if (!c) {\n    return this.ab(a), null;\n  }\n  var d = Lc(this.i, c);\n  if (void 0 !== d) {\n    if (0 === d.g.count.value) {\n      return d.g.o = c, d.g.G = a, d.clone();\n    }\n    d = d.clone();\n    this.ab(a);\n    return d;\n  }\n  d = this.i.Ub(c);\n  d = Kc[d];\n  if (!d) {\n    return b.call(this);\n  }\n  d = this.ta ? d.Kb : d.pointerType;\n  var e = Jc(c, this.i, d.i);\n  return null === e ? b.call(this) : this.ua ? Oc(d.i.N, {u:d, o:e, L:this, G:a,}) : Oc(d.i.N, {u:d, o:e,});\n};\nnd = m.UnboundTypeError = tc(\"UnboundTypeError\");\nvar Xd = {__syscall_fcntl64:function(a, b, c) {\n  lc = c;\n  try {\n    var d = Tb(a);\n    switch(b) {\n      case 0:\n        var e = mc();\n        return 0 > e ? -28 : Vb(d, e).X;\n      case 1:\n      case 2:\n        return 0;\n      case 3:\n        return d.flags;\n      case 4:\n        return e = mc(), d.flags |= e, 0;\n      case 5:\n        return e = mc(), Da[e + 0 >> 1] = 2, 0;\n      case 6:\n      case 7:\n        return 0;\n      case 16:\n      case 8:\n        return -28;\n      case 9:\n        return L[Vd() >> 2] = 28, -1;\n      default:\n        return -28;\n    }\n  } catch (f) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== f.name) {\n      throw f;\n    }\n    return -f.aa;\n  }\n}, __syscall_ioctl:function(a, b, c) {\n  lc = c;\n  try {\n    var d = Tb(a);\n    switch(b) {\n      case 21509:\n        return d.s ? 0 : -59;\n      case 21505:\n        if (!d.s) {\n          return -59;\n        }\n        if (d.s.V.bc) {\n          b = [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];\n          var e = mc();\n          L[e >> 2] = 25856;\n          L[e + 4 >> 2] = 5;\n          L[e + 8 >> 2] = 191;\n          L[e + 12 >> 2] = 35387;\n          for (var f = 0; 32 > f; f++) {\n            C[e + f + 17 >> 0] = b[f] || 0;\n          }\n        }\n        return 0;\n      case 21510:\n      case 21511:\n      case 21512:\n        return d.s ? 0 : -59;\n      case 21506:\n      case 21507:\n      case 21508:\n        if (!d.s) {\n          return -59;\n        }\n        if (d.s.V.cc) {\n          for (e = mc(), b = [], f = 0; 32 > f; f++) {\n            b.push(C[e + f + 17 >> 0]);\n          }\n        }\n        return 0;\n      case 21519:\n        if (!d.s) {\n          return -59;\n        }\n        e = mc();\n        return L[e >> 2] = 0;\n      case 21520:\n        return d.s ? -28 : -59;\n      case 21531:\n        e = mc();\n        if (!d.m.ac) {\n          throw new O(59);\n        }\n        return d.m.ac(d, b, e);\n      case 21523:\n        if (!d.s) {\n          return -59;\n        }\n        d.s.V.dc && (f = [24, 80], e = mc(), Da[e >> 1] = f[0], Da[e + 2 >> 1] = f[1]);\n        return 0;\n      case 21524:\n        return d.s ? 0 : -59;\n      case 21515:\n        return d.s ? 0 : -59;\n      default:\n        return -28;\n    }\n  } catch (g) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== g.name) {\n      throw g;\n    }\n    return -g.aa;\n  }\n}, __syscall_openat:function(a, b, c, d) {\n  lc = d;\n  try {\n    b = b ? nb(E, b) : \"\";\n    var e = b;\n    if (\"/\" === e.charAt(0)) {\n      b = e;\n    } else {\n      var f = -100 === a ? \"/\" : Tb(a).path;\n      if (0 == e.length) {\n        throw new O(44);\n      }\n      b = gb(f + \"/\" + e);\n    }\n    var g = d ? mc() : 0;\n    return ec(b, c, g).X;\n  } catch (n) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== n.name) {\n      throw n;\n    }\n    return -n.aa;\n  }\n}, _embind_create_inheriting_constructor:function(a, b, c) {\n  a = W(a);\n  b = Fc(b, \"wrapper\");\n  c = rc(c);\n  var d = [].slice, e = b.i, f = e.N, g = e.A.N, n = e.A.constructor;\n  a = oc(a, function() {\n    e.A.qb.forEach(function(l) {\n      if (this[l] === g[l]) {\n        throw new uc(`Pure virtual function ${l} must be implemented in JavaScript`);\n      }\n    }.bind(this));\n    Object.defineProperty(this, \"__parent\", {value:f});\n    this.__construct.apply(this, d.call(arguments));\n  });\n  f.__construct = function() {\n    this === f && V(\"Pass correct 'this' to __construct\");\n    var l = n.implement.apply(void 0, [this].concat(d.call(arguments)));\n    Gc(l);\n    var u = l.g;\n    l.notifyOnDestruction();\n    u.ia = !0;\n    Object.defineProperties(this, {g:{value:u}});\n    Pc(this);\n    l = u.o;\n    l = Ac(e, l);\n    zc.hasOwnProperty(l) ? V(`Tried to register registered instance: ${l}`) : zc[l] = this;\n  };\n  f.__destruct = function() {\n    this === f && V(\"Pass correct 'this' to __destruct\");\n    Gc(this);\n    var l = this.g.o;\n    l = Ac(e, l);\n    zc.hasOwnProperty(l) ? delete zc[l] : V(`Tried to unregister unregistered instance: ${l}`);\n  };\n  a.prototype = Object.create(f);\n  for (var p in c) {\n    a.prototype[p] = c[p];\n  }\n  return sc(a);\n}, _embind_finalize_value_object:function(a) {\n  var b = Qc[a];\n  delete Qc[a];\n  var c = b.Pa, d = b.W, e = b.eb, f = e.map(g => g.Yb).concat(e.map(g => g.rc));\n  Y([a], f, g => {\n    var n = {};\n    e.forEach((p, l) => {\n      var u = g[l], v = p.Wb, x = p.Xb, k = g[l + e.length], t = p.qc, r = p.sc;\n      n[p.Sb] = {read:B => u.fromWireType(v(x, B)), write:(B, D) => {\n        var w = [];\n        t(r, B, k.toWireType(w, D));\n        Rc(w);\n      }};\n    });\n    return [{name:b.name, fromWireType:function(p) {\n      var l = {}, u;\n      for (u in n) {\n        l[u] = n[u].read(p);\n      }\n      d(p);\n      return l;\n    }, toWireType:function(p, l) {\n      for (var u in n) {\n        if (!(u in l)) {\n          throw new TypeError(`Missing field: \"${u}\"`);\n        }\n      }\n      var v = c();\n      for (u in n) {\n        n[u].write(v, l[u]);\n      }\n      null !== p && p.push(d, v);\n      return v;\n    }, argPackAdvance:8, readValueFromPointer:Sc, K:d,}];\n  });\n}, _embind_register_bigint:function() {\n}, _embind_register_bool:function(a, b, c, d, e) {\n  var f = Wc(c);\n  b = W(b);\n  Vc(a, {name:b, fromWireType:function(g) {\n    return !!g;\n  }, toWireType:function(g, n) {\n    return n ? d : e;\n  }, argPackAdvance:8, readValueFromPointer:function(g) {\n    if (1 === c) {\n      var n = C;\n    } else if (2 === c) {\n      n = Da;\n    } else if (4 === c) {\n      n = L;\n    } else {\n      throw new TypeError(\"Unknown boolean type size: \" + b);\n    }\n    return this.fromWireType(n[g >> f]);\n  }, K:null,});\n}, _embind_register_class:function(a, b, c, d, e, f, g, n, p, l, u, v, x) {\n  u = W(u);\n  f = Z(e, f);\n  n && (n = Z(g, n));\n  l && (l = Z(p, l));\n  x = Z(v, x);\n  var k = nc(u);\n  ad(k, function() {\n    od(`Cannot construct ${u} due to unbound types`, [d]);\n  });\n  Y([a, b, c], d ? [d] : [], function(t) {\n    t = t[0];\n    if (d) {\n      var r = t.i;\n      var B = r.N;\n    } else {\n      B = Zc.prototype;\n    }\n    t = oc(k, function() {\n      if (Object.getPrototypeOf(this) !== D) {\n        throw new qc(\"Use 'new' to construct \" + u);\n      }\n      if (void 0 === w.$) {\n        throw new qc(u + \" has no accessible constructor\");\n      }\n      var T = w.$[arguments.length];\n      if (void 0 === T) {\n        throw new qc(`Tried to invoke ctor of ${u} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(w.$).toString()}) parameters instead!`);\n      }\n      return T.apply(this, arguments);\n    });\n    var D = Object.create(B, {constructor:{value:t},});\n    t.prototype = D;\n    var w = new bd(u, t, D, x, r, f, n, l);\n    w.A && (void 0 === w.A.oa && (w.A.oa = []), w.A.oa.push(w));\n    r = new hd(u, w, !0, !1);\n    B = new hd(u + \"*\", w, !1, !1);\n    var M = new hd(u + \" const*\", w, !1, !0);\n    Kc[a] = {pointerType:B, Kb:M};\n    jd(k, t);\n    return [r, B, M];\n  });\n}, _embind_register_class_class_function:function(a, b, c, d, e, f, g) {\n  var n = sd(c, d);\n  b = W(b);\n  f = Z(e, f);\n  Y([], [a], function(p) {\n    function l() {\n      od(`Cannot call ${u} due to unbound types`, n);\n    }\n    p = p[0];\n    var u = `${p.name}.${b}`;\n    b.startsWith(\"@@\") && (b = Symbol[b.substring(2)]);\n    var v = p.i.constructor;\n    void 0 === v[b] ? (l.ea = c - 1, v[b] = l) : ($c(v, b, u), v[b].B[c - 1] = l);\n    Y([], n, function(x) {\n      x = pd(u, [x[0], null].concat(x.slice(1)), null, f, g);\n      void 0 === v[b].B ? (x.ea = c - 1, v[b] = x) : v[b].B[c - 1] = x;\n      if (p.i.oa) {\n        for (const k of p.i.oa) {\n          k.constructor.hasOwnProperty(b) || (k.constructor[b] = x);\n        }\n      }\n      return [];\n    });\n    return [];\n  });\n}, _embind_register_class_class_property:function(a, b, c, d, e, f, g, n) {\n  b = W(b);\n  f = Z(e, f);\n  Y([], [a], function(p) {\n    p = p[0];\n    var l = `${p.name}.${b}`, u = {get() {\n      od(`Cannot access ${l} due to unbound types`, [c]);\n    }, enumerable:!0, configurable:!0};\n    u.set = n ? () => {\n      od(`Cannot access ${l} due to unbound types`, [c]);\n    } : () => {\n      V(`${l} is a read-only property`);\n    };\n    Object.defineProperty(p.i.constructor, b, u);\n    Y([], [c], function(v) {\n      v = v[0];\n      var x = {get() {\n        return v.fromWireType(f(d));\n      }, enumerable:!0};\n      n && (n = Z(g, n), x.set = k => {\n        var t = [];\n        n(d, v.toWireType(t, k));\n        Rc(t);\n      });\n      Object.defineProperty(p.i.constructor, b, x);\n      return [];\n    });\n    return [];\n  });\n}, _embind_register_class_constructor:function(a, b, c, d, e, f) {\n  var g = sd(b, c);\n  e = Z(d, e);\n  Y([], [a], function(n) {\n    n = n[0];\n    var p = `constructor ${n.name}`;\n    void 0 === n.i.$ && (n.i.$ = []);\n    if (void 0 !== n.i.$[b - 1]) {\n      throw new qc(`Cannot register multiple constructors with identical number of parameters (${b - 1}) for class '${n.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\n    }\n    n.i.$[b - 1] = () => {\n      od(`Cannot construct ${n.name} due to unbound types`, g);\n    };\n    Y([], g, function(l) {\n      l.splice(1, 0, null);\n      n.i.$[b - 1] = pd(p, l, null, e, f);\n      return [];\n    });\n    return [];\n  });\n}, _embind_register_class_function:function(a, b, c, d, e, f, g, n) {\n  var p = sd(c, d);\n  b = W(b);\n  f = Z(e, f);\n  Y([], [a], function(l) {\n    function u() {\n      od(`Cannot call ${v} due to unbound types`, p);\n    }\n    l = l[0];\n    var v = `${l.name}.${b}`;\n    b.startsWith(\"@@\") && (b = Symbol[b.substring(2)]);\n    n && l.i.qb.push(b);\n    var x = l.i.N, k = x[b];\n    void 0 === k || void 0 === k.B && k.className !== l.name && k.ea === c - 2 ? (u.ea = c - 2, u.className = l.name, x[b] = u) : ($c(x, b, v), x[b].B[c - 2] = u);\n    Y([], p, function(t) {\n      t = pd(v, t, l, f, g);\n      void 0 === x[b].B ? (t.ea = c - 2, x[b] = t) : x[b].B[c - 2] = t;\n      return [];\n    });\n    return [];\n  });\n}, _embind_register_class_property:function(a, b, c, d, e, f, g, n, p, l) {\n  b = W(b);\n  e = Z(d, e);\n  Y([], [a], function(u) {\n    u = u[0];\n    var v = `${u.name}.${b}`, x = {get() {\n      od(`Cannot access ${v} due to unbound types`, [c, g]);\n    }, enumerable:!0, configurable:!0};\n    x.set = p ? () => {\n      od(`Cannot access ${v} due to unbound types`, [c, g]);\n    } : () => {\n      V(v + \" is a read-only property\");\n    };\n    Object.defineProperty(u.i.N, b, x);\n    Y([], p ? [c, g] : [c], function(k) {\n      var t = k[0], r = {get() {\n        var D = td(this, u, v + \" getter\");\n        return t.fromWireType(e(f, D));\n      }, enumerable:!0};\n      if (p) {\n        p = Z(n, p);\n        var B = k[1];\n        r.set = function(D) {\n          var w = td(this, u, v + \" setter\"), M = [];\n          p(l, w, B.toWireType(M, D));\n          Rc(M);\n        };\n      }\n      Object.defineProperty(u.i.N, b, r);\n      return [];\n    });\n    return [];\n  });\n}, _embind_register_emval:function(a, b) {\n  b = W(b);\n  Vc(a, {name:b, fromWireType:function(c) {\n    var d = rc(c);\n    ud(c);\n    return d;\n  }, toWireType:function(c, d) {\n    return sc(d);\n  }, argPackAdvance:8, readValueFromPointer:Sc, K:null,});\n}, _embind_register_enum:function(a, b, c, d) {\n  function e() {\n  }\n  c = Wc(c);\n  b = W(b);\n  e.values = {};\n  Vc(a, {name:b, constructor:e, fromWireType:function(f) {\n    return this.constructor.values[f];\n  }, toWireType:function(f, g) {\n    return g.value;\n  }, argPackAdvance:8, readValueFromPointer:vd(b, c, d), K:null,});\n  ad(b, e);\n}, _embind_register_enum_value:function(a, b, c) {\n  var d = Fc(a, \"enum\");\n  b = W(b);\n  a = d.constructor;\n  d = Object.create(d.constructor.prototype, {value:{value:c}, constructor:{value:oc(`${d.name}_${b}`, function() {\n  })},});\n  a.values[c] = d;\n  a[b] = d;\n}, _embind_register_float:function(a, b, c) {\n  c = Wc(c);\n  b = W(b);\n  Vc(a, {name:b, fromWireType:function(d) {\n    return d;\n  }, toWireType:function(d, e) {\n    return e;\n  }, argPackAdvance:8, readValueFromPointer:wd(b, c), K:null,});\n}, _embind_register_function:function(a, b, c, d, e, f) {\n  var g = sd(b, c);\n  a = W(a);\n  e = Z(d, e);\n  ad(a, function() {\n    od(`Cannot call ${a} due to unbound types`, g);\n  }, b - 1);\n  Y([], g, function(n) {\n    jd(a, pd(a, [n[0], null].concat(n.slice(1)), null, e, f), b - 1);\n    return [];\n  });\n}, _embind_register_integer:function(a, b, c, d, e) {\n  b = W(b);\n  -1 === e && (e = 4294967295);\n  e = Wc(c);\n  var f = n => n;\n  if (0 === d) {\n    var g = 32 - 8 * c;\n    f = n => n << g >>> g;\n  }\n  c = b.includes(\"unsigned\") ? function(n, p) {\n    return p >>> 0;\n  } : function(n, p) {\n    return p;\n  };\n  Vc(a, {name:b, fromWireType:f, toWireType:c, argPackAdvance:8, readValueFromPointer:xd(b, e, 0 !== d), K:null,});\n}, _embind_register_memory_view:function(a, b, c) {\n  function d(f) {\n    f >>= 2;\n    var g = N;\n    return new e(g.buffer, g[f + 1], g[f]);\n  }\n  var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array,][b];\n  c = W(c);\n  Vc(a, {name:c, fromWireType:d, argPackAdvance:8, readValueFromPointer:d,}, {$b:!0,});\n}, _embind_register_std_string:function(a, b) {\n  b = W(b);\n  var c = \"std::string\" === b;\n  Vc(a, {name:b, fromWireType:function(d) {\n    var e = N[d >> 2], f = d + 4;\n    if (c) {\n      for (var g = f, n = 0; n <= e; ++n) {\n        var p = f + n;\n        if (n == e || 0 == E[p]) {\n          g = g ? nb(E, g, p - g) : \"\";\n          if (void 0 === l) {\n            var l = g;\n          } else {\n            l += String.fromCharCode(0), l += g;\n          }\n          g = p + 1;\n        }\n      }\n    } else {\n      l = Array(e);\n      for (n = 0; n < e; ++n) {\n        l[n] = String.fromCharCode(E[f + n]);\n      }\n      l = l.join(\"\");\n    }\n    Ec(d);\n    return l;\n  }, toWireType:function(d, e) {\n    e instanceof ArrayBuffer && (e = new Uint8Array(e));\n    var f = \"string\" == typeof e;\n    f || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || V(\"Cannot pass non-string to std::string\");\n    var g = c && f ? pb(e) : e.length;\n    var n = Wd(4 + g + 1), p = n + 4;\n    N[n >> 2] = g;\n    if (c && f) {\n      qb(e, E, p, g + 1);\n    } else {\n      if (f) {\n        for (f = 0; f < g; ++f) {\n          var l = e.charCodeAt(f);\n          255 < l && (Ec(p), V(\"String has UTF-16 code units that do not fit in 8 bits\"));\n          E[p + f] = l;\n        }\n      } else {\n        for (f = 0; f < g; ++f) {\n          E[p + f] = e[f];\n        }\n      }\n    }\n    null !== d && d.push(Ec, n);\n    return n;\n  }, argPackAdvance:8, readValueFromPointer:Sc, K:function(d) {\n    Ec(d);\n  },});\n}, _embind_register_std_wstring:function(a, b, c) {\n  c = W(c);\n  if (2 === b) {\n    var d = zd;\n    var e = Ad;\n    var f = Bd;\n    var g = () => Ea;\n    var n = 1;\n  } else {\n    4 === b && (d = Cd, e = Dd, f = Ed, g = () => N, n = 2);\n  }\n  Vc(a, {name:c, fromWireType:function(p) {\n    for (var l = N[p >> 2], u = g(), v, x = p + 4, k = 0; k <= l; ++k) {\n      var t = p + 4 + k * b;\n      if (k == l || 0 == u[t >> n]) {\n        x = d(x, t - x), void 0 === v ? v = x : (v += String.fromCharCode(0), v += x), x = t + b;\n      }\n    }\n    Ec(p);\n    return v;\n  }, toWireType:function(p, l) {\n    \"string\" != typeof l && V(`Cannot pass non-string to C++ string type ${c}`);\n    var u = f(l), v = Wd(4 + u + b);\n    N[v >> 2] = u >> n;\n    e(l, v + 4, u + b);\n    null !== p && p.push(Ec, v);\n    return v;\n  }, argPackAdvance:8, readValueFromPointer:Sc, K:function(p) {\n    Ec(p);\n  },});\n}, _embind_register_value_object:function(a, b, c, d, e, f) {\n  Qc[a] = {name:W(b), Pa:Z(c, d), W:Z(e, f), eb:[],};\n}, _embind_register_value_object_field:function(a, b, c, d, e, f, g, n, p, l) {\n  Qc[a].eb.push({Sb:W(b), Yb:c, Wb:Z(d, e), Xb:f, rc:g, qc:Z(n, p), sc:l,});\n}, _embind_register_void:function(a, b) {\n  b = W(b);\n  Vc(a, {fc:!0, name:b, argPackAdvance:0, fromWireType:function() {\n  }, toWireType:function() {\n  },});\n}, _emscripten_get_now_is_monotonic:() => !0, _emval_as:function(a, b, c) {\n  a = rc(a);\n  b = Fc(b, \"emval::as\");\n  var d = [], e = sc(d);\n  N[c >> 2] = e;\n  return b.toWireType(d, a);\n}, _emval_call_method:function(a, b, c, d, e) {\n  a = Hd[a];\n  b = rc(b);\n  c = Gd(c);\n  var f = [];\n  N[d >> 2] = sc(f);\n  return a(b, c, f, e);\n}, _emval_call_void_method:function(a, b, c, d) {\n  a = Hd[a];\n  b = rc(b);\n  c = Gd(c);\n  a(b, c, null, d);\n}, _emval_decref:ud, _emval_get_method_caller:function(a, b) {\n  var c = Jd(a, b), d = c[0];\n  b = d.name + \"_$\" + c.slice(1).map(function(g) {\n    return g.name;\n  }).join(\"_\") + \"$\";\n  var e = Kd[b];\n  if (void 0 !== e) {\n    return e;\n  }\n  var f = Array(a - 1);\n  e = Id((g, n, p, l) => {\n    for (var u = 0, v = 0; v < a - 1; ++v) {\n      f[v] = c[v + 1].readValueFromPointer(l + u), u += c[v + 1].argPackAdvance;\n    }\n    g = g[n].apply(g, f);\n    for (v = 0; v < a - 1; ++v) {\n      c[v + 1].Nb && c[v + 1].Nb(f[v]);\n    }\n    if (!d.fc) {\n      return d.toWireType(p, g);\n    }\n  });\n  return Kd[b] = e;\n}, _emval_get_module_property:function(a) {\n  a = Gd(a);\n  return sc(m[a]);\n}, _emval_get_property:function(a, b) {\n  a = rc(a);\n  b = rc(b);\n  return sc(a[b]);\n}, _emval_incref:function(a) {\n  4 < a && (U.get(a).tb += 1);\n}, _emval_new_array:function() {\n  return sc([]);\n}, _emval_new_cstring:function(a) {\n  return sc(Gd(a));\n}, _emval_new_object:function() {\n  return sc({});\n}, _emval_run_destructors:function(a) {\n  var b = rc(a);\n  Rc(b);\n  ud(a);\n}, _emval_set_property:function(a, b, c) {\n  a = rc(a);\n  b = rc(b);\n  c = rc(c);\n  a[b] = c;\n}, _emval_take_value:function(a, b) {\n  a = Fc(a, \"_emval_take_value\");\n  a = a.readValueFromPointer(b);\n  return sc(a);\n}, abort:() => {\n  Aa(\"\");\n}, emscripten_asm_const_int:(a, b, c) => {\n  Ld.length = 0;\n  var d;\n  for (c >>= 2; d = E[b++];) {\n    c += 105 != d & c, Ld.push(105 == d ? L[c] : Ia[c++ >> 1]), ++c;\n  }\n  return db[a].apply(null, Ld);\n}, emscripten_date_now:function() {\n  return Date.now();\n}, emscripten_get_now:() => performance.now(), emscripten_memcpy_big:(a, b, c) => E.copyWithin(a, b, b + c), emscripten_resize_heap:a => {\n  var b = E.length;\n  a >>>= 0;\n  if (2147483648 < a) {\n    return !1;\n  }\n  for (var c = 1; 4 >= c; c *= 2) {\n    var d = b * (1 + 0.2 / c);\n    d = Math.min(d, a + 100663296);\n    var e = Math;\n    d = Math.max(a, d);\n    a: {\n      e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536) - Ba.buffer.byteLength + 65535 >>> 16;\n      try {\n        Ba.grow(e);\n        Ja();\n        var f = 1;\n        break a;\n      } catch (g) {\n      }\n      f = void 0;\n    }\n    if (f) {\n      return !0;\n    }\n  }\n  return !1;\n}, environ_get:(a, b) => {\n  var c = 0;\n  Od().forEach(function(d, e) {\n    var f = b + c;\n    e = N[a + 4 * e >> 2] = f;\n    for (f = 0; f < d.length; ++f) {\n      C[e++ >> 0] = d.charCodeAt(f);\n    }\n    C[e >> 0] = 0;\n    c += d.length + 1;\n  });\n  return 0;\n}, environ_sizes_get:(a, b) => {\n  var c = Od();\n  N[a >> 2] = c.length;\n  var d = 0;\n  c.forEach(function(e) {\n    d += e.length + 1;\n  });\n  N[b >> 2] = d;\n  return 0;\n}, fd_close:function(a) {\n  try {\n    var b = Tb(a);\n    if (null === b.X) {\n      throw new O(8);\n    }\n    b.Ma && (b.Ma = null);\n    try {\n      b.m.close && b.m.close(b);\n    } catch (c) {\n      throw c;\n    } finally {\n      Gb[b.X] = null;\n    }\n    b.X = null;\n    return 0;\n  } catch (c) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== c.name) {\n      throw c;\n    }\n    return c.aa;\n  }\n}, fd_read:function(a, b, c, d) {\n  try {\n    a: {\n      var e = Tb(a);\n      a = b;\n      for (var f, g = b = 0; g < c; g++) {\n        var n = N[a >> 2], p = N[a + 4 >> 2];\n        a += 8;\n        var l = e, u = n, v = p, x = f, k = C;\n        if (0 > v || 0 > x) {\n          throw new O(28);\n        }\n        if (null === l.X) {\n          throw new O(8);\n        }\n        if (1 === (l.flags & 2097155)) {\n          throw new O(8);\n        }\n        if (16384 === (l.node.mode & 61440)) {\n          throw new O(31);\n        }\n        if (!l.m.read) {\n          throw new O(28);\n        }\n        var t = \"undefined\" != typeof x;\n        if (!t) {\n          x = l.position;\n        } else if (!l.seekable) {\n          throw new O(70);\n        }\n        var r = l.m.read(l, k, u, v, x);\n        t || (l.position += r);\n        var B = r;\n        if (0 > B) {\n          var D = -1;\n          break a;\n        }\n        b += B;\n        if (B < p) {\n          break;\n        }\n        \"undefined\" !== typeof f && (f += B);\n      }\n      D = b;\n    }\n    N[d >> 2] = D;\n    return 0;\n  } catch (w) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== w.name) {\n      throw w;\n    }\n    return w.aa;\n  }\n}, fd_seek:function(a, b, c, d, e) {\n  b = c + 2097152 >>> 0 < 4194305 - !!b ? (b >>> 0) + 4294967296 * c : NaN;\n  try {\n    if (isNaN(b)) {\n      return 61;\n    }\n    var f = Tb(a);\n    fc(f, b, d);\n    $a = [f.position >>> 0, (Za = f.position, 1.0 <= +Math.abs(Za) ? 0.0 < Za ? +Math.floor(Za / 4294967296.0) >>> 0 : ~~+Math.ceil((Za - +(~~Za >>> 0)) / 4294967296.0) >>> 0 : 0)];\n    L[e >> 2] = $a[0];\n    L[e + 4 >> 2] = $a[1];\n    f.Ma && 0 === b && 0 === d && (f.Ma = null);\n    return 0;\n  } catch (g) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== g.name) {\n      throw g;\n    }\n    return g.aa;\n  }\n}, fd_write:function(a, b, c, d) {\n  try {\n    a: {\n      var e = Tb(a);\n      a = b;\n      for (var f, g = b = 0; g < c; g++) {\n        var n = N[a >> 2], p = N[a + 4 >> 2];\n        a += 8;\n        var l = e, u = n, v = p, x = f, k = C;\n        if (0 > v || 0 > x) {\n          throw new O(28);\n        }\n        if (null === l.X) {\n          throw new O(8);\n        }\n        if (0 === (l.flags & 2097155)) {\n          throw new O(8);\n        }\n        if (16384 === (l.node.mode & 61440)) {\n          throw new O(31);\n        }\n        if (!l.m.write) {\n          throw new O(28);\n        }\n        l.seekable && l.flags & 1024 && fc(l, 0, 2);\n        var t = \"undefined\" != typeof x;\n        if (!t) {\n          x = l.position;\n        } else if (!l.seekable) {\n          throw new O(70);\n        }\n        var r = l.m.write(l, k, u, v, x, void 0);\n        t || (l.position += r);\n        var B = r;\n        if (0 > B) {\n          var D = -1;\n          break a;\n        }\n        b += B;\n        \"undefined\" !== typeof f && (f += B);\n      }\n      D = b;\n    }\n    N[d >> 2] = D;\n    return 0;\n  } catch (w) {\n    if (\"undefined\" == typeof kc || \"ErrnoError\" !== w.name) {\n      throw w;\n    }\n    return w.aa;\n  }\n}, strftime_l:(a, b, c, d) => Sd(a, b, c, d)};\n(function() {\n  function a(c) {\n    z = c = c.exports;\n    Ba = z.memory;\n    Ja();\n    Ka = z.__indirect_function_table;\n    Ma.unshift(z.__wasm_call_ctors);\n    Pa--;\n    m.monitorRunDependencies && m.monitorRunDependencies(Pa);\n    if (0 == Pa && (null !== Qa && (clearInterval(Qa), Qa = null), Ra)) {\n      var d = Ra;\n      Ra = null;\n      d();\n    }\n    return c;\n  }\n  var b = {env:Xd, wasi_snapshot_preview1:Xd,};\n  Pa++;\n  m.monitorRunDependencies && m.monitorRunDependencies(Pa);\n  if (m.instantiateWasm) {\n    try {\n      return m.instantiateWasm(b, a);\n    } catch (c) {\n      xa(\"Module.instantiateWasm callback failed with error: \" + c), ba(c);\n    }\n  }\n  Ya(b, function(c) {\n    a(c.instance);\n  }).catch(ba);\n  return {};\n})();\nvar Ec = a => (Ec = z.free)(a), Wd = a => (Wd = z.malloc)(a), ab = m._ma_device__on_notification_unlocked = a => (ab = m._ma_device__on_notification_unlocked = z.ma_device__on_notification_unlocked)(a);\nm._ma_malloc_emscripten = (a, b) => (m._ma_malloc_emscripten = z.ma_malloc_emscripten)(a, b);\nm._ma_free_emscripten = (a, b) => (m._ma_free_emscripten = z.ma_free_emscripten)(a, b);\nvar bb = m._ma_device_process_pcm_frames_capture__webaudio = (a, b, c) => (bb = m._ma_device_process_pcm_frames_capture__webaudio = z.ma_device_process_pcm_frames_capture__webaudio)(a, b, c), cb = m._ma_device_process_pcm_frames_playback__webaudio = (a, b, c) => (cb = m._ma_device_process_pcm_frames_playback__webaudio = z.ma_device_process_pcm_frames_playback__webaudio)(a, b, c), Vd = () => (Vd = z.__errno_location)(), Dc = a => (Dc = z.__getTypeName)(a);\nm.__embind_initialize_bindings = () => (m.__embind_initialize_bindings = z._embind_initialize_bindings)();\nm.dynCall_iiji = (a, b, c, d, e) => (m.dynCall_iiji = z.dynCall_iiji)(a, b, c, d, e);\nm.dynCall_jiji = (a, b, c, d, e) => (m.dynCall_jiji = z.dynCall_jiji)(a, b, c, d, e);\nm.dynCall_iiiji = (a, b, c, d, e, f) => (m.dynCall_iiiji = z.dynCall_iiiji)(a, b, c, d, e, f);\nm.dynCall_iij = (a, b, c, d) => (m.dynCall_iij = z.dynCall_iij)(a, b, c, d);\nm.dynCall_jii = (a, b, c) => (m.dynCall_jii = z.dynCall_jii)(a, b, c);\nm.dynCall_viijii = (a, b, c, d, e, f, g) => (m.dynCall_viijii = z.dynCall_viijii)(a, b, c, d, e, f, g);\nm.dynCall_iiiiij = (a, b, c, d, e, f, g) => (m.dynCall_iiiiij = z.dynCall_iiiiij)(a, b, c, d, e, f, g);\nm.dynCall_iiiiijj = (a, b, c, d, e, f, g, n, p) => (m.dynCall_iiiiijj = z.dynCall_iiiiijj)(a, b, c, d, e, f, g, n, p);\nm.dynCall_iiiiiijj = (a, b, c, d, e, f, g, n, p, l) => (m.dynCall_iiiiiijj = z.dynCall_iiiiiijj)(a, b, c, d, e, f, g, n, p, l);\nvar Yd;\nRa = function Zd() {\n  Yd || $d();\n  Yd || (Ra = Zd);\n};\nfunction $d() {\n  function a() {\n    if (!Yd && (Yd = !0, m.calledRun = !0, !Ca)) {\n      m.noFSInit || hc || (hc = !0, gc(), m.stdin = m.stdin, m.stdout = m.stdout, m.stderr = m.stderr, m.stdin ? jc(\"stdin\", m.stdin) : cc(\"/dev/tty\", \"/dev/stdin\"), m.stdout ? jc(\"stdout\", null, m.stdout) : cc(\"/dev/tty\", \"/dev/stdout\"), m.stderr ? jc(\"stderr\", null, m.stderr) : cc(\"/dev/tty1\", \"/dev/stderr\"), ec(\"/dev/stdin\", 0), ec(\"/dev/stdout\", 1), ec(\"/dev/stderr\", 1));\n      Jb = !1;\n      eb(Ma);\n      aa(m);\n      if (m.onRuntimeInitialized) {\n        m.onRuntimeInitialized();\n      }\n      if (m.postRun) {\n        for (\"function\" == typeof m.postRun && (m.postRun = [m.postRun]); m.postRun.length;) {\n          var b = m.postRun.shift();\n          Na.unshift(b);\n        }\n      }\n      eb(Na);\n    }\n  }\n  if (!(0 < Pa)) {\n    if (m.preRun) {\n      for (\"function\" == typeof m.preRun && (m.preRun = [m.preRun]); m.preRun.length;) {\n        Oa();\n      }\n    }\n    eb(La);\n    0 < Pa || (m.setStatus ? (m.setStatus(\"Running...\"), setTimeout(function() {\n      setTimeout(function() {\n        m.setStatus(\"\");\n      }, 1);\n      a();\n    }, 1)) : a());\n  }\n}\nif (m.preInit) {\n  for (\"function\" == typeof m.preInit && (m.preInit = [m.preInit]); 0 < m.preInit.length;) {\n    m.preInit.pop()();\n  }\n}\n$d();\n\n\n\n  return moduleArg.ready\n}\n\n);\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Rive);\n\n/***/ }),\n/* 2 */\n/***/ ((module) => {\n\nmodule.exports = /*#__PURE__*/JSON.parse('{\"name\":\"@rive-app/canvas\",\"version\":\"2.26.5\",\"description\":\"Rive\\'s canvas based web api.\",\"main\":\"rive.js\",\"homepage\":\"https://rive.app\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/rive-app/rive-wasm/tree/master/js\"},\"keywords\":[\"rive\",\"animation\"],\"author\":\"Rive\",\"contributors\":[\"Luigi Rosso <luigi@rive.app> (https://rive.app)\",\"Maxwell Talbot <max@rive.app> (https://rive.app)\",\"Arthur Vivian <arthur@rive.app> (https://rive.app)\",\"Umberto Sonnino <umberto@rive.app> (https://rive.app)\",\"Matthew Sullivan <matt.j.sullivan@gmail.com> (mailto:matt.j.sullivan@gmail.com)\"],\"license\":\"MIT\",\"files\":[\"rive.js\",\"rive.js.map\",\"rive.wasm\",\"rive_fallback.wasm\",\"rive.d.ts\",\"rive_advanced.mjs.d.ts\"],\"typings\":\"rive.d.ts\",\"dependencies\":{},\"browser\":{\"fs\":false,\"path\":false}}');\n\n/***/ }),\n/* 3 */\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_96233__) => {\n\n__nested_webpack_require_96233__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_96233__.d(__nested_webpack_exports__, {\n/* harmony export */   Animation: () => (/* reexport safe */ _Animation__WEBPACK_IMPORTED_MODULE_0__.Animation)\n/* harmony export */ });\n/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_96233__(4);\n\n\n\n/***/ }),\n/* 4 */\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_96673__) => {\n\n__nested_webpack_require_96673__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_96673__.d(__nested_webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation)\n/* harmony export */ });\n/**\n * Represents an animation that can be played on an Artboard.\n * Wraps animations and instances from the runtime and keeps track of playback state.\n *\n * The `Animation` class manages the state and behavior of a single animation instance,\n * including its current time, loop count, and ability to scrub to a specific time.\n *\n * The class provides methods to advance the animation, apply its interpolated keyframe\n * values to the Artboard, and clean up the underlying animation instance when the\n * animation is no longer needed.\n */\nvar Animation = /** @class */ (function () {\n    /**\n     * Constructs a new animation\n     * @constructor\n     * @param {any} animation: runtime animation object\n     * @param {any} instance: runtime animation instance object\n     */\n    function Animation(animation, artboard, runtime, playing) {\n        this.animation = animation;\n        this.artboard = artboard;\n        this.playing = playing;\n        this.loopCount = 0;\n        /**\n         * The time to which the animation should move to on the next render.\n         * If not null, the animation will scrub to this time instead of advancing by the given time.\n         */\n        this.scrubTo = null;\n        this.instance = new runtime.LinearAnimationInstance(animation, artboard);\n    }\n    Object.defineProperty(Animation.prototype, \"name\", {\n        /**\n         * Returns the animation's name\n         */\n        get: function () {\n            return this.animation.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"time\", {\n        /**\n         * Returns the animation's name\n         */\n        get: function () {\n            return this.instance.time;\n        },\n        /**\n         * Sets the animation's current time\n         */\n        set: function (value) {\n            this.instance.time = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"loopValue\", {\n        /**\n         * Returns the animation's loop type\n         */\n        get: function () {\n            return this.animation.loopValue;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animation.prototype, \"needsScrub\", {\n        /**\n         * Indicates whether the animation needs to be scrubbed.\n         * @returns `true` if the animation needs to be scrubbed, `false` otherwise.\n         */\n        get: function () {\n            return this.scrubTo !== null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Advances the animation by the give time. If the animation needs scrubbing,\n     * time is ignored and the stored scrub value is used.\n     * @param time the time to advance the animation by if no scrubbing required\n     */\n    Animation.prototype.advance = function (time) {\n        if (this.scrubTo === null) {\n            this.instance.advance(time);\n        }\n        else {\n            this.instance.time = 0;\n            this.instance.advance(this.scrubTo);\n            this.scrubTo = null;\n        }\n    };\n    /**\n     * Apply interpolated keyframe values to the artboard. This should be called after calling\n     * .advance() on an animation instance so that new values are applied to properties.\n     *\n     * Note: This does not advance the artboard, which updates all objects on the artboard\n     * @param mix - Mix value for the animation from 0 to 1\n     */\n    Animation.prototype.apply = function (mix) {\n        this.instance.apply(mix);\n    };\n    /**\n     * Deletes the backing Wasm animation instance; once this is called, this\n     * animation is no more.\n     */\n    Animation.prototype.cleanup = function () {\n        this.instance.delete();\n    };\n    return Animation;\n}());\n\n\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_100807__) => {\n\n__nested_webpack_require_100807__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_100807__.d(__nested_webpack_exports__, {\n/* harmony export */   BLANK_URL: () => (/* reexport safe */ _sanitizeUrl__WEBPACK_IMPORTED_MODULE_1__.BLANK_URL),\n/* harmony export */   registerTouchInteractions: () => (/* reexport safe */ _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__.registerTouchInteractions),\n/* harmony export */   sanitizeUrl: () => (/* reexport safe */ _sanitizeUrl__WEBPACK_IMPORTED_MODULE_1__.sanitizeUrl)\n/* harmony export */ });\n/* harmony import */ var _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_100807__(6);\n/* harmony import */ var _sanitizeUrl__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_100807__(7);\n\n\n\n\n/***/ }),\n/* 6 */\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_101639__) => {\n\n__nested_webpack_require_101639__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_101639__.d(__nested_webpack_exports__, {\n/* harmony export */   registerTouchInteractions: () => (/* binding */ registerTouchInteractions)\n/* harmony export */ });\nvar _this = undefined;\n/**\n * Returns the clientX and clientY properties from touch or mouse events. Also\n * calls preventDefault() on the event if it is a touchstart or touchmove to prevent\n * scrolling the page on mobile devices\n * @param event - Either a TouchEvent or a MouseEvent\n * @returns - Coordinates of the clientX and clientY properties from the touch/mouse event\n */\nvar getClientCoordinates = function (event, isTouchScrollEnabled) {\n    var _a, _b;\n    if ([\"touchstart\", \"touchmove\"].indexOf(event.type) > -1 &&\n        ((_a = event.touches) === null || _a === void 0 ? void 0 : _a.length)) {\n        // This flag, if false, prevents touch events on the canvas default behavior\n        // which may prevent scrolling if a drag motion on the canvas is performed\n        if (!isTouchScrollEnabled) {\n            event.preventDefault();\n        }\n        return {\n            clientX: event.touches[0].clientX,\n            clientY: event.touches[0].clientY,\n        };\n    }\n    else if (event.type === \"touchend\" &&\n        ((_b = event.changedTouches) === null || _b === void 0 ? void 0 : _b.length)) {\n        return {\n            clientX: event.changedTouches[0].clientX,\n            clientY: event.changedTouches[0].clientY,\n        };\n    }\n    else {\n        return {\n            clientX: event.clientX,\n            clientY: event.clientY,\n        };\n    }\n};\n/**\n * Registers mouse move/up/down callback handlers on the canvas to send meaningful coordinates to\n * the state machine pointer move/up/down functions based on cursor interaction\n */\nvar registerTouchInteractions = function (_a) {\n    var canvas = _a.canvas, artboard = _a.artboard, _b = _a.stateMachines, stateMachines = _b === void 0 ? [] : _b, renderer = _a.renderer, rive = _a.rive, fit = _a.fit, alignment = _a.alignment, _c = _a.isTouchScrollEnabled, isTouchScrollEnabled = _c === void 0 ? false : _c, _d = _a.layoutScaleFactor, layoutScaleFactor = _d === void 0 ? 1.0 : _d;\n    if (!canvas ||\n        !stateMachines.length ||\n        !renderer ||\n        !rive ||\n        !artboard ||\n        typeof window === \"undefined\") {\n        return null;\n    }\n    /**\n     * After a touchend event, some browsers may fire synthetic mouse events\n     * (mouseover, mousedown, mousemove, mouseup) if the touch interaction did not cause\n     * any default action (such as scrolling).\n     *\n     * This is done to simulate the behavior of a mouse for applications that do not support\n     * touch events.\n     *\n     * We're keeping track of the previous event to not send the synthetic mouse events if the\n     * touch event was a click (touchstart -> touchend).\n     *\n     * This is only needed when `isTouchScrollEnabled` is false\n     * When true, `preventDefault()` is called which prevents this behaviour.\n     **/\n    var _prevEventType = null;\n    var _syntheticEventsActive = false;\n    var processEventCallback = function (event) {\n        // Exit early out of all synthetic mouse events\n        // https://stackoverflow.com/questions/9656990/how-to-prevent-simulated-mouse-events-in-mobile-browsers\n        // https://stackoverflow.com/questions/25572070/javascript-touchend-versus-click-dilemma\n        if (_syntheticEventsActive && event instanceof MouseEvent) {\n            // Synthetic event finished\n            if (event.type == \"mouseup\") {\n                _syntheticEventsActive = false;\n            }\n            return;\n        }\n        // Test if it's a \"touch click\". This could cause the browser to send\n        // synthetic mouse events.\n        _syntheticEventsActive =\n            isTouchScrollEnabled &&\n                event.type === \"touchend\" &&\n                _prevEventType === \"touchstart\";\n        _prevEventType = event.type;\n        var boundingRect = event.currentTarget.getBoundingClientRect();\n        var _a = getClientCoordinates(event, isTouchScrollEnabled), clientX = _a.clientX, clientY = _a.clientY;\n        if (!clientX && !clientY) {\n            return;\n        }\n        var canvasX = clientX - boundingRect.left;\n        var canvasY = clientY - boundingRect.top;\n        var forwardMatrix = rive.computeAlignment(fit, alignment, {\n            minX: 0,\n            minY: 0,\n            maxX: boundingRect.width,\n            maxY: boundingRect.height,\n        }, artboard.bounds, layoutScaleFactor);\n        var invertedMatrix = new rive.Mat2D();\n        forwardMatrix.invert(invertedMatrix);\n        var canvasCoordinatesVector = new rive.Vec2D(canvasX, canvasY);\n        var transformedVector = rive.mapXY(invertedMatrix, canvasCoordinatesVector);\n        var transformedX = transformedVector.x();\n        var transformedY = transformedVector.y();\n        transformedVector.delete();\n        invertedMatrix.delete();\n        canvasCoordinatesVector.delete();\n        forwardMatrix.delete();\n        switch (event.type) {\n            /**\n             * There's a 2px buffer for a hitRadius when translating the pointer coordinates\n             * down to the state machine. In cases where the hitbox is about that much away\n             * from the Artboard border, we don't have exact precision on determining pointer\n             * exit. We're therefore adding to the translated coordinates on mouseout of a canvas\n             * to ensure that we report the mouse has truly exited the hitarea.\n             * https://github.com/rive-app/rive-cpp/blob/master/src/animation/state_machine_instance.cpp#L336\n             *\n             * We add/subtract 10000 to account for when the graphic goes beyond the canvas bound\n             * due to for example, a fit: 'cover'. Not perfect, but helps reliably (for now) ensure\n             * we report going out of bounds when the mouse is out of the canvas\n             */\n            case \"mouseout\":\n                for (var _i = 0, stateMachines_1 = stateMachines; _i < stateMachines_1.length; _i++) {\n                    var stateMachine = stateMachines_1[_i];\n                    stateMachine.pointerMove(transformedX, transformedY);\n                }\n                break;\n            // Pointer moving/hovering on the canvas\n            case \"touchmove\":\n            case \"mouseover\":\n            case \"mousemove\": {\n                for (var _b = 0, stateMachines_2 = stateMachines; _b < stateMachines_2.length; _b++) {\n                    var stateMachine = stateMachines_2[_b];\n                    stateMachine.pointerMove(transformedX, transformedY);\n                }\n                break;\n            }\n            // Pointer click initiated but not released yet on the canvas\n            case \"touchstart\":\n            case \"mousedown\": {\n                for (var _c = 0, stateMachines_3 = stateMachines; _c < stateMachines_3.length; _c++) {\n                    var stateMachine = stateMachines_3[_c];\n                    stateMachine.pointerDown(transformedX, transformedY);\n                }\n                break;\n            }\n            // Pointer click released on the canvas\n            case \"touchend\":\n            case \"mouseup\": {\n                for (var _d = 0, stateMachines_4 = stateMachines; _d < stateMachines_4.length; _d++) {\n                    var stateMachine = stateMachines_4[_d];\n                    stateMachine.pointerUp(transformedX, transformedY);\n                }\n                break;\n            }\n            default:\n        }\n    };\n    var callback = processEventCallback.bind(_this);\n    canvas.addEventListener(\"mouseover\", callback);\n    canvas.addEventListener(\"mouseout\", callback);\n    canvas.addEventListener(\"mousemove\", callback);\n    canvas.addEventListener(\"mousedown\", callback);\n    canvas.addEventListener(\"mouseup\", callback);\n    canvas.addEventListener(\"touchmove\", callback, {\n        passive: isTouchScrollEnabled,\n    });\n    canvas.addEventListener(\"touchstart\", callback, {\n        passive: isTouchScrollEnabled,\n    });\n    canvas.addEventListener(\"touchend\", callback);\n    return function () {\n        canvas.removeEventListener(\"mouseover\", callback);\n        canvas.removeEventListener(\"mouseout\", callback);\n        canvas.removeEventListener(\"mousemove\", callback);\n        canvas.removeEventListener(\"mousedown\", callback);\n        canvas.removeEventListener(\"mouseup\", callback);\n        canvas.removeEventListener(\"touchmove\", callback);\n        canvas.removeEventListener(\"touchstart\", callback);\n        canvas.removeEventListener(\"touchend\", callback);\n    };\n};\n\n\n/***/ }),\n/* 7 */\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_110398__) => {\n\n__nested_webpack_require_110398__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_110398__.d(__nested_webpack_exports__, {\n/* harmony export */   BLANK_URL: () => (/* binding */ BLANK_URL),\n/* harmony export */   sanitizeUrl: () => (/* binding */ sanitizeUrl)\n/* harmony export */ });\n// Reference: https://github.com/braintree/sanitize-url/tree/main\nvar invalidProtocolRegex = /^([^\\w]*)(javascript|data|vbscript)/im;\nvar htmlEntitiesRegex = /&#(\\w+)(^\\w|;)?/g;\nvar htmlCtrlEntityRegex = /&(newline|tab);/gi;\nvar ctrlCharactersRegex = /[\\u0000-\\u001F\\u007F-\\u009F\\u2000-\\u200D\\uFEFF]/gim;\nvar urlSchemeRegex = /^.+(:|&colon;)/gim;\nvar relativeFirstCharacters = [\".\", \"/\"];\nvar BLANK_URL = \"about:blank\";\nfunction isRelativeUrlWithoutProtocol(url) {\n    return relativeFirstCharacters.indexOf(url[0]) > -1;\n}\n// adapted from https://stackoverflow.com/a/29824550/2601552\nfunction decodeHtmlCharacters(str) {\n    var removedNullByte = str.replace(ctrlCharactersRegex, \"\");\n    return removedNullByte.replace(htmlEntitiesRegex, function (match, dec) {\n        return String.fromCharCode(dec);\n    });\n}\nfunction sanitizeUrl(url) {\n    if (!url) {\n        return BLANK_URL;\n    }\n    var sanitizedUrl = decodeHtmlCharacters(url)\n        .replace(htmlCtrlEntityRegex, \"\")\n        .replace(ctrlCharactersRegex, \"\")\n        .trim();\n    if (!sanitizedUrl) {\n        return BLANK_URL;\n    }\n    if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {\n        return sanitizedUrl;\n    }\n    var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);\n    if (!urlSchemeParseResults) {\n        return sanitizedUrl;\n    }\n    var urlScheme = urlSchemeParseResults[0];\n    if (invalidProtocolRegex.test(urlScheme)) {\n        return BLANK_URL;\n    }\n    return sanitizedUrl;\n}\n\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_112404__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_112404__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_112404__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_112404__.o(definition, key) && !__nested_webpack_require_112404__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_112404__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_112404__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.\n(() => {\n__nested_webpack_require_112404__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_112404__.d(__nested_webpack_exports__, {\n/* harmony export */   Alignment: () => (/* binding */ Alignment),\n/* harmony export */   DataEnum: () => (/* binding */ DataEnum),\n/* harmony export */   EventType: () => (/* binding */ EventType),\n/* harmony export */   Fit: () => (/* binding */ Fit),\n/* harmony export */   Layout: () => (/* binding */ Layout),\n/* harmony export */   LoopType: () => (/* binding */ LoopType),\n/* harmony export */   Rive: () => (/* binding */ Rive),\n/* harmony export */   RiveEventType: () => (/* binding */ RiveEventType),\n/* harmony export */   RiveFile: () => (/* binding */ RiveFile),\n/* harmony export */   RuntimeLoader: () => (/* binding */ RuntimeLoader),\n/* harmony export */   StateMachineInput: () => (/* binding */ StateMachineInput),\n/* harmony export */   StateMachineInputType: () => (/* binding */ StateMachineInputType),\n/* harmony export */   Testing: () => (/* binding */ Testing),\n/* harmony export */   ViewModel: () => (/* binding */ ViewModel),\n/* harmony export */   ViewModelInstance: () => (/* binding */ ViewModelInstance),\n/* harmony export */   ViewModelInstanceBoolean: () => (/* binding */ ViewModelInstanceBoolean),\n/* harmony export */   ViewModelInstanceColor: () => (/* binding */ ViewModelInstanceColor),\n/* harmony export */   ViewModelInstanceEnum: () => (/* binding */ ViewModelInstanceEnum),\n/* harmony export */   ViewModelInstanceNumber: () => (/* binding */ ViewModelInstanceNumber),\n/* harmony export */   ViewModelInstanceString: () => (/* binding */ ViewModelInstanceString),\n/* harmony export */   ViewModelInstanceTrigger: () => (/* binding */ ViewModelInstanceTrigger),\n/* harmony export */   ViewModelInstanceValue: () => (/* binding */ ViewModelInstanceValue),\n/* harmony export */   decodeAudio: () => (/* binding */ decodeAudio),\n/* harmony export */   decodeFont: () => (/* binding */ decodeFont),\n/* harmony export */   decodeImage: () => (/* binding */ decodeImage)\n/* harmony export */ });\n/* harmony import */ var _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_112404__(1);\n/* harmony import */ var package_json__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_112404__(2);\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_112404__(3);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_112404__(5);\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = ( false) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\nvar RiveError = /** @class */ (function (_super) {\n    __extends(RiveError, _super);\n    function RiveError() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isHandledError = true;\n        return _this;\n    }\n    return RiveError;\n}(Error));\n// #regions helpers\nvar resolveErrorMessage = function (error) {\n    return error && error.isHandledError\n        ? error.message\n        : \"Problem loading file; may be corrupt!\";\n};\n// #region layout\n// Fit options for the canvas\nvar Fit;\n(function (Fit) {\n    Fit[\"Cover\"] = \"cover\";\n    Fit[\"Contain\"] = \"contain\";\n    Fit[\"Fill\"] = \"fill\";\n    Fit[\"FitWidth\"] = \"fitWidth\";\n    Fit[\"FitHeight\"] = \"fitHeight\";\n    Fit[\"None\"] = \"none\";\n    Fit[\"ScaleDown\"] = \"scaleDown\";\n    Fit[\"Layout\"] = \"layout\";\n})(Fit || (Fit = {}));\n// Alignment options for the canvas\nvar Alignment;\n(function (Alignment) {\n    Alignment[\"Center\"] = \"center\";\n    Alignment[\"TopLeft\"] = \"topLeft\";\n    Alignment[\"TopCenter\"] = \"topCenter\";\n    Alignment[\"TopRight\"] = \"topRight\";\n    Alignment[\"CenterLeft\"] = \"centerLeft\";\n    Alignment[\"CenterRight\"] = \"centerRight\";\n    Alignment[\"BottomLeft\"] = \"bottomLeft\";\n    Alignment[\"BottomCenter\"] = \"bottomCenter\";\n    Alignment[\"BottomRight\"] = \"bottomRight\";\n})(Alignment || (Alignment = {}));\n// Alignment options for Rive animations in a HTML canvas\nvar Layout = /** @class */ (function () {\n    function Layout(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : Fit.Contain;\n        this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : Alignment.Center;\n        this.layoutScaleFactor = (_c = params === null || params === void 0 ? void 0 : params.layoutScaleFactor) !== null && _c !== void 0 ? _c : 1;\n        this.minX = (_d = params === null || params === void 0 ? void 0 : params.minX) !== null && _d !== void 0 ? _d : 0;\n        this.minY = (_e = params === null || params === void 0 ? void 0 : params.minY) !== null && _e !== void 0 ? _e : 0;\n        this.maxX = (_f = params === null || params === void 0 ? void 0 : params.maxX) !== null && _f !== void 0 ? _f : 0;\n        this.maxY = (_g = params === null || params === void 0 ? void 0 : params.maxY) !== null && _g !== void 0 ? _g : 0;\n    }\n    // Alternative constructor to build a Layout from an interface/object\n    Layout.new = function (_a) {\n        var fit = _a.fit, alignment = _a.alignment, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n        console.warn(\"This function is deprecated: please use `new Layout({})` instead\");\n        return new Layout({ fit: fit, alignment: alignment, minX: minX, minY: minY, maxX: maxX, maxY: maxY });\n    };\n    /**\n     * Makes a copy of the layout, replacing any specified parameters\n     */\n    Layout.prototype.copyWith = function (_a) {\n        var fit = _a.fit, alignment = _a.alignment, layoutScaleFactor = _a.layoutScaleFactor, minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n        return new Layout({\n            fit: fit !== null && fit !== void 0 ? fit : this.fit,\n            alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,\n            layoutScaleFactor: layoutScaleFactor !== null && layoutScaleFactor !== void 0 ? layoutScaleFactor : this.layoutScaleFactor,\n            minX: minX !== null && minX !== void 0 ? minX : this.minX,\n            minY: minY !== null && minY !== void 0 ? minY : this.minY,\n            maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,\n            maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY,\n        });\n    };\n    // Returns fit for the Wasm runtime format\n    Layout.prototype.runtimeFit = function (rive) {\n        if (this.cachedRuntimeFit)\n            return this.cachedRuntimeFit;\n        var fit;\n        if (this.fit === Fit.Cover)\n            fit = rive.Fit.cover;\n        else if (this.fit === Fit.Contain)\n            fit = rive.Fit.contain;\n        else if (this.fit === Fit.Fill)\n            fit = rive.Fit.fill;\n        else if (this.fit === Fit.FitWidth)\n            fit = rive.Fit.fitWidth;\n        else if (this.fit === Fit.FitHeight)\n            fit = rive.Fit.fitHeight;\n        else if (this.fit === Fit.ScaleDown)\n            fit = rive.Fit.scaleDown;\n        else if (this.fit === Fit.Layout)\n            fit = rive.Fit.layout;\n        else\n            fit = rive.Fit.none;\n        this.cachedRuntimeFit = fit;\n        return fit;\n    };\n    // Returns alignment for the Wasm runtime format\n    Layout.prototype.runtimeAlignment = function (rive) {\n        if (this.cachedRuntimeAlignment)\n            return this.cachedRuntimeAlignment;\n        var alignment;\n        if (this.alignment === Alignment.TopLeft)\n            alignment = rive.Alignment.topLeft;\n        else if (this.alignment === Alignment.TopCenter)\n            alignment = rive.Alignment.topCenter;\n        else if (this.alignment === Alignment.TopRight)\n            alignment = rive.Alignment.topRight;\n        else if (this.alignment === Alignment.CenterLeft)\n            alignment = rive.Alignment.centerLeft;\n        else if (this.alignment === Alignment.CenterRight)\n            alignment = rive.Alignment.centerRight;\n        else if (this.alignment === Alignment.BottomLeft)\n            alignment = rive.Alignment.bottomLeft;\n        else if (this.alignment === Alignment.BottomCenter)\n            alignment = rive.Alignment.bottomCenter;\n        else if (this.alignment === Alignment.BottomRight)\n            alignment = rive.Alignment.bottomRight;\n        else\n            alignment = rive.Alignment.center;\n        this.cachedRuntimeAlignment = alignment;\n        return alignment;\n    };\n    return Layout;\n}());\n\n// Runtime singleton; use getInstance to provide a callback that returns the\n// Rive runtime\nvar RuntimeLoader = /** @class */ (function () {\n    // Class is never instantiated\n    function RuntimeLoader() {\n    }\n    // Loads the runtime\n    RuntimeLoader.loadRuntime = function () {\n        _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            // Loads Wasm bundle\n            locateFile: function () { return RuntimeLoader.wasmURL; },\n        })\n            .then(function (rive) {\n            var _a;\n            RuntimeLoader.runtime = rive;\n            // Fire all the callbacks\n            while (RuntimeLoader.callBackQueue.length > 0) {\n                (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);\n            }\n        })\n            .catch(function (error) {\n            // Capture specific error details\n            var errorDetails = {\n                message: (error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\",\n                type: (error === null || error === void 0 ? void 0 : error.name) || \"Error\",\n                // Some browsers may provide additional WebAssembly-specific details\n                wasmError: error instanceof WebAssembly.CompileError ||\n                    error instanceof WebAssembly.RuntimeError,\n                originalError: error,\n            };\n            // Log detailed error for debugging\n            console.debug(\"Rive WASM load error details:\", errorDetails);\n            // In case unpkg fails, or the wasm was not supported, we try to load the fallback module from jsdelivr.\n            // This `rive_fallback.wasm` is compiled to support older architecture.\n            // TODO: (Gordon): preemptively test browser support and load the correct wasm file. Then use jsdelvr only if unpkg fails.\n            var backupJsdelivrUrl = \"https://cdn.jsdelivr.net/npm/\".concat(package_json__WEBPACK_IMPORTED_MODULE_1__.name, \"@\").concat(package_json__WEBPACK_IMPORTED_MODULE_1__.version, \"/rive_fallback.wasm\");\n            if (RuntimeLoader.wasmURL.toLowerCase() !== backupJsdelivrUrl) {\n                console.warn(\"Failed to load WASM from \".concat(RuntimeLoader.wasmURL, \" (\").concat(errorDetails.message, \"), trying jsdelivr as a backup\"));\n                RuntimeLoader.setWasmUrl(backupJsdelivrUrl);\n                RuntimeLoader.loadRuntime();\n            }\n            else {\n                var errorMessage = [\n                    \"Could not load Rive WASM file from \".concat(RuntimeLoader.wasmURL, \" or \").concat(backupJsdelivrUrl, \".\"),\n                    \"Possible reasons:\",\n                    \"- Network connection is down\",\n                    \"- WebAssembly is not supported in this environment\",\n                    \"- The WASM file is corrupted or incompatible\",\n                    \"\\nError details:\",\n                    \"- Type: \".concat(errorDetails.type),\n                    \"- Message: \".concat(errorDetails.message),\n                    \"- WebAssembly-specific error: \".concat(errorDetails.wasmError),\n                    \"\\nTo resolve, you may need to:\",\n                    \"1. Check your network connection\",\n                    \"2. Set a new WASM source via RuntimeLoader.setWasmUrl()\",\n                    \"3. Call RuntimeLoader.loadRuntime() again\",\n                ].join(\"\\n\");\n                console.error(errorMessage);\n            }\n        });\n    };\n    // Provides a runtime instance via a callback\n    RuntimeLoader.getInstance = function (callback) {\n        // If it's not loading, start loading runtime\n        if (!RuntimeLoader.isLoading) {\n            RuntimeLoader.isLoading = true;\n            RuntimeLoader.loadRuntime();\n        }\n        if (!RuntimeLoader.runtime) {\n            RuntimeLoader.callBackQueue.push(callback);\n        }\n        else {\n            callback(RuntimeLoader.runtime);\n        }\n    };\n    // Provides a runtime instance via a promise\n    RuntimeLoader.awaitInstance = function () {\n        return new Promise(function (resolve) {\n            return RuntimeLoader.getInstance(function (rive) { return resolve(rive); });\n        });\n    };\n    // Manually sets the wasm url\n    RuntimeLoader.setWasmUrl = function (url) {\n        RuntimeLoader.wasmURL = url;\n    };\n    // Gets the current wasm url\n    RuntimeLoader.getWasmUrl = function () {\n        return RuntimeLoader.wasmURL;\n    };\n    // Flag to indicate that loading has started/completed\n    RuntimeLoader.isLoading = false;\n    // List of callbacks for the runtime that come in while loading\n    RuntimeLoader.callBackQueue = [];\n    // Path to the Wasm file; default path works for testing only;\n    // if embedded wasm is used then this is never used.\n    RuntimeLoader.wasmURL = \"https://unpkg.com/\".concat(package_json__WEBPACK_IMPORTED_MODULE_1__.name, \"@\").concat(package_json__WEBPACK_IMPORTED_MODULE_1__.version, \"/rive.wasm\");\n    return RuntimeLoader;\n}());\n\n// #endregion\n// #region state machines\nvar StateMachineInputType;\n(function (StateMachineInputType) {\n    StateMachineInputType[StateMachineInputType[\"Number\"] = 56] = \"Number\";\n    StateMachineInputType[StateMachineInputType[\"Trigger\"] = 58] = \"Trigger\";\n    StateMachineInputType[StateMachineInputType[\"Boolean\"] = 59] = \"Boolean\";\n})(StateMachineInputType || (StateMachineInputType = {}));\n/**\n * An input for a state machine\n */\nvar StateMachineInput = /** @class */ (function () {\n    function StateMachineInput(type, runtimeInput) {\n        this.type = type;\n        this.runtimeInput = runtimeInput;\n    }\n    Object.defineProperty(StateMachineInput.prototype, \"name\", {\n        /**\n         * Returns the name of the input\n         */\n        get: function () {\n            return this.runtimeInput.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMachineInput.prototype, \"value\", {\n        /**\n         * Returns the current value of the input\n         */\n        get: function () {\n            return this.runtimeInput.value;\n        },\n        /**\n         * Sets the value of the input\n         */\n        set: function (value) {\n            this.runtimeInput.value = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Fires a trigger; does nothing on Number or Boolean input types\n     */\n    StateMachineInput.prototype.fire = function () {\n        if (this.type === StateMachineInputType.Trigger) {\n            this.runtimeInput.fire();\n        }\n    };\n    /**\n     * Deletes the input\n     */\n    StateMachineInput.prototype.delete = function () {\n        this.runtimeInput = null;\n    };\n    return StateMachineInput;\n}());\n\nvar RiveEventType;\n(function (RiveEventType) {\n    RiveEventType[RiveEventType[\"General\"] = 128] = \"General\";\n    RiveEventType[RiveEventType[\"OpenUrl\"] = 131] = \"OpenUrl\";\n})(RiveEventType || (RiveEventType = {}));\nvar StateMachine = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param stateMachine runtime state machine object\n     * @param instance runtime state machine instance object\n     */\n    function StateMachine(stateMachine, runtime, playing, artboard) {\n        this.stateMachine = stateMachine;\n        this.playing = playing;\n        this.artboard = artboard;\n        /**\n         * Caches the inputs from the runtime\n         */\n        this.inputs = [];\n        this.instance = new runtime.StateMachineInstance(stateMachine, artboard);\n        this.initInputs(runtime);\n    }\n    Object.defineProperty(StateMachine.prototype, \"name\", {\n        get: function () {\n            return this.stateMachine.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(StateMachine.prototype, \"statesChanged\", {\n        /**\n         * Returns a list of state names that have changed on this frame\n         */\n        get: function () {\n            var names = [];\n            for (var i = 0; i < this.instance.stateChangedCount(); i++) {\n                names.push(this.instance.stateChangedNameByIndex(i));\n            }\n            return names;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Advances the state machine instance by a given time.\n     * @param time - the time to advance the animation by in seconds\n     */\n    StateMachine.prototype.advance = function (time) {\n        this.instance.advance(time);\n    };\n    /**\n     * Advances the state machine instance by a given time and apply changes to artboard.\n     * @param time - the time to advance the animation by in seconds\n     */\n    StateMachine.prototype.advanceAndApply = function (time) {\n        this.instance.advanceAndApply(time);\n    };\n    /**\n     * Returns the number of events reported from the last advance call\n     * @returns Number of events reported\n     */\n    StateMachine.prototype.reportedEventCount = function () {\n        return this.instance.reportedEventCount();\n    };\n    /**\n     * Returns a RiveEvent object emitted from the last advance call at the given index\n     * of a list of potentially multiple events. If an event at the index is not found,\n     * undefined is returned.\n     * @param i index of the event reported in a list of potentially multiple events\n     * @returns RiveEvent or extended RiveEvent object returned, or undefined\n     */\n    StateMachine.prototype.reportedEventAt = function (i) {\n        return this.instance.reportedEventAt(i);\n    };\n    /**\n     * Fetches references to the state machine's inputs and caches them\n     * @param runtime an instance of the runtime; needed for the SMIInput types\n     */\n    StateMachine.prototype.initInputs = function (runtime) {\n        // Fetch the inputs from the runtime if we don't have them\n        for (var i = 0; i < this.instance.inputCount(); i++) {\n            var input = this.instance.input(i);\n            this.inputs.push(this.mapRuntimeInput(input, runtime));\n        }\n    };\n    /**\n     * Maps a runtime input to it's appropriate type\n     * @param input\n     */\n    StateMachine.prototype.mapRuntimeInput = function (input, runtime) {\n        if (input.type === runtime.SMIInput.bool) {\n            return new StateMachineInput(StateMachineInputType.Boolean, input.asBool());\n        }\n        else if (input.type === runtime.SMIInput.number) {\n            return new StateMachineInput(StateMachineInputType.Number, input.asNumber());\n        }\n        else if (input.type === runtime.SMIInput.trigger) {\n            return new StateMachineInput(StateMachineInputType.Trigger, input.asTrigger());\n        }\n    };\n    /**\n     * Deletes the backing Wasm state machine instance; once this is called, this\n     * state machine is no more.\n     */\n    StateMachine.prototype.cleanup = function () {\n        this.inputs.forEach(function (input) {\n            input.delete();\n        });\n        this.inputs.length = 0;\n        this.instance.delete();\n    };\n    StateMachine.prototype.bindViewModelInstance = function (viewModelInstance) {\n        if (viewModelInstance.runtimeInstance != null) {\n            this.instance.bindViewModelInstance(viewModelInstance.runtimeInstance);\n        }\n    };\n    return StateMachine;\n}());\n// #endregion\n// #region animator\n/**\n * Manages animation\n */\nvar Animator = /** @class */ (function () {\n    /**\n     * Constructs a new animator\n     * @constructor\n     * @param runtime Rive runtime; needed to instance animations & state machines\n     * @param artboard the artboard that holds all animations and state machines\n     * @param animations optional list of animations\n     * @param stateMachines optional list of state machines\n     */\n    function Animator(runtime, artboard, eventManager, animations, stateMachines) {\n        if (animations === void 0) { animations = []; }\n        if (stateMachines === void 0) { stateMachines = []; }\n        this.runtime = runtime;\n        this.artboard = artboard;\n        this.eventManager = eventManager;\n        this.animations = animations;\n        this.stateMachines = stateMachines;\n    }\n    /**\n     * Adds animations and state machines by their names. If names are shared\n     * between animations & state machines, then the first one found will be\n     * created. Best not to use the same names for these in your Rive file.\n     * @param animatable the name(s) of animations and state machines to add\n     * @returns a list of names of the playing animations and state machines\n     */\n    Animator.prototype.add = function (animatables, playing, fireEvent) {\n        if (fireEvent === void 0) { fireEvent = true; }\n        animatables = mapToStringArray(animatables);\n        // If animatables is empty, play or pause everything\n        if (animatables.length === 0) {\n            this.animations.forEach(function (a) { return (a.playing = playing); });\n            this.stateMachines.forEach(function (m) { return (m.playing = playing); });\n        }\n        else {\n            // Play/pause already instanced items, or create new instances\n            var instancedAnimationNames = this.animations.map(function (a) { return a.name; });\n            var instancedMachineNames = this.stateMachines.map(function (m) { return m.name; });\n            for (var i = 0; i < animatables.length; i++) {\n                var aIndex = instancedAnimationNames.indexOf(animatables[i]);\n                var mIndex = instancedMachineNames.indexOf(animatables[i]);\n                if (aIndex >= 0 || mIndex >= 0) {\n                    if (aIndex >= 0) {\n                        // Animation is instanced, play/pause it\n                        this.animations[aIndex].playing = playing;\n                    }\n                    else {\n                        // State machine is instanced, play/pause it\n                        this.stateMachines[mIndex].playing = playing;\n                    }\n                }\n                else {\n                    // Try to create a new animation instance\n                    var anim = this.artboard.animationByName(animatables[i]);\n                    if (anim) {\n                        var newAnimation = new _animation__WEBPACK_IMPORTED_MODULE_2__.Animation(anim, this.artboard, this.runtime, playing);\n                        // Display the first frame of the specified animation\n                        newAnimation.advance(0);\n                        newAnimation.apply(1.0);\n                        this.animations.push(newAnimation);\n                    }\n                    else {\n                        // Try to create a new state machine instance\n                        var sm = this.artboard.stateMachineByName(animatables[i]);\n                        if (sm) {\n                            var newStateMachine = new StateMachine(sm, this.runtime, playing, this.artboard);\n                            this.stateMachines.push(newStateMachine);\n                        }\n                    }\n                }\n            }\n        }\n        // Fire play/paused events for animations\n        if (fireEvent) {\n            if (playing) {\n                this.eventManager.fire({\n                    type: EventType.Play,\n                    data: this.playing,\n                });\n            }\n            else {\n                this.eventManager.fire({\n                    type: EventType.Pause,\n                    data: this.paused,\n                });\n            }\n        }\n        return playing ? this.playing : this.paused;\n    };\n    /**\n     * Adds linear animations by their names.\n     * @param animatables the name(s) of animations to add\n     * @param playing whether animations should play on instantiation\n     */\n    Animator.prototype.initLinearAnimations = function (animatables, playing) {\n        // Play/pause already instanced items, or create new instances\n        // This validation is kept to maintain compatibility with current behavior.\n        // But given that it this is called during artboard initialization\n        // it should probably be safe to remove.\n        var instancedAnimationNames = this.animations.map(function (a) { return a.name; });\n        for (var i = 0; i < animatables.length; i++) {\n            var aIndex = instancedAnimationNames.indexOf(animatables[i]);\n            if (aIndex >= 0) {\n                this.animations[aIndex].playing = playing;\n            }\n            else {\n                // Try to create a new animation instance\n                var anim = this.artboard.animationByName(animatables[i]);\n                if (anim) {\n                    var newAnimation = new _animation__WEBPACK_IMPORTED_MODULE_2__.Animation(anim, this.artboard, this.runtime, playing);\n                    // Display the first frame of the specified animation\n                    newAnimation.advance(0);\n                    newAnimation.apply(1.0);\n                    this.animations.push(newAnimation);\n                }\n            }\n        }\n    };\n    /**\n     * Adds state machines by their names.\n     * @param animatables the name(s) of state machines to add\n     * @param playing whether state machines should play on instantiation\n     */\n    Animator.prototype.initStateMachines = function (animatables, playing) {\n        // Play/pause already instanced items, or create new instances\n        // This validation is kept to maintain compatibility with current behavior.\n        // But given that it this is called during artboard initialization\n        // it should probably be safe to remove.\n        var instancedStateMachineNames = this.stateMachines.map(function (a) { return a.name; });\n        for (var i = 0; i < animatables.length; i++) {\n            var aIndex = instancedStateMachineNames.indexOf(animatables[i]);\n            if (aIndex >= 0) {\n                this.stateMachines[aIndex].playing = playing;\n            }\n            else {\n                // Try to create a new state machine instance\n                var sm = this.artboard.stateMachineByName(animatables[i]);\n                if (sm) {\n                    var newStateMachine = new StateMachine(sm, this.runtime, playing, this.artboard);\n                    this.stateMachines.push(newStateMachine);\n                    if (!playing) {\n                        newStateMachine.advanceAndApply(0);\n                    }\n                }\n                else {\n                    // In order to maintain compatibility with current behavior, if a state machine is not found\n                    // we look for an animation with the same name\n                    this.initLinearAnimations([animatables[i]], playing);\n                }\n            }\n        }\n    };\n    /**\n     * Play the named animations/state machines\n     * @param animatables the names of the animations/machines to play; plays all if empty\n     * @returns a list of the playing items\n     */\n    Animator.prototype.play = function (animatables) {\n        return this.add(animatables, true);\n    };\n    /**\n     * Pauses named animations and state machines, or everything if nothing is\n     * specified\n     * @param animatables names of the animations and state machines to pause\n     * @returns a list of names of the animations and state machines paused\n     */\n    Animator.prototype.pause = function (animatables) {\n        return this.add(animatables, false);\n    };\n    /**\n     * Set time of named animations\n     * @param animations names of the animations to scrub\n     * @param value time scrub value, a floating point number to which the playhead is jumped\n     * @returns a list of names of the animations that were scrubbed\n     */\n    Animator.prototype.scrub = function (animatables, value) {\n        var forScrubbing = this.animations.filter(function (a) {\n            return animatables.includes(a.name);\n        });\n        forScrubbing.forEach(function (a) { return (a.scrubTo = value); });\n        return forScrubbing.map(function (a) { return a.name; });\n    };\n    Object.defineProperty(Animator.prototype, \"playing\", {\n        /**\n         * Returns a list of names of all animations and state machines currently\n         * playing\n         */\n        get: function () {\n            return this.animations\n                .filter(function (a) { return a.playing; })\n                .map(function (a) { return a.name; })\n                .concat(this.stateMachines.filter(function (m) { return m.playing; }).map(function (m) { return m.name; }));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animator.prototype, \"paused\", {\n        /**\n         * Returns a list of names of all animations and state machines currently\n         * paused\n         */\n        get: function () {\n            return this.animations\n                .filter(function (a) { return !a.playing; })\n                .map(function (a) { return a.name; })\n                .concat(this.stateMachines.filter(function (m) { return !m.playing; }).map(function (m) { return m.name; }));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Stops and removes all named animations and state machines\n     * @param animatables animations and state machines to remove\n     * @returns a list of names of removed items\n     */\n    Animator.prototype.stop = function (animatables) {\n        var _this = this;\n        animatables = mapToStringArray(animatables);\n        // If nothing's specified, wipe them out, all of them\n        var removedNames = [];\n        // Stop everything\n        if (animatables.length === 0) {\n            removedNames = this.animations\n                .map(function (a) { return a.name; })\n                .concat(this.stateMachines.map(function (m) { return m.name; }));\n            // Clean up before emptying the arrays\n            this.animations.forEach(function (a) { return a.cleanup(); });\n            this.stateMachines.forEach(function (m) { return m.cleanup(); });\n            // Empty out the arrays\n            this.animations.splice(0, this.animations.length);\n            this.stateMachines.splice(0, this.stateMachines.length);\n        }\n        else {\n            // Remove only the named animations/state machines\n            var animationsToRemove = this.animations.filter(function (a) {\n                return animatables.includes(a.name);\n            });\n            animationsToRemove.forEach(function (a) {\n                a.cleanup();\n                _this.animations.splice(_this.animations.indexOf(a), 1);\n            });\n            var machinesToRemove = this.stateMachines.filter(function (m) {\n                return animatables.includes(m.name);\n            });\n            machinesToRemove.forEach(function (m) {\n                m.cleanup();\n                _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);\n            });\n            removedNames = animationsToRemove\n                .map(function (a) { return a.name; })\n                .concat(machinesToRemove.map(function (m) { return m.name; }));\n        }\n        this.eventManager.fire({\n            type: EventType.Stop,\n            data: removedNames,\n        });\n        // Return the list of animations removed\n        return removedNames;\n    };\n    Object.defineProperty(Animator.prototype, \"isPlaying\", {\n        /**\n         * Returns true if at least one animation is active\n         */\n        get: function () {\n            return (this.animations.reduce(function (acc, curr) { return acc || curr.playing; }, false) ||\n                this.stateMachines.reduce(function (acc, curr) { return acc || curr.playing; }, false));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animator.prototype, \"isPaused\", {\n        /**\n         * Returns true if all animations are paused and there's at least one animation\n         */\n        get: function () {\n            return (!this.isPlaying &&\n                (this.animations.length > 0 || this.stateMachines.length > 0));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Animator.prototype, \"isStopped\", {\n        /**\n         * Returns true if there are no playing or paused animations/state machines\n         */\n        get: function () {\n            return this.animations.length === 0 && this.stateMachines.length === 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * If there are no animations or state machines, add the first one found\n     * @returns the name of the animation or state machine instanced\n     */\n    Animator.prototype.atLeastOne = function (playing, fireEvent) {\n        if (fireEvent === void 0) { fireEvent = true; }\n        var instancedName;\n        if (this.animations.length === 0 && this.stateMachines.length === 0) {\n            if (this.artboard.animationCount() > 0) {\n                // Add the first animation\n                this.add([(instancedName = this.artboard.animationByIndex(0).name)], playing, fireEvent);\n            }\n            else if (this.artboard.stateMachineCount() > 0) {\n                // Add the first state machine\n                this.add([(instancedName = this.artboard.stateMachineByIndex(0).name)], playing, fireEvent);\n            }\n        }\n        return instancedName;\n    };\n    /**\n     * Checks if any animations have looped and if so, fire the appropriate event\n     */\n    Animator.prototype.handleLooping = function () {\n        for (var _i = 0, _a = this.animations.filter(function (a) { return a.playing; }); _i < _a.length; _i++) {\n            var animation = _a[_i];\n            // Emit if the animation looped\n            if (animation.loopValue === 0 && animation.loopCount) {\n                animation.loopCount = 0;\n                // This is a one-shot; if it has ended, delete the instance\n                this.stop(animation.name);\n            }\n            else if (animation.loopValue === 1 && animation.loopCount) {\n                this.eventManager.fire({\n                    type: EventType.Loop,\n                    data: { animation: animation.name, type: LoopType.Loop },\n                });\n                animation.loopCount = 0;\n            }\n            // Wasm indicates a loop at each time the animation\n            // changes direction, so a full loop/lap occurs every\n            // two loop counts\n            else if (animation.loopValue === 2 && animation.loopCount > 1) {\n                this.eventManager.fire({\n                    type: EventType.Loop,\n                    data: { animation: animation.name, type: LoopType.PingPong },\n                });\n                animation.loopCount = 0;\n            }\n        }\n    };\n    /**\n     * Checks if states have changed in state machines and fires a statechange\n     * event\n     */\n    Animator.prototype.handleStateChanges = function () {\n        var statesChanged = [];\n        for (var _i = 0, _a = this.stateMachines.filter(function (sm) { return sm.playing; }); _i < _a.length; _i++) {\n            var stateMachine = _a[_i];\n            statesChanged.push.apply(statesChanged, stateMachine.statesChanged);\n        }\n        if (statesChanged.length > 0) {\n            this.eventManager.fire({\n                type: EventType.StateChange,\n                data: statesChanged,\n            });\n        }\n    };\n    Animator.prototype.handleAdvancing = function (time) {\n        this.eventManager.fire({\n            type: EventType.Advance,\n            data: time,\n        });\n    };\n    return Animator;\n}());\n// #endregion\n// #region events\n/**\n * Supported event types triggered in Rive\n */\nvar EventType;\n(function (EventType) {\n    EventType[\"Load\"] = \"load\";\n    EventType[\"LoadError\"] = \"loaderror\";\n    EventType[\"Play\"] = \"play\";\n    EventType[\"Pause\"] = \"pause\";\n    EventType[\"Stop\"] = \"stop\";\n    EventType[\"Loop\"] = \"loop\";\n    EventType[\"Draw\"] = \"draw\";\n    EventType[\"Advance\"] = \"advance\";\n    EventType[\"StateChange\"] = \"statechange\";\n    EventType[\"RiveEvent\"] = \"riveevent\";\n    EventType[\"AudioStatusChange\"] = \"audiostatuschange\";\n})(EventType || (EventType = {}));\n/**\n * Looping types: one-shot, loop, and ping-pong\n */\nvar LoopType;\n(function (LoopType) {\n    LoopType[\"OneShot\"] = \"oneshot\";\n    LoopType[\"Loop\"] = \"loop\";\n    LoopType[\"PingPong\"] = \"pingpong\";\n})(LoopType || (LoopType = {}));\n// Manages Rive events and listeners\nvar EventManager = /** @class */ (function () {\n    function EventManager(listeners) {\n        if (listeners === void 0) { listeners = []; }\n        this.listeners = listeners;\n    }\n    // Gets listeners of specified type\n    EventManager.prototype.getListeners = function (type) {\n        return this.listeners.filter(function (e) { return e.type === type; });\n    };\n    // Adds a listener\n    EventManager.prototype.add = function (listener) {\n        if (!this.listeners.includes(listener)) {\n            this.listeners.push(listener);\n        }\n    };\n    /**\n     * Removes a listener\n     * @param listener the listener with the callback to be removed\n     */\n    EventManager.prototype.remove = function (listener) {\n        // We can't simply look for the listener as it'll be a different instance to\n        // one originally subscribed. Find all the listeners of the right type and\n        // then check their callbacks which should match.\n        for (var i = 0; i < this.listeners.length; i++) {\n            var currentListener = this.listeners[i];\n            if (currentListener.type === listener.type) {\n                if (currentListener.callback === listener.callback) {\n                    this.listeners.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    };\n    /**\n     * Clears all listeners of specified type, or every listener if no type is\n     * specified\n     * @param type the type of listeners to clear, or all listeners if not\n     * specified\n     */\n    EventManager.prototype.removeAll = function (type) {\n        var _this = this;\n        if (!type) {\n            this.listeners.splice(0, this.listeners.length);\n        }\n        else {\n            this.listeners\n                .filter(function (l) { return l.type === type; })\n                .forEach(function (l) { return _this.remove(l); });\n        }\n    };\n    // Fires an event\n    EventManager.prototype.fire = function (event) {\n        var eventListeners = this.getListeners(event.type);\n        eventListeners.forEach(function (listener) { return listener.callback(event); });\n    };\n    return EventManager;\n}());\n// Manages a queue of tasks\nvar TaskQueueManager = /** @class */ (function () {\n    function TaskQueueManager(eventManager) {\n        this.eventManager = eventManager;\n        this.queue = [];\n    }\n    // Adds a task top the queue\n    TaskQueueManager.prototype.add = function (task) {\n        this.queue.push(task);\n    };\n    // Processes all tasks in the queue\n    TaskQueueManager.prototype.process = function () {\n        while (this.queue.length > 0) {\n            var task = this.queue.shift();\n            if (task === null || task === void 0 ? void 0 : task.action) {\n                task.action();\n            }\n            if (task === null || task === void 0 ? void 0 : task.event) {\n                this.eventManager.fire(task.event);\n            }\n        }\n    };\n    return TaskQueueManager;\n}());\n// #endregion\n// #region Audio\nvar SystemAudioStatus;\n(function (SystemAudioStatus) {\n    SystemAudioStatus[SystemAudioStatus[\"AVAILABLE\"] = 0] = \"AVAILABLE\";\n    SystemAudioStatus[SystemAudioStatus[\"UNAVAILABLE\"] = 1] = \"UNAVAILABLE\";\n})(SystemAudioStatus || (SystemAudioStatus = {}));\n// Class to handle audio context availability and status changes\nvar AudioManager = /** @class */ (function (_super) {\n    __extends(AudioManager, _super);\n    function AudioManager() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._started = false;\n        _this._enabled = false;\n        _this._status = SystemAudioStatus.UNAVAILABLE;\n        return _this;\n    }\n    AudioManager.prototype.delay = function (time) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve) { return setTimeout(resolve, time); })];\n            });\n        });\n    };\n    AudioManager.prototype.timeout = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (_, reject) { return setTimeout(reject, 50); })];\n            });\n        });\n    };\n    // Alerts animations on status changes and removes the listeners to avoid alerting twice.\n    AudioManager.prototype.reportToListeners = function () {\n        this.fire({ type: EventType.AudioStatusChange });\n        this.removeAll();\n    };\n    /**\n     * The audio context has been resolved.\n     * Alert any listeners that we can now play audio.\n     * Rive will now play audio at the configured volume.\n     */\n    AudioManager.prototype.enableAudio = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!this._enabled) {\n                    this._enabled = true;\n                    this._status = SystemAudioStatus.AVAILABLE;\n                    this.reportToListeners();\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Check if we are able to play audio.\n     *\n     * We currently check the audio context, when resume() returns before a timeout we know that the\n     * audio context is running and we can enable audio.\n     */\n    AudioManager.prototype.testAudio = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(this._status === SystemAudioStatus.UNAVAILABLE &&\n                            this._audioContext !== null)) return [3 /*break*/, 4];\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, Promise.race([this._audioContext.resume(), this.timeout()])];\n                    case 2:\n                        _b.sent();\n                        this.enableAudio();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        _a = _b.sent();\n                        return [3 /*break*/, 4];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Establish audio for use with rive.\n     * We both test if we can use audio intermittently and listen for user interaction.\n     * The aim is to enable audio playback as soon as the browser allows this.\n     */\n    AudioManager.prototype._establishAudio = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!this._started) return [3 /*break*/, 5];\n                        this._started = true;\n                        if (!(typeof window == \"undefined\")) return [3 /*break*/, 1];\n                        this.enableAudio();\n                        return [3 /*break*/, 5];\n                    case 1:\n                        this._audioContext = new AudioContext();\n                        this.listenForUserAction();\n                        _a.label = 2;\n                    case 2:\n                        if (!(this._status === SystemAudioStatus.UNAVAILABLE)) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.testAudio()];\n                    case 3:\n                        _a.sent();\n                        return [4 /*yield*/, this.delay(1000)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 2];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AudioManager.prototype.listenForUserAction = function () {\n        var _this = this;\n        // NOTE: AudioContexts are ready immediately if requested in a ui callback\n        // we *could* re request one in this listener.\n        var _clickListener = function () { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                // note this has \"better\" results than calling `await this.testAudio()`\n                // as we force audio to be enabled in the current thread, rather than chancing\n                // the thread to be passed over for some other async context\n                this.enableAudio();\n                return [2 /*return*/];\n            });\n        }); };\n        // NOTE: we should test this on mobile/pads\n        document.addEventListener(\"pointerdown\", _clickListener, {\n            once: true,\n        });\n    };\n    /**\n     * Establish the audio context for rive, this lets rive know that we can play audio.\n     */\n    AudioManager.prototype.establishAudio = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                this._establishAudio();\n                return [2 /*return*/];\n            });\n        });\n    };\n    Object.defineProperty(AudioManager.prototype, \"systemVolume\", {\n        get: function () {\n            if (this._status === SystemAudioStatus.UNAVAILABLE) {\n                // We do an immediate test to avoid depending on the delay of the running test\n                this.testAudio();\n                return 0;\n            }\n            return 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AudioManager.prototype, \"status\", {\n        get: function () {\n            return this._status;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return AudioManager;\n}(EventManager));\nvar audioManager = new AudioManager();\nvar FakeResizeObserver = /** @class */ (function () {\n    function FakeResizeObserver() {\n    }\n    FakeResizeObserver.prototype.observe = function () { };\n    FakeResizeObserver.prototype.unobserve = function () { };\n    FakeResizeObserver.prototype.disconnect = function () { };\n    return FakeResizeObserver;\n}());\nvar MyResizeObserver = globalThis.ResizeObserver || FakeResizeObserver;\n/**\n * This class takes care of any observers that will be attached to an animation.\n * It should be treated as a singleton because observers are much more performant\n * when used for observing multiple elements by a single instance.\n */\nvar ObjectObservers = /** @class */ (function () {\n    function ObjectObservers() {\n        var _this = this;\n        this._elementsMap = new Map();\n        /**\n         * Resize observers trigger both when the element changes its size and also when the\n         * element is added or removed from the document.\n         */\n        this._onObservedEntry = function (entry) {\n            var observed = _this._elementsMap.get(entry.target);\n            if (observed !== null) {\n                observed.onResize(entry.target.clientWidth == 0 || entry.target.clientHeight == 0);\n            }\n            else {\n                _this._resizeObserver.unobserve(entry.target);\n            }\n        };\n        this._onObserved = function (entries) {\n            entries.forEach(_this._onObservedEntry);\n        };\n        this._resizeObserver = new MyResizeObserver(this._onObserved);\n    }\n    // Adds an observable element\n    ObjectObservers.prototype.add = function (element, onResize) {\n        var observed = {\n            onResize: onResize,\n            element: element,\n        };\n        this._elementsMap.set(element, observed);\n        this._resizeObserver.observe(element);\n        return observed;\n    };\n    // Removes an observable element\n    ObjectObservers.prototype.remove = function (observed) {\n        this._resizeObserver.unobserve(observed.element);\n        this._elementsMap.delete(observed.element);\n    };\n    return ObjectObservers;\n}());\nvar observers = new ObjectObservers();\nvar RiveFile = /** @class */ (function () {\n    function RiveFile(params) {\n        // Allow the runtime to automatically load assets hosted in Rive's runtime.\n        this.enableRiveAssetCDN = true;\n        this.referenceCount = 0;\n        this.destroyed = false;\n        this.src = params.src;\n        this.buffer = params.buffer;\n        if (params.assetLoader)\n            this.assetLoader = params.assetLoader;\n        this.enableRiveAssetCDN =\n            typeof params.enableRiveAssetCDN == \"boolean\"\n                ? params.enableRiveAssetCDN\n                : true;\n        // New event management system\n        this.eventManager = new EventManager();\n        if (params.onLoad)\n            this.on(EventType.Load, params.onLoad);\n        if (params.onLoadError)\n            this.on(EventType.LoadError, params.onLoadError);\n    }\n    RiveFile.prototype.initData = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, loader, _b;\n            var _c;\n            return __generator(this, function (_d) {\n                switch (_d.label) {\n                    case 0:\n                        if (!this.src) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, loadRiveFile(this.src)];\n                    case 1:\n                        _a.buffer = _d.sent();\n                        _d.label = 2;\n                    case 2:\n                        if (this.destroyed) {\n                            return [2 /*return*/];\n                        }\n                        if (this.assetLoader) {\n                            loader = new this.runtime.CustomFileAssetLoader({\n                                loadContents: this.assetLoader,\n                            });\n                        }\n                        // Load the Rive file\n                        _b = this;\n                        return [4 /*yield*/, this.runtime.load(new Uint8Array(this.buffer), loader, this.enableRiveAssetCDN)];\n                    case 3:\n                        // Load the Rive file\n                        _b.file = _d.sent();\n                        if (this.destroyed) {\n                            (_c = this.file) === null || _c === void 0 ? void 0 : _c.delete();\n                            this.file = null;\n                            return [2 /*return*/];\n                        }\n                        if (this.file !== null) {\n                            this.eventManager.fire({\n                                type: EventType.Load,\n                                data: this,\n                            });\n                        }\n                        else {\n                            this.eventManager.fire({\n                                type: EventType.LoadError,\n                                data: null,\n                            });\n                            throw new Error(RiveFile.fileLoadErrorMessage);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    RiveFile.prototype.init = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        // If no source file url specified, it's a bust\n                        if (!this.src && !this.buffer) {\n                            throw new Error(RiveFile.missingErrorMessage);\n                        }\n                        _a = this;\n                        return [4 /*yield*/, RuntimeLoader.awaitInstance()];\n                    case 1:\n                        _a.runtime = _b.sent();\n                        if (this.destroyed) {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.initData()];\n                    case 2:\n                        _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Subscribe to Rive-generated events\n     * @param type the type of event to subscribe to\n     * @param callback callback to fire when the event occurs\n     */\n    RiveFile.prototype.on = function (type, callback) {\n        this.eventManager.add({\n            type: type,\n            callback: callback,\n        });\n    };\n    /**\n     * Unsubscribes from a Rive-generated event\n     * @param type the type of event to unsubscribe from\n     * @param callback the callback to unsubscribe\n     */\n    RiveFile.prototype.off = function (type, callback) {\n        this.eventManager.remove({\n            type: type,\n            callback: callback,\n        });\n    };\n    RiveFile.prototype.cleanup = function () {\n        var _a;\n        this.referenceCount -= 1;\n        if (this.referenceCount <= 0) {\n            this.removeAllRiveEventListeners();\n            (_a = this.file) === null || _a === void 0 ? void 0 : _a.delete();\n            this.file = null;\n            this.destroyed = true;\n        }\n    };\n    /**\n     * Unsubscribes all Rive listeners from an event type, or everything if no type is\n     * given\n     * @param type the type of event to unsubscribe from, or all types if\n     * undefined\n     */\n    RiveFile.prototype.removeAllRiveEventListeners = function (type) {\n        this.eventManager.removeAll(type);\n    };\n    RiveFile.prototype.getInstance = function () {\n        if (this.file !== null) {\n            this.referenceCount += 1;\n            return this.file;\n        }\n    };\n    // Error message for missing source or buffer\n    RiveFile.missingErrorMessage = \"Rive source file or data buffer required\";\n    // Error message for file load error\n    RiveFile.fileLoadErrorMessage = \"The file failed to load\";\n    return RiveFile;\n}());\n\nvar Rive = /** @class */ (function () {\n    function Rive(params) {\n        var _this = this;\n        var _a;\n        // Tracks if a Rive file is loaded\n        this.loaded = false;\n        // Tracks if a Rive file is destroyed\n        this.destroyed = false;\n        // Reference of an object that handles any observers for the animation\n        this._observed = null;\n        /**\n         * Tracks if a Rive file is loaded; we need this in addition to loaded as some\n         * commands (e.g. contents) can be called as soon as the file is loaded.\n         * However, playback commands need to be queued and run in order once initial\n         * animations and autoplay has been sorted out. This applies to play, pause,\n         * and start.\n         */\n        this.readyForPlaying = false;\n        // Runtime artboard\n        this.artboard = null;\n        // place to clear up event listeners\n        this.eventCleanup = null;\n        this.shouldDisableRiveListeners = false;\n        this.automaticallyHandleEvents = false;\n        // Allow the runtime to automatically load assets hosted in Rive's runtime.\n        this.enableRiveAssetCDN = true;\n        // Keep a local value of the set volume to update it asynchronously\n        this._volume = 1;\n        // Keep a local value of the set width to update it asynchronously\n        this._artboardWidth = undefined;\n        // Keep a local value of the set height to update it asynchronously\n        this._artboardHeight = undefined;\n        // Keep a local value of the device pixel ratio used in rendering and canvas/artboard resizing\n        this._devicePixelRatioUsed = 1;\n        // Whether the canvas element's size is 0\n        this._hasZeroSize = false;\n        // Audio event listener\n        this._audioEventListener = null;\n        // draw method bound to the class\n        this._boundDraw = null;\n        this._viewModelInstance = null;\n        this._dataEnums = null;\n        // Durations to generate a frame for the last second. Used for performance profiling.\n        this.durations = [];\n        this.frameTimes = [];\n        this.frameCount = 0;\n        this.isTouchScrollEnabled = false;\n        this.onCanvasResize = function (hasZeroSize) {\n            var toggledDisplay = _this._hasZeroSize !== hasZeroSize;\n            _this._hasZeroSize = hasZeroSize;\n            if (!hasZeroSize) {\n                if (toggledDisplay) {\n                    _this.resizeDrawingSurfaceToCanvas();\n                }\n            }\n            else if (!_this._layout.maxX || !_this._layout.maxY) {\n                _this.resizeToCanvas();\n            }\n        };\n        /**\n         * Used be draw to track when a second of active rendering time has passed.\n         * Used for debugging purposes\n         */\n        this.renderSecondTimer = 0;\n        this._boundDraw = this.draw.bind(this);\n        this.canvas = params.canvas;\n        if (params.canvas.constructor === HTMLCanvasElement) {\n            this._observed = observers.add(this.canvas, this.onCanvasResize);\n        }\n        this.src = params.src;\n        this.buffer = params.buffer;\n        this.riveFile = params.riveFile;\n        this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new Layout();\n        this.shouldDisableRiveListeners = !!params.shouldDisableRiveListeners;\n        this.isTouchScrollEnabled = !!params.isTouchScrollEnabled;\n        this.automaticallyHandleEvents = !!params.automaticallyHandleEvents;\n        this.enableRiveAssetCDN =\n            params.enableRiveAssetCDN === undefined\n                ? true\n                : params.enableRiveAssetCDN;\n        // New event management system\n        this.eventManager = new EventManager();\n        if (params.onLoad)\n            this.on(EventType.Load, params.onLoad);\n        if (params.onLoadError)\n            this.on(EventType.LoadError, params.onLoadError);\n        if (params.onPlay)\n            this.on(EventType.Play, params.onPlay);\n        if (params.onPause)\n            this.on(EventType.Pause, params.onPause);\n        if (params.onStop)\n            this.on(EventType.Stop, params.onStop);\n        if (params.onLoop)\n            this.on(EventType.Loop, params.onLoop);\n        if (params.onStateChange)\n            this.on(EventType.StateChange, params.onStateChange);\n        if (params.onAdvance)\n            this.on(EventType.Advance, params.onAdvance);\n        /**\n         * @deprecated Use camelCase'd versions instead.\n         */\n        if (params.onload && !params.onLoad)\n            this.on(EventType.Load, params.onload);\n        if (params.onloaderror && !params.onLoadError)\n            this.on(EventType.LoadError, params.onloaderror);\n        if (params.onplay && !params.onPlay)\n            this.on(EventType.Play, params.onplay);\n        if (params.onpause && !params.onPause)\n            this.on(EventType.Pause, params.onpause);\n        if (params.onstop && !params.onStop)\n            this.on(EventType.Stop, params.onstop);\n        if (params.onloop && !params.onLoop)\n            this.on(EventType.Loop, params.onloop);\n        if (params.onstatechange && !params.onStateChange)\n            this.on(EventType.StateChange, params.onstatechange);\n        /**\n         * Asset loading\n         */\n        if (params.assetLoader)\n            this.assetLoader = params.assetLoader;\n        // Hook up the task queue\n        this.taskQueue = new TaskQueueManager(this.eventManager);\n        this.init({\n            src: this.src,\n            buffer: this.buffer,\n            riveFile: this.riveFile,\n            autoplay: params.autoplay,\n            autoBind: params.autoBind,\n            animations: params.animations,\n            stateMachines: params.stateMachines,\n            artboard: params.artboard,\n            useOffscreenRenderer: params.useOffscreenRenderer,\n        });\n    }\n    // Alternative constructor to build a Rive instance from an interface/object\n    Rive.new = function (params) {\n        console.warn(\"This function is deprecated: please use `new Rive({})` instead\");\n        return new Rive(params);\n    };\n    // Event handler for when audio context becomes available\n    Rive.prototype.onSystemAudioChanged = function () {\n        this.volume = this._volume;\n    };\n    // Initializes the Rive object either from constructor or load()\n    Rive.prototype.init = function (_a) {\n        var _this = this;\n        var src = _a.src, buffer = _a.buffer, riveFile = _a.riveFile, animations = _a.animations, stateMachines = _a.stateMachines, artboard = _a.artboard, _b = _a.autoplay, autoplay = _b === void 0 ? false : _b, _c = _a.useOffscreenRenderer, useOffscreenRenderer = _c === void 0 ? false : _c, _d = _a.autoBind, autoBind = _d === void 0 ? false : _d;\n        if (this.destroyed) {\n            return;\n        }\n        this.src = src;\n        this.buffer = buffer;\n        this.riveFile = riveFile;\n        // If no source file url specified, it's a bust\n        if (!this.src && !this.buffer && !this.riveFile) {\n            throw new RiveError(Rive.missingErrorMessage);\n        }\n        // List of animations that should be initialized.\n        var startingAnimationNames = mapToStringArray(animations);\n        // List of state machines that should be initialized\n        var startingStateMachineNames = mapToStringArray(stateMachines);\n        // Ensure loaded is marked as false if loading new file\n        this.loaded = false;\n        this.readyForPlaying = false;\n        // Ensure the runtime is loaded\n        RuntimeLoader.awaitInstance()\n            .then(function (runtime) {\n            if (_this.destroyed) {\n                return;\n            }\n            _this.runtime = runtime;\n            _this.removeRiveListeners();\n            _this.deleteRiveRenderer();\n            // Get the canvas where you want to render the animation and create a renderer\n            _this.renderer = _this.runtime.makeRenderer(_this.canvas, useOffscreenRenderer);\n            // Initial size adjustment based on devicePixelRatio if no width/height are\n            // specified explicitly\n            if (!(_this.canvas.width || _this.canvas.height)) {\n                _this.resizeDrawingSurfaceToCanvas();\n            }\n            // Load Rive data from a source uri or a data buffer\n            _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay, autoBind)\n                .then(function () { return _this.setupRiveListeners(); })\n                .catch(function (e) {\n                console.error(e);\n            });\n        })\n            .catch(function (e) {\n            console.error(e);\n        });\n    };\n    /**\n     * Setup Rive Listeners on the canvas\n     * @param riveListenerOptions - Enables TouchEvent events on the canvas. Set to true to allow\n     * touch scrolling on the canvas element on touch-enabled devices\n     * i.e. { isTouchScrollEnabled: true }\n     */\n    Rive.prototype.setupRiveListeners = function (riveListenerOptions) {\n        var _this = this;\n        if (this.eventCleanup) {\n            this.eventCleanup();\n        }\n        if (!this.shouldDisableRiveListeners) {\n            var activeStateMachines = (this.animator.stateMachines || [])\n                .filter(function (sm) { return sm.playing && _this.runtime.hasListeners(sm.instance); })\n                .map(function (sm) { return sm.instance; });\n            var touchScrollEnabledOption = this.isTouchScrollEnabled;\n            if (riveListenerOptions &&\n                \"isTouchScrollEnabled\" in riveListenerOptions) {\n                touchScrollEnabledOption = riveListenerOptions.isTouchScrollEnabled;\n            }\n            this.eventCleanup = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.registerTouchInteractions)({\n                canvas: this.canvas,\n                artboard: this.artboard,\n                stateMachines: activeStateMachines,\n                renderer: this.renderer,\n                rive: this.runtime,\n                fit: this._layout.runtimeFit(this.runtime),\n                alignment: this._layout.runtimeAlignment(this.runtime),\n                isTouchScrollEnabled: touchScrollEnabledOption,\n                layoutScaleFactor: this._layout.layoutScaleFactor,\n            });\n        }\n    };\n    /**\n     * Remove Rive Listeners setup on the canvas\n     */\n    Rive.prototype.removeRiveListeners = function () {\n        if (this.eventCleanup) {\n            this.eventCleanup();\n            this.eventCleanup = null;\n        }\n    };\n    /**\n     * If the instance has audio and the system audio is not ready\n     * we hook the instance to the audio manager\n     */\n    Rive.prototype.initializeAudio = function () {\n        var _this = this;\n        var _a;\n        // Initialize audio if needed\n        if (audioManager.status == SystemAudioStatus.UNAVAILABLE) {\n            if (((_a = this.artboard) === null || _a === void 0 ? void 0 : _a.hasAudio) && this._audioEventListener === null) {\n                this._audioEventListener = {\n                    type: EventType.AudioStatusChange,\n                    callback: function () { return _this.onSystemAudioChanged(); },\n                };\n                audioManager.add(this._audioEventListener);\n                audioManager.establishAudio();\n            }\n        }\n    };\n    Rive.prototype.initArtboardSize = function () {\n        if (!this.artboard)\n            return;\n        // Use preset values if they are not undefined\n        this._artboardWidth = this.artboard.width =\n            this._artboardWidth || this.artboard.width;\n        this._artboardHeight = this.artboard.height =\n            this._artboardHeight || this.artboard.height;\n    };\n    // Initializes runtime with Rive data and preps for playing\n    Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay, autoBind) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_1, msg;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 3, , 4]);\n                        if (!(this.riveFile == null)) return [3 /*break*/, 2];\n                        this.riveFile = new RiveFile({\n                            src: this.src,\n                            buffer: this.buffer,\n                            enableRiveAssetCDN: this.enableRiveAssetCDN,\n                            assetLoader: this.assetLoader,\n                        });\n                        return [4 /*yield*/, this.riveFile.init()];\n                    case 1:\n                        _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        // Check for riveFile in case it has been cleaned up while initializing;\n                        if (!this.riveFile) {\n                            throw new RiveError(Rive.cleanupErrorMessage);\n                        }\n                        this.file = this.riveFile.getInstance();\n                        // Initialize and draw frame\n                        this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay, autoBind);\n                        // Initialize the artboard size\n                        this.initArtboardSize();\n                        // Check for audio\n                        this.initializeAudio();\n                        // Everything's set up, emit a load event\n                        this.loaded = true;\n                        this.eventManager.fire({\n                            type: EventType.Load,\n                            data: (_a = this.src) !== null && _a !== void 0 ? _a : \"buffer\",\n                        });\n                        // Flag ready for playback commands and clear the task queue; this order\n                        // is important or it may infinitely recurse\n                        this.readyForPlaying = true;\n                        this.taskQueue.process();\n                        this.drawFrame();\n                        return [2 /*return*/, Promise.resolve()];\n                    case 3:\n                        error_1 = _b.sent();\n                        msg = resolveErrorMessage(error_1);\n                        console.warn(msg);\n                        this.eventManager.fire({ type: EventType.LoadError, data: msg });\n                        return [2 /*return*/, Promise.reject(msg)];\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    // Initialize for playback\n    Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay, autoBind) {\n        if (!this.file) {\n            return;\n        }\n        // Fetch the artboard\n        var rootArtboard = artboardName\n            ? this.file.artboardByName(artboardName)\n            : this.file.defaultArtboard();\n        // Check we have a working artboard\n        if (!rootArtboard) {\n            var msg = \"Invalid artboard name or no default artboard\";\n            console.warn(msg);\n            this.eventManager.fire({ type: EventType.LoadError, data: msg });\n            return;\n        }\n        this.artboard = rootArtboard;\n        rootArtboard.volume = this._volume * audioManager.systemVolume;\n        // Check that the artboard has at least 1 animation\n        if (this.artboard.animationCount() < 1) {\n            var msg = \"Artboard has no animations\";\n            this.eventManager.fire({ type: EventType.LoadError, data: msg });\n            throw msg;\n        }\n        // Initialize the animator\n        this.animator = new Animator(this.runtime, this.artboard, this.eventManager);\n        // Initialize the animations; as loaded hasn't happened yet, we need to\n        // suppress firing the play/pause events until the load event has fired. To\n        // do this we tell the animator to suppress firing events, and add event\n        // firing to the task queue.\n        var instanceNames;\n        if (animationNames.length > 0 || stateMachineNames.length > 0) {\n            instanceNames = animationNames.concat(stateMachineNames);\n            this.animator.initLinearAnimations(animationNames, autoplay);\n            this.animator.initStateMachines(stateMachineNames, autoplay);\n        }\n        else {\n            instanceNames = [this.animator.atLeastOne(autoplay, false)];\n        }\n        // Queue up firing the playback events\n        this.taskQueue.add({\n            event: {\n                type: autoplay ? EventType.Play : EventType.Pause,\n                data: instanceNames,\n            },\n        });\n        if (autoBind) {\n            var viewModel = this.file.defaultArtboardViewModel(rootArtboard);\n            if (viewModel !== null) {\n                var runtimeInstance = viewModel.defaultInstance();\n                if (runtimeInstance !== null) {\n                    var viewModelInstance = new ViewModelInstance(runtimeInstance, null);\n                    this.bindViewModelInstance(viewModelInstance);\n                }\n            }\n        }\n    };\n    // Draws the current artboard frame\n    Rive.prototype.drawFrame = function () {\n        var _a, _b;\n        if ((_a = document === null || document === void 0 ? void 0 : document.timeline) === null || _a === void 0 ? void 0 : _a.currentTime) {\n            if (this.loaded && this.artboard && !this.frameRequestId) {\n                this._boundDraw(document.timeline.currentTime);\n                (_b = this.runtime) === null || _b === void 0 ? void 0 : _b.resolveAnimationFrame();\n            }\n        }\n        else {\n            this.startRendering();\n        }\n    };\n    /**\n     * Draw rendering loop; renders animation frames at the correct time interval.\n     * @param time the time at which to render a frame\n     */\n    Rive.prototype.draw = function (time, onSecond) {\n        var _a;\n        // Clear the frameRequestId, as we're now rendering a fresh frame\n        this.frameRequestId = null;\n        var before = performance.now();\n        // On the first pass, make sure lastTime has a valid value\n        if (!this.lastRenderTime) {\n            this.lastRenderTime = time;\n        }\n        // Handle the onSecond callback\n        this.renderSecondTimer += time - this.lastRenderTime;\n        if (this.renderSecondTimer > 5000) {\n            this.renderSecondTimer = 0;\n            onSecond === null || onSecond === void 0 ? void 0 : onSecond();\n        }\n        // Calculate the elapsed time between frames in seconds\n        var elapsedTime = (time - this.lastRenderTime) / 1000;\n        this.lastRenderTime = time;\n        // - Advance non-paused animations by the elapsed number of seconds\n        // - Advance any animations that require scrubbing\n        // - Advance to the first frame even when autoplay is false\n        var activeAnimations = this.animator.animations\n            .filter(function (a) { return a.playing || a.needsScrub; })\n            // The scrubbed animations must be applied first to prevent weird artifacts\n            // if the playing animations conflict with the scrubbed animating attribuates.\n            .sort(function (first) { return (first.needsScrub ? -1 : 1); });\n        for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {\n            var animation = activeAnimations_1[_i];\n            animation.advance(elapsedTime);\n            if (animation.instance.didLoop) {\n                animation.loopCount += 1;\n            }\n            animation.apply(1.0);\n        }\n        // - Advance non-paused state machines by the elapsed number of seconds\n        // - Advance to the first frame even when autoplay is false\n        var activeStateMachines = this.animator.stateMachines.filter(function (a) { return a.playing; });\n        for (var _b = 0, activeStateMachines_1 = activeStateMachines; _b < activeStateMachines_1.length; _b++) {\n            var stateMachine = activeStateMachines_1[_b];\n            // Check for events before the current frame's state machine advance\n            var numEventsReported = stateMachine.reportedEventCount();\n            if (numEventsReported) {\n                for (var i = 0; i < numEventsReported; i++) {\n                    var event_1 = stateMachine.reportedEventAt(i);\n                    if (event_1) {\n                        if (event_1.type === RiveEventType.OpenUrl) {\n                            this.eventManager.fire({\n                                type: EventType.RiveEvent,\n                                data: event_1,\n                            });\n                            // Handle the event side effect if explicitly enabled\n                            if (this.automaticallyHandleEvents) {\n                                var newAnchorTag = document.createElement(\"a\");\n                                var _c = event_1, url = _c.url, target = _c.target;\n                                var sanitizedUrl = (0,_utils__WEBPACK_IMPORTED_MODULE_3__.sanitizeUrl)(url);\n                                url && newAnchorTag.setAttribute(\"href\", sanitizedUrl);\n                                target && newAnchorTag.setAttribute(\"target\", target);\n                                if (sanitizedUrl && sanitizedUrl !== _utils__WEBPACK_IMPORTED_MODULE_3__.BLANK_URL) {\n                                    newAnchorTag.click();\n                                }\n                            }\n                        }\n                        else {\n                            this.eventManager.fire({\n                                type: EventType.RiveEvent,\n                                data: event_1,\n                            });\n                        }\n                    }\n                }\n            }\n            stateMachine.advanceAndApply(elapsedTime);\n            // stateMachine.instance.apply(this.artboard);\n        }\n        // Once the animations have been applied to the artboard, advance it\n        // by the elapsed time.\n        if (this.animator.stateMachines.length == 0) {\n            this.artboard.advance(elapsedTime);\n        }\n        var renderer = this.renderer;\n        // Canvas must be wiped to prevent artifacts\n        renderer.clear();\n        renderer.save();\n        // Update the renderer alignment if necessary\n        this.alignRenderer();\n        // Do not draw on 0 canvas size\n        if (!this._hasZeroSize) {\n            this.artboard.draw(renderer);\n        }\n        renderer.restore();\n        renderer.flush();\n        // Check for any animations that looped\n        this.animator.handleLooping();\n        // Check for any state machines that had a state change\n        this.animator.handleStateChanges();\n        // Report advanced time\n        this.animator.handleAdvancing(elapsedTime);\n        // Add duration to create frame to durations array\n        this.frameCount++;\n        var after = performance.now();\n        this.frameTimes.push(after);\n        this.durations.push(after - before);\n        while (this.frameTimes[0] <= after - 1000) {\n            this.frameTimes.shift();\n            this.durations.shift();\n        }\n        (_a = this._viewModelInstance) === null || _a === void 0 ? void 0 : _a.handleCallbacks();\n        // Calling requestAnimationFrame will rerun draw() at the correct rate:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations\n        if (this.animator.isPlaying) {\n            // Request a new rendering frame\n            this.startRendering();\n        }\n        else if (this.animator.isPaused) {\n            // Reset the end time so on playback it starts at the correct frame\n            this.lastRenderTime = 0;\n        }\n        else if (this.animator.isStopped) {\n            // Reset animation instances, artboard and time\n            // TODO: implement this properly when we have instancing\n            // this.initArtboard();\n            // this.drawFrame();\n            this.lastRenderTime = 0;\n        }\n    };\n    /**\n     * Align the renderer\n     */\n    Rive.prototype.alignRenderer = function () {\n        var _a = this, renderer = _a.renderer, runtime = _a.runtime, _layout = _a._layout, artboard = _a.artboard;\n        // Align things up safe in the knowledge we can restore if changed\n        renderer.align(_layout.runtimeFit(runtime), _layout.runtimeAlignment(runtime), {\n            minX: _layout.minX,\n            minY: _layout.minY,\n            maxX: _layout.maxX,\n            maxY: _layout.maxY,\n        }, artboard.bounds, this._devicePixelRatioUsed * _layout.layoutScaleFactor);\n    };\n    Object.defineProperty(Rive.prototype, \"fps\", {\n        get: function () {\n            return this.durations.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"frameTime\", {\n        get: function () {\n            if (this.durations.length === 0) {\n                return 0;\n            }\n            return (this.durations.reduce(function (a, b) { return a + b; }, 0) / this.durations.length).toFixed(4);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Cleans up all Wasm-generated objects that need to be manually destroyed:\n     * artboard instances, animation instances, state machine instances,\n     * renderer instance, file and runtime.\n     *\n     * Once this is called, you will need to initialise a new instance of the\n     * Rive class\n     */\n    Rive.prototype.cleanup = function () {\n        var _a, _b;\n        this.destroyed = true;\n        // Stop the renderer if it hasn't already been stopped.\n        this.stopRendering();\n        // Clean up any artboard, animation or state machine instances.\n        this.cleanupInstances();\n        // Remove from observer\n        if (this._observed !== null) {\n            observers.remove(this._observed);\n        }\n        this.removeRiveListeners();\n        if (this.file) {\n            (_a = this.riveFile) === null || _a === void 0 ? void 0 : _a.cleanup();\n            this.file = null;\n        }\n        this.riveFile = null;\n        this.deleteRiveRenderer();\n        if (this._audioEventListener !== null) {\n            audioManager.remove(this._audioEventListener);\n            this._audioEventListener = null;\n        }\n        (_b = this._viewModelInstance) === null || _b === void 0 ? void 0 : _b.cleanup();\n        this._viewModelInstance = null;\n        this._dataEnums = null;\n    };\n    /**\n     * Cleans up the Renderer object. Only call this API if you no longer\n     * need to render Rive content in your session.\n     */\n    Rive.prototype.deleteRiveRenderer = function () {\n        var _a;\n        (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.delete();\n        this.renderer = null;\n    };\n    /**\n     * Cleans up any Wasm-generated objects that need to be manually destroyed:\n     * artboard instances, animation instances, state machine instances.\n     *\n     * Once this is called, things will need to be reinitialized or bad things\n     * might happen.\n     */\n    Rive.prototype.cleanupInstances = function () {\n        if (this.eventCleanup !== null) {\n            this.eventCleanup();\n        }\n        // Delete all animation and state machine instances\n        this.stop();\n        if (this.artboard) {\n            this.artboard.delete();\n            this.artboard = null;\n        }\n    };\n    /**\n     * Tries to query the setup Artboard for a text run node with the given name.\n     *\n     * @param textRunName - Name of the text run node associated with a text object\n     * @returns - TextValueRun node or undefined if the text run cannot be queried\n     */\n    Rive.prototype.retrieveTextRun = function (textRunName) {\n        var _a;\n        if (!textRunName) {\n            console.warn(\"No text run name provided\");\n            return;\n        }\n        if (!this.artboard) {\n            console.warn(\"Tried to access text run, but the Artboard is null\");\n            return;\n        }\n        var textRun = this.artboard.textRun(textRunName);\n        if (!textRun) {\n            console.warn(\"Could not access a text run with name '\".concat(textRunName, \"' in the '\").concat((_a = this.artboard) === null || _a === void 0 ? void 0 : _a.name, \"' Artboard. Note that you must rename a text run node in the Rive editor to make it queryable at runtime.\"));\n            return;\n        }\n        return textRun;\n    };\n    /**\n     * Returns a string from a given text run node name, or undefined if the text run\n     * cannot be queried.\n     *\n     * @param textRunName - Name of the text run node associated with a text object\n     * @returns - String value of the text run node or undefined\n     */\n    Rive.prototype.getTextRunValue = function (textRunName) {\n        var textRun = this.retrieveTextRun(textRunName);\n        return textRun ? textRun.text : undefined;\n    };\n    /**\n     * Sets a text value for a given text run node name if possible\n     *\n     * @param textRunName - Name of the text run node associated with a text object\n     * @param textRunValue - String value to set on the text run node\n     */\n    Rive.prototype.setTextRunValue = function (textRunName, textRunValue) {\n        var textRun = this.retrieveTextRun(textRunName);\n        if (textRun) {\n            textRun.text = textRunValue;\n        }\n    };\n    // Plays specified animations; if none specified, it unpauses everything.\n    Rive.prototype.play = function (animationNames, autoplay) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, queue up the play\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.play(animationNames, autoplay); },\n            });\n            return;\n        }\n        this.animator.play(animationNames);\n        if (this.eventCleanup) {\n            this.eventCleanup();\n        }\n        this.setupRiveListeners();\n        this.startRendering();\n    };\n    // Pauses specified animations; if none specified, pauses all.\n    Rive.prototype.pause = function (animationNames) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.pause(animationNames); },\n            });\n            return;\n        }\n        if (this.eventCleanup) {\n            this.eventCleanup();\n        }\n        this.animator.pause(animationNames);\n    };\n    Rive.prototype.scrub = function (animationNames, value) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.scrub(animationNames, value); },\n            });\n            return;\n        }\n        // Scrub the animation time; we draw a single frame here so that if\n        // nothing's currently playing, the scrubbed animation is still rendered/\n        this.animator.scrub(animationNames, value || 0);\n        this.drawFrame();\n    };\n    // Stops specified animations; if none specifies, stops them all.\n    Rive.prototype.stop = function (animationNames) {\n        var _this = this;\n        animationNames = mapToStringArray(animationNames);\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.readyForPlaying) {\n            this.taskQueue.add({\n                action: function () { return _this.stop(animationNames); },\n            });\n            return;\n        }\n        // If there is no artboard, this.animator will be undefined\n        if (this.animator) {\n            this.animator.stop(animationNames);\n        }\n        if (this.eventCleanup) {\n            this.eventCleanup();\n        }\n    };\n    /**\n     * Resets the animation\n     * @param artboard the name of the artboard, or default if none given\n     * @param animations the names of animations for playback\n     * @param stateMachines the names of state machines for playback\n     * @param autoplay whether to autoplay when reset, defaults to false\n     *\n     */\n    Rive.prototype.reset = function (params) {\n        var _a, _b;\n        // Get the current artboard, animations, state machines, and playback states\n        var artBoardName = params === null || params === void 0 ? void 0 : params.artboard;\n        var animationNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.animations);\n        var stateMachineNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.stateMachines);\n        var autoplay = (_a = params === null || params === void 0 ? void 0 : params.autoplay) !== null && _a !== void 0 ? _a : false;\n        var autoBind = (_b = params === null || params === void 0 ? void 0 : params.autoBind) !== null && _b !== void 0 ? _b : false;\n        // Stop everything and clean up\n        this.cleanupInstances();\n        // Reinitialize an artboard instance with the state\n        this.initArtboard(artBoardName, animationNames, stateMachineNames, autoplay, autoBind);\n        this.taskQueue.process();\n    };\n    // Loads a new Rive file, keeping listeners in place\n    Rive.prototype.load = function (params) {\n        this.file = null;\n        // Stop all animations\n        this.stop();\n        // Reinitialize\n        this.init(params);\n    };\n    Object.defineProperty(Rive.prototype, \"layout\", {\n        /**\n         * Returns the current layout. Note that layout should be treated as\n         * immutable. If you want to change the layout, create a new one use the\n         * layout setter\n         */\n        get: function () {\n            return this._layout;\n        },\n        // Sets a new layout\n        set: function (layout) {\n            this._layout = layout;\n            // If the maxX or maxY are 0, then set them to the canvas width and height\n            if (!layout.maxX || !layout.maxY) {\n                this.resizeToCanvas();\n            }\n            if (this.loaded && !this.animator.isPlaying) {\n                this.drawFrame();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Sets the layout bounds to the current canvas size; this is typically called\n     * when the canvas is resized\n     */\n    Rive.prototype.resizeToCanvas = function () {\n        this._layout = this.layout.copyWith({\n            minX: 0,\n            minY: 0,\n            maxX: this.canvas.width,\n            maxY: this.canvas.height,\n        });\n    };\n    /**\n     * Accounts for devicePixelRatio as a multiplier to render the size of the canvas drawing surface.\n     * Uses the size of the backing canvas to set new width/height attributes. Need to re-render\n     * and resize the layout to match the new drawing surface afterwards.\n     * Useful function for consumers to include in a window resize listener.\n     *\n     * This method will set the {@link devicePixelRatioUsed} property.\n     *\n     * Optionally, you can provide a {@link customDevicePixelRatio} to provide a\n     * custom value.\n     */\n    Rive.prototype.resizeDrawingSurfaceToCanvas = function (customDevicePixelRatio) {\n        if (this.canvas instanceof HTMLCanvasElement && !!window) {\n            var _a = this.canvas.getBoundingClientRect(), width = _a.width, height = _a.height;\n            var dpr = customDevicePixelRatio || window.devicePixelRatio || 1;\n            this.devicePixelRatioUsed = dpr;\n            this.canvas.width = dpr * width;\n            this.canvas.height = dpr * height;\n            this.resizeToCanvas();\n            this.drawFrame();\n            if (this.layout.fit === Fit.Layout) {\n                var scaleFactor = this._layout.layoutScaleFactor;\n                this.artboard.width = width / scaleFactor;\n                this.artboard.height = height / scaleFactor;\n            }\n        }\n    };\n    Object.defineProperty(Rive.prototype, \"source\", {\n        // Returns the animation source, which may be undefined\n        get: function () {\n            return this.src;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"activeArtboard\", {\n        /**\n         * Returns the name of the active artboard\n         */\n        get: function () {\n            return this.artboard ? this.artboard.name : \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"animationNames\", {\n        // Returns a list of animation names on the chosen artboard\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded || !this.artboard) {\n                return [];\n            }\n            var animationNames = [];\n            for (var i = 0; i < this.artboard.animationCount(); i++) {\n                animationNames.push(this.artboard.animationByIndex(i).name);\n            }\n            return animationNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"stateMachineNames\", {\n        /**\n         * Returns a list of state machine names from the current artboard\n         */\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded || !this.artboard) {\n                return [];\n            }\n            var stateMachineNames = [];\n            for (var i = 0; i < this.artboard.stateMachineCount(); i++) {\n                stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);\n            }\n            return stateMachineNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns the inputs for the specified instanced state machine, or an empty\n     * list if the name is invalid or the state machine is not instanced\n     * @param name the state machine name\n     * @returns the inputs for the named state machine\n     */\n    Rive.prototype.stateMachineInputs = function (name) {\n        // If the file's not loaded, early out, nothing to pause\n        if (!this.loaded) {\n            return;\n        }\n        var stateMachine = this.animator.stateMachines.find(function (m) { return m.name === name; });\n        return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;\n    };\n    // Returns the input with the provided name at the given path\n    Rive.prototype.retrieveInputAtPath = function (name, path) {\n        if (!name) {\n            console.warn(\"No input name provided for path '\".concat(path, \"'\"));\n            return;\n        }\n        if (!this.artboard) {\n            console.warn(\"Tried to access input: '\".concat(name, \"', at path: '\").concat(path, \"', but the Artboard is null\"));\n            return;\n        }\n        var input = this.artboard.inputByPath(name, path);\n        if (!input) {\n            console.warn(\"Could not access an input with name: '\".concat(name, \"', at path:'\").concat(path, \"'\"));\n            return;\n        }\n        return input;\n    };\n    /**\n     * Set the boolean input with the provided name at the given path with value\n     * @param input the state machine input name\n     * @param value the value to set the input to\n     * @param path the path the input is located at an artboard level\n     */\n    Rive.prototype.setBooleanStateAtPath = function (inputName, value, path) {\n        var input = this.retrieveInputAtPath(inputName, path);\n        if (!input)\n            return;\n        if (input.type === StateMachineInputType.Boolean) {\n            input.asBool().value = value;\n        }\n        else {\n            console.warn(\"Input with name: '\".concat(inputName, \"', at path:'\").concat(path, \"' is not a boolean\"));\n        }\n    };\n    /**\n     * Set the number input with the provided name at the given path with value\n     * @param input the state machine input name\n     * @param value the value to set the input to\n     * @param path the path the input is located at an artboard level\n     */\n    Rive.prototype.setNumberStateAtPath = function (inputName, value, path) {\n        var input = this.retrieveInputAtPath(inputName, path);\n        if (!input)\n            return;\n        if (input.type === StateMachineInputType.Number) {\n            input.asNumber().value = value;\n        }\n        else {\n            console.warn(\"Input with name: '\".concat(inputName, \"', at path:'\").concat(path, \"' is not a number\"));\n        }\n    };\n    /**\n     * Fire the trigger with the provided name at the given path\n     * @param input the state machine input name\n     * @param path the path the input is located at an artboard level\n     */\n    Rive.prototype.fireStateAtPath = function (inputName, path) {\n        var input = this.retrieveInputAtPath(inputName, path);\n        if (!input)\n            return;\n        if (input.type === StateMachineInputType.Trigger) {\n            input.asTrigger().fire();\n        }\n        else {\n            console.warn(\"Input with name: '\".concat(inputName, \"', at path:'\").concat(path, \"' is not a trigger\"));\n        }\n    };\n    // Returns the TextValueRun object for the provided name at the given path\n    Rive.prototype.retrieveTextAtPath = function (name, path) {\n        if (!name) {\n            console.warn(\"No text name provided for path '\".concat(path, \"'\"));\n            return;\n        }\n        if (!path) {\n            console.warn(\"No path provided for text '\".concat(name, \"'\"));\n            return;\n        }\n        if (!this.artboard) {\n            console.warn(\"Tried to access text: '\".concat(name, \"', at path: '\").concat(path, \"', but the Artboard is null\"));\n            return;\n        }\n        var text = this.artboard.textByPath(name, path);\n        if (!text) {\n            console.warn(\"Could not access text with name: '\".concat(name, \"', at path:'\").concat(path, \"'\"));\n            return;\n        }\n        return text;\n    };\n    /**\n     * Retrieves the text value for a specified text run at a given path\n     * @param textName The name of the text run\n     * @param path The path to the text run within the artboard\n     * @returns The text value of the text run, or undefined if not found\n     *\n     * @example\n     * // Get the text value for a text run named \"title\" at one nested artboard deep\n     * const titleText = riveInstance.getTextRunValueAtPath(\"title\", \"artboard1\");\n     *\n     * @example\n     * // Get the text value for a text run named \"subtitle\" within a nested group two artboards deep\n     * const subtitleText = riveInstance.getTextRunValueAtPath(\"subtitle\", \"group/nestedGroup\");\n     *\n     * @remarks\n     * If the text run cannot be found at the specified path, a warning will be logged to the console.\n     */\n    Rive.prototype.getTextRunValueAtPath = function (textName, path) {\n        var run = this.retrieveTextAtPath(textName, path);\n        if (!run) {\n            console.warn(\"Could not get text with name: '\".concat(textName, \"', at path:'\").concat(path, \"'\"));\n            return;\n        }\n        return run.text;\n    };\n    /**\n     * Sets the text value for a specified text run at a given path\n     * @param textName The name of the text run\n     * @param value The new text value to set\n     * @param path The path to the text run within the artboard\n     * @returns void\n     *\n     * @example\n     * // Set the text value for a text run named \"title\" at one nested artboard deep\n     * riveInstance.setTextRunValueAtPath(\"title\", \"New Title\", \"artboard1\");\n     *\n     * @example\n     * // Set the text value for a text run named \"subtitle\" within a nested group two artboards deep\n     * riveInstance.setTextRunValueAtPath(\"subtitle\", \"New Subtitle\", \"group/nestedGroup\");\n     *\n     * @remarks\n     * If the text run cannot be found at the specified path, a warning will be logged to the console.\n     */\n    Rive.prototype.setTextRunValueAtPath = function (textName, value, path) {\n        var run = this.retrieveTextAtPath(textName, path);\n        if (!run) {\n            console.warn(\"Could not set text with name: '\".concat(textName, \"', at path:'\").concat(path, \"'\"));\n            return;\n        }\n        run.text = value;\n    };\n    Object.defineProperty(Rive.prototype, \"playingStateMachineNames\", {\n        // Returns a list of playing machine names\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.stateMachines\n                .filter(function (m) { return m.playing; })\n                .map(function (m) { return m.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"playingAnimationNames\", {\n        // Returns a list of playing animation names\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.animations.filter(function (a) { return a.playing; }).map(function (a) { return a.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"pausedAnimationNames\", {\n        // Returns a list of paused animation names\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.animations\n                .filter(function (a) { return !a.playing; })\n                .map(function (a) { return a.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"pausedStateMachineNames\", {\n        /**\n         *  Returns a list of paused machine names\n         * @returns a list of state machine names that are paused\n         */\n        get: function () {\n            // If the file's not loaded, we got nothing to return\n            if (!this.loaded) {\n                return [];\n            }\n            return this.animator.stateMachines\n                .filter(function (m) { return !m.playing; })\n                .map(function (m) { return m.name; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"isPlaying\", {\n        /**\n         * @returns true if any animation is playing\n         */\n        get: function () {\n            return this.animator.isPlaying;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"isPaused\", {\n        /**\n         * @returns true if all instanced animations are paused\n         */\n        get: function () {\n            return this.animator.isPaused;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"isStopped\", {\n        /**\n         * @returns true if no animations are playing or paused\n         */\n        get: function () {\n            return this.animator.isStopped;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"bounds\", {\n        /**\n         * @returns the bounds of the current artboard, or undefined if the artboard\n         * isn't loaded yet.\n         */\n        get: function () {\n            return this.artboard ? this.artboard.bounds : undefined;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Subscribe to Rive-generated events\n     * @param type the type of event to subscribe to\n     * @param callback callback to fire when the event occurs\n     */\n    Rive.prototype.on = function (type, callback) {\n        this.eventManager.add({\n            type: type,\n            callback: callback,\n        });\n    };\n    /**\n     * Unsubscribes from a Rive-generated event\n     * @param type the type of event to unsubscribe from\n     * @param callback the callback to unsubscribe\n     */\n    Rive.prototype.off = function (type, callback) {\n        this.eventManager.remove({\n            type: type,\n            callback: callback,\n        });\n    };\n    /**\n     * Unsubscribes from a Rive-generated event\n     * @deprecated\n     * @param callback the callback to unsubscribe from\n     */\n    Rive.prototype.unsubscribe = function (type, callback) {\n        console.warn(\"This function is deprecated: please use `off()` instead.\");\n        this.off(type, callback);\n    };\n    /**\n     * Unsubscribes all Rive listeners from an event type, or everything if no type is\n     * given\n     * @param type the type of event to unsubscribe from, or all types if\n     * undefined\n     */\n    Rive.prototype.removeAllRiveEventListeners = function (type) {\n        this.eventManager.removeAll(type);\n    };\n    /**\n     * Unsubscribes all listeners from an event type, or everything if no type is\n     * given\n     * @deprecated\n     * @param type the type of event to unsubscribe from, or all types if\n     * undefined\n     */\n    Rive.prototype.unsubscribeAll = function (type) {\n        console.warn(\"This function is deprecated: please use `removeAllRiveEventListeners()` instead.\");\n        this.removeAllRiveEventListeners(type);\n    };\n    /**\n     * Stops the rendering loop; this is different from pausing in that it doesn't\n     * change the state of any animation. It stops rendering from occurring. This\n     * is designed for situations such as when Rive isn't visible.\n     *\n     * The only way to start rendering again is to call `startRendering`.\n     * Animations that are marked as playing will start from the position that\n     * they would have been at if rendering had not been stopped.\n     */\n    Rive.prototype.stopRendering = function () {\n        if (this.loaded && this.frameRequestId) {\n            if (this.runtime.cancelAnimationFrame) {\n                this.runtime.cancelAnimationFrame(this.frameRequestId);\n            }\n            else {\n                cancelAnimationFrame(this.frameRequestId);\n            }\n            this.frameRequestId = null;\n        }\n    };\n    /**\n     * Starts the rendering loop if it has been previously stopped. If the\n     * renderer is already active, then this will have zero effect.\n     */\n    Rive.prototype.startRendering = function () {\n        if (this.loaded && this.artboard && !this.frameRequestId) {\n            if (this.runtime.requestAnimationFrame) {\n                this.frameRequestId = this.runtime.requestAnimationFrame(this._boundDraw);\n            }\n            else {\n                this.frameRequestId = requestAnimationFrame(this._boundDraw);\n            }\n        }\n    };\n    /**\n     * Enables frames-per-second (FPS) reporting for the runtime\n     * If no callback is provided, Rive will append a fixed-position div at the top-right corner of\n     * the page with the FPS reading\n     * @param fpsCallback - Callback from the runtime during the RAF loop that supplies the FPS value\n     */\n    Rive.prototype.enableFPSCounter = function (fpsCallback) {\n        this.runtime.enableFPSCounter(fpsCallback);\n    };\n    /**\n     * Disables frames-per-second (FPS) reporting for the runtime\n     */\n    Rive.prototype.disableFPSCounter = function () {\n        this.runtime.disableFPSCounter();\n    };\n    Object.defineProperty(Rive.prototype, \"contents\", {\n        /**\n         * Returns the contents of a Rive file: the artboards, animations, and state machines\n         */\n        get: function () {\n            if (!this.loaded) {\n                return undefined;\n            }\n            var riveContents = {\n                artboards: [],\n            };\n            for (var i = 0; i < this.file.artboardCount(); i++) {\n                var artboard = this.file.artboardByIndex(i);\n                var artboardContents = {\n                    name: artboard.name,\n                    animations: [],\n                    stateMachines: [],\n                };\n                for (var j = 0; j < artboard.animationCount(); j++) {\n                    var animation = artboard.animationByIndex(j);\n                    artboardContents.animations.push(animation.name);\n                }\n                for (var k = 0; k < artboard.stateMachineCount(); k++) {\n                    var stateMachine = artboard.stateMachineByIndex(k);\n                    var name_1 = stateMachine.name;\n                    var instance = new this.runtime.StateMachineInstance(stateMachine, artboard);\n                    var inputContents = [];\n                    for (var l = 0; l < instance.inputCount(); l++) {\n                        var input = instance.input(l);\n                        inputContents.push({ name: input.name, type: input.type });\n                    }\n                    artboardContents.stateMachines.push({\n                        name: name_1,\n                        inputs: inputContents,\n                    });\n                }\n                riveContents.artboards.push(artboardContents);\n            }\n            return riveContents;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"volume\", {\n        /**\n         * Getter / Setter for the volume of the artboard\n         */\n        get: function () {\n            if (this.artboard && this.artboard.volume !== this._volume) {\n                this._volume = this.artboard.volume;\n            }\n            return this._volume;\n        },\n        set: function (value) {\n            this._volume = value;\n            if (this.artboard) {\n                this.artboard.volume = value * audioManager.systemVolume;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"artboardWidth\", {\n        /**\n         * The width of the artboard.\n         *\n         * This will return 0 if the artboard is not loaded yet and a custom\n         * width has not been set.\n         *\n         * Do not set this value manually when using {@link resizeDrawingSurfaceToCanvas}\n         * with a {@link Layout.fit} of {@link Fit.Layout}, as the artboard width is\n         * automatically set.\n         */\n        get: function () {\n            var _a;\n            if (this.artboard) {\n                return this.artboard.width;\n            }\n            return (_a = this._artboardWidth) !== null && _a !== void 0 ? _a : 0;\n        },\n        set: function (value) {\n            this._artboardWidth = value;\n            if (this.artboard) {\n                this.artboard.width = value;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Rive.prototype, \"artboardHeight\", {\n        /**\n         * The height of the artboard.\n         *\n         * This will return 0 if the artboard is not loaded yet and a custom\n         * height has not been set.\n         *\n         * Do not set this value manually when using {@link resizeDrawingSurfaceToCanvas}\n         * with a {@link Layout.fit} of {@link Fit.Layout}, as the artboard height is\n         * automatically set.\n         */\n        get: function () {\n            var _a;\n            if (this.artboard) {\n                return this.artboard.height;\n            }\n            return (_a = this._artboardHeight) !== null && _a !== void 0 ? _a : 0;\n        },\n        set: function (value) {\n            this._artboardHeight = value;\n            if (this.artboard) {\n                this.artboard.height = value;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Reset the artboard size to its original values.\n     */\n    Rive.prototype.resetArtboardSize = function () {\n        if (this.artboard) {\n            this.artboard.resetArtboardSize();\n            this._artboardWidth = this.artboard.width;\n            this._artboardHeight = this.artboard.height;\n        }\n        else {\n            // If the artboard isn't loaded, we need to reset the custom width and height\n            this._artboardWidth = undefined;\n            this._artboardHeight = undefined;\n        }\n    };\n    Object.defineProperty(Rive.prototype, \"devicePixelRatioUsed\", {\n        /**\n         * The device pixel ratio used in rendering and canvas/artboard resizing.\n         *\n         * This value will be overidden by the device pixel ratio used in\n         * {@link resizeDrawingSurfaceToCanvas}. If you use that method, do not set this value.\n         */\n        get: function () {\n            return this._devicePixelRatioUsed;\n        },\n        set: function (value) {\n            this._devicePixelRatioUsed = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Initialize the data context with the view model instance.\n     */\n    Rive.prototype.bindViewModelInstance = function (viewModelInstance) {\n        var _a;\n        if (this.artboard && !this.destroyed) {\n            if (viewModelInstance && viewModelInstance.runtimeInstance) {\n                viewModelInstance.internalIncrementReferenceCount();\n                (_a = this._viewModelInstance) === null || _a === void 0 ? void 0 : _a.cleanup();\n                this._viewModelInstance = viewModelInstance;\n                this.artboard.bindViewModelInstance(viewModelInstance.runtimeInstance);\n                this.animator.stateMachines.forEach(function (stateMachine) {\n                    return stateMachine.bindViewModelInstance(viewModelInstance);\n                });\n            }\n        }\n    };\n    Object.defineProperty(Rive.prototype, \"viewModelInstance\", {\n        get: function () {\n            return this._viewModelInstance;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Rive.prototype.viewModelByIndex = function (index) {\n        var viewModel = this.file.viewModelByIndex(index);\n        if (viewModel !== null) {\n            return new ViewModel(viewModel);\n        }\n        return null;\n    };\n    Rive.prototype.viewModelByName = function (name) {\n        var viewModel = this.file.viewModelByName(name);\n        if (viewModel !== null) {\n            return new ViewModel(viewModel);\n        }\n        return null;\n    };\n    Rive.prototype.enums = function () {\n        if (this._dataEnums === null) {\n            var dataEnums = this.file.enums();\n            this._dataEnums = dataEnums.map(function (dataEnum) {\n                return new DataEnum(dataEnum);\n            });\n        }\n        return this._dataEnums;\n    };\n    Rive.prototype.defaultViewModel = function () {\n        if (this.artboard) {\n            var viewModel = this.file.defaultArtboardViewModel(this.artboard);\n            if (viewModel) {\n                return new ViewModel(viewModel);\n            }\n        }\n        return null;\n    };\n    // Error message for missing source or buffer\n    Rive.missingErrorMessage = \"Rive source file or data buffer required\";\n    // Error message for removed rive file\n    Rive.cleanupErrorMessage = \"Attempt to use file after calling cleanup.\";\n    return Rive;\n}());\n\nvar ViewModel = /** @class */ (function () {\n    function ViewModel(viewModel) {\n        this._viewModel = viewModel;\n    }\n    Object.defineProperty(ViewModel.prototype, \"instanceCount\", {\n        get: function () {\n            return this._viewModel.instanceCount;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewModel.prototype, \"name\", {\n        get: function () {\n            return this._viewModel.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModel.prototype.instanceByIndex = function (index) {\n        var instance = this._viewModel.instanceByIndex(index);\n        if (instance !== null) {\n            return new ViewModelInstance(instance, null);\n        }\n        return null;\n    };\n    ViewModel.prototype.instanceByName = function (name) {\n        var instance = this._viewModel.instanceByName(name);\n        if (instance !== null) {\n            return new ViewModelInstance(instance, null);\n        }\n        return null;\n    };\n    ViewModel.prototype.defaultInstance = function () {\n        var runtimeInstance = this._viewModel.defaultInstance();\n        if (runtimeInstance !== null) {\n            return new ViewModelInstance(runtimeInstance, null);\n        }\n        return null;\n    };\n    ViewModel.prototype.instance = function () {\n        var runtimeInstance = this._viewModel.instance();\n        if (runtimeInstance !== null) {\n            return new ViewModelInstance(runtimeInstance, null);\n        }\n        return null;\n    };\n    Object.defineProperty(ViewModel.prototype, \"properties\", {\n        get: function () {\n            return this._viewModel.getProperties();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewModel.prototype, \"instanceNames\", {\n        get: function () {\n            return this._viewModel.getInstanceNames();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ViewModel;\n}());\n\nvar DataEnum = /** @class */ (function () {\n    function DataEnum(dataEnum) {\n        this._dataEnum = dataEnum;\n    }\n    Object.defineProperty(DataEnum.prototype, \"name\", {\n        get: function () {\n            return this._dataEnum.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DataEnum.prototype, \"values\", {\n        get: function () {\n            return this._dataEnum.values;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return DataEnum;\n}());\n\nvar ViewModelInstance = /** @class */ (function () {\n    function ViewModelInstance(runtimeInstance, root) {\n        this._propertiesWithCallbacks = [];\n        this._referenceCount = 0;\n        this._runtimeInstance = runtimeInstance;\n        this._root = root || this;\n    }\n    Object.defineProperty(ViewModelInstance.prototype, \"runtimeInstance\", {\n        get: function () {\n            return this._runtimeInstance;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstance.prototype.handleCallbacks = function () {\n        if (this._propertiesWithCallbacks.length !== 0) {\n            this._propertiesWithCallbacks.forEach(function (property) {\n                property.handleCallbacks();\n            });\n        }\n    };\n    ViewModelInstance.prototype.clearCallbacks = function () {\n        this._propertiesWithCallbacks.forEach(function (property) {\n            property.clearCallbacks();\n        });\n    };\n    /**\n     * method to access a property instance of type number belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.number = function (path) {\n        var _a;\n        var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.number(path);\n        if (instance) {\n            return new ViewModelInstanceNumber(instance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to access a property instance of type string belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.string = function (path) {\n        var _a;\n        var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.string(path);\n        if (instance) {\n            return new ViewModelInstanceString(instance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to access a property instance of type boolean belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.boolean = function (path) {\n        var _a;\n        var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.boolean(path);\n        if (instance) {\n            return new ViewModelInstanceBoolean(instance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to access a property instance of type color belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.color = function (path) {\n        var _a;\n        var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.color(path);\n        if (instance) {\n            return new ViewModelInstanceColor(instance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to access a property instance of type trigger belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.trigger = function (path) {\n        var _a;\n        var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.trigger(path);\n        if (instance) {\n            return new ViewModelInstanceTrigger(instance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to access a property instance of type enum belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.enum = function (path) {\n        var _a;\n        var instance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.enum(path);\n        if (instance) {\n            return new ViewModelInstanceEnum(instance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to access a view model property instance belonging\n     * to the view model instance or to a nested view model instance\n     * @param path - path to the number property\n     */\n    ViewModelInstance.prototype.viewModel = function (path) {\n        var _a;\n        var viewModelInstance = (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.viewModel(path);\n        if (viewModelInstance) {\n            return new ViewModelInstance(viewModelInstance, this._root);\n        }\n        return null;\n    };\n    /**\n     * method to replace a view model property with another view model value\n     * @param path - path to the view model property\n     * @param value - view model that will replace the original\n     */\n    ViewModelInstance.prototype.replaceViewModel = function (path, value) {\n        var _a;\n        if (value.runtimeInstance !== null) {\n            return (((_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.replaceViewModel(path, value.runtimeInstance)) ||\n                false);\n        }\n        return false;\n    };\n    /*\n     * method for internal use, it shouldn't be called externally\n     */\n    ViewModelInstance.prototype.addToCallbacks = function (property) {\n        if (!this._propertiesWithCallbacks.includes(property)) {\n            this._propertiesWithCallbacks.push(property);\n        }\n    };\n    /*\n     * method for internal use, it shouldn't be called externally\n     */\n    ViewModelInstance.prototype.removeFromCallbacks = function (property) {\n        if (this._propertiesWithCallbacks.includes(property)) {\n            this._propertiesWithCallbacks = this._propertiesWithCallbacks.filter(function (prop) { return prop !== property; });\n        }\n    };\n    /*\n     * method to add one to the reference counter of the instance.\n     * Use if the file owning the reference is destroyed but the instance needs to stay around\n     */\n    ViewModelInstance.prototype.incrementReferenceCount = function () {\n        var _a;\n        this._referenceCount++;\n        (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.incrementReferenceCount();\n    };\n    /*\n     * method to subtract one to the reference counter of the instance.\n     * Use if incrementReferenceCount has been called\n     */\n    ViewModelInstance.prototype.decrementReferenceCount = function () {\n        var _a;\n        this._referenceCount--;\n        (_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.decrementReferenceCount();\n    };\n    Object.defineProperty(ViewModelInstance.prototype, \"properties\", {\n        get: function () {\n            var _a;\n            return (((_a = this._runtimeInstance) === null || _a === void 0 ? void 0 : _a.getProperties().map(function (prop) { return (__assign({}, prop)); })) || []);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstance.prototype.internalIncrementReferenceCount = function () {\n        this._referenceCount++;\n    };\n    ViewModelInstance.prototype.cleanup = function () {\n        this._referenceCount--;\n        if (this._referenceCount <= 0) {\n            this._runtimeInstance = null;\n            this.clearCallbacks();\n            this._propertiesWithCallbacks = [];\n        }\n    };\n    return ViewModelInstance;\n}());\n\nvar ViewModelInstanceValue = /** @class */ (function () {\n    function ViewModelInstanceValue(instance, root) {\n        this.callbacks = [];\n        this._viewModelInstanceValue = instance;\n        this._rootViewModel = root;\n    }\n    ViewModelInstanceValue.prototype.on = function (callback) {\n        // Since we don't clean the changed flag for properties that don't have listeners,\n        // we clean it the first time we add a listener to it\n        if (this.callbacks.length === 0) {\n            this._viewModelInstanceValue.clearChanges();\n        }\n        if (!this.callbacks.includes(callback)) {\n            this.callbacks.push(callback);\n            this._rootViewModel.addToCallbacks(this);\n        }\n    };\n    ViewModelInstanceValue.prototype.off = function (callback) {\n        if (!callback) {\n            this.callbacks.length = 0;\n        }\n        else {\n            this.callbacks = this.callbacks.filter(function (cb) { return cb !== callback; });\n        }\n        if (this.callbacks.length === 0) {\n            this._rootViewModel.removeFromCallbacks(this);\n        }\n    };\n    ViewModelInstanceValue.prototype.internalHandleCallback = function (callback) { };\n    ViewModelInstanceValue.prototype.handleCallbacks = function () {\n        var _this = this;\n        if (this._viewModelInstanceValue.hasChanged) {\n            this._viewModelInstanceValue.clearChanges();\n            this.callbacks.forEach(function (callback) {\n                _this.internalHandleCallback(callback);\n            });\n        }\n    };\n    ViewModelInstanceValue.prototype.clearCallbacks = function () {\n        this.callbacks.length = 0;\n    };\n    Object.defineProperty(ViewModelInstanceValue.prototype, \"name\", {\n        get: function () {\n            return this._viewModelInstanceValue.name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ViewModelInstanceValue;\n}());\n\nvar ViewModelInstanceString = /** @class */ (function (_super) {\n    __extends(ViewModelInstanceString, _super);\n    function ViewModelInstanceString(instance, root) {\n        return _super.call(this, instance, root) || this;\n    }\n    Object.defineProperty(ViewModelInstanceString.prototype, \"value\", {\n        get: function () {\n            return this._viewModelInstanceValue.value;\n        },\n        set: function (val) {\n            this._viewModelInstanceValue.value = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstanceString.prototype.internalHandleCallback = function (callback) {\n        callback(this.value);\n    };\n    return ViewModelInstanceString;\n}(ViewModelInstanceValue));\n\nvar ViewModelInstanceNumber = /** @class */ (function (_super) {\n    __extends(ViewModelInstanceNumber, _super);\n    function ViewModelInstanceNumber(instance, root) {\n        return _super.call(this, instance, root) || this;\n    }\n    Object.defineProperty(ViewModelInstanceNumber.prototype, \"value\", {\n        get: function () {\n            return this._viewModelInstanceValue.value;\n        },\n        set: function (val) {\n            this._viewModelInstanceValue.value = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstanceNumber.prototype.internalHandleCallback = function (callback) {\n        callback(this.value);\n    };\n    return ViewModelInstanceNumber;\n}(ViewModelInstanceValue));\n\nvar ViewModelInstanceBoolean = /** @class */ (function (_super) {\n    __extends(ViewModelInstanceBoolean, _super);\n    function ViewModelInstanceBoolean(instance, root) {\n        return _super.call(this, instance, root) || this;\n    }\n    Object.defineProperty(ViewModelInstanceBoolean.prototype, \"value\", {\n        get: function () {\n            return this._viewModelInstanceValue.value;\n        },\n        set: function (val) {\n            this._viewModelInstanceValue.value = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstanceBoolean.prototype.internalHandleCallback = function (callback) {\n        callback(this.value);\n    };\n    return ViewModelInstanceBoolean;\n}(ViewModelInstanceValue));\n\nvar ViewModelInstanceTrigger = /** @class */ (function (_super) {\n    __extends(ViewModelInstanceTrigger, _super);\n    function ViewModelInstanceTrigger(instance, root) {\n        return _super.call(this, instance, root) || this;\n    }\n    ViewModelInstanceTrigger.prototype.trigger = function () {\n        return this._viewModelInstanceValue.trigger();\n    };\n    ViewModelInstanceTrigger.prototype.internalHandleCallback = function (callback) {\n        callback();\n    };\n    return ViewModelInstanceTrigger;\n}(ViewModelInstanceValue));\n\nvar ViewModelInstanceEnum = /** @class */ (function (_super) {\n    __extends(ViewModelInstanceEnum, _super);\n    function ViewModelInstanceEnum(instance, root) {\n        return _super.call(this, instance, root) || this;\n    }\n    Object.defineProperty(ViewModelInstanceEnum.prototype, \"value\", {\n        get: function () {\n            return this._viewModelInstanceValue.value;\n        },\n        set: function (val) {\n            this._viewModelInstanceValue.value = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewModelInstanceEnum.prototype, \"valueIndex\", {\n        get: function () {\n            return this._viewModelInstanceValue\n                .valueIndex;\n        },\n        set: function (val) {\n            this._viewModelInstanceValue.valueIndex = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewModelInstanceEnum.prototype, \"values\", {\n        get: function () {\n            return this._viewModelInstanceValue.values;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstanceEnum.prototype.internalHandleCallback = function (callback) {\n        callback(this.value);\n    };\n    return ViewModelInstanceEnum;\n}(ViewModelInstanceValue));\n\nvar ViewModelInstanceColor = /** @class */ (function (_super) {\n    __extends(ViewModelInstanceColor, _super);\n    function ViewModelInstanceColor(instance, root) {\n        return _super.call(this, instance, root) || this;\n    }\n    Object.defineProperty(ViewModelInstanceColor.prototype, \"value\", {\n        get: function () {\n            return this._viewModelInstanceValue.value;\n        },\n        set: function (val) {\n            this._viewModelInstanceValue.value = val;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewModelInstanceColor.prototype.rgb = function (r, g, b) {\n        this._viewModelInstanceValue.rgb(r, g, b);\n    };\n    ViewModelInstanceColor.prototype.rgba = function (r, g, b, a) {\n        this._viewModelInstanceValue.argb(a, r, g, b);\n    };\n    ViewModelInstanceColor.prototype.argb = function (a, r, g, b) {\n        this._viewModelInstanceValue.argb(a, r, g, b);\n    };\n    // Value 0 to 255\n    ViewModelInstanceColor.prototype.alpha = function (a) {\n        this._viewModelInstanceValue.alpha(a);\n    };\n    // Value 0 to 1\n    ViewModelInstanceColor.prototype.opacity = function (o) {\n        this._viewModelInstanceValue.alpha(Math.round(Math.max(0, Math.min(1, o)) * 255));\n    };\n    ViewModelInstanceColor.prototype.internalHandleCallback = function (callback) {\n        callback(this.value);\n    };\n    return ViewModelInstanceColor;\n}(ViewModelInstanceValue));\n\n// Loads Rive data from a URI via fetch.\nvar loadRiveFile = function (src) { return __awaiter(void 0, void 0, void 0, function () {\n    var req, res, buffer;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                req = new Request(src);\n                return [4 /*yield*/, fetch(req)];\n            case 1:\n                res = _a.sent();\n                return [4 /*yield*/, res.arrayBuffer()];\n            case 2:\n                buffer = _a.sent();\n                return [2 /*return*/, buffer];\n        }\n    });\n}); };\n// #endregion\n// #region utility functions\n/*\n * Utility function to ensure an object is a string array\n */\nvar mapToStringArray = function (obj) {\n    if (typeof obj === \"string\") {\n        return [obj];\n    }\n    else if (obj instanceof Array) {\n        return obj;\n    }\n    // If obj is undefined, return empty array\n    return [];\n};\n// #endregion\n// #region testing utilities\n// Exports to only be used for tests\nvar Testing = {\n    EventManager: EventManager,\n    TaskQueueManager: TaskQueueManager,\n};\n// #endregion\n// #region asset loaders\n/**\n * Decodes bytes into an audio asset.\n *\n * Be sure to call `.unref()` on the audio once it is no longer needed. This\n * allows the engine to clean it up when it is not used by any more animations.\n */\nvar decodeAudio = function (bytes) {\n    return new Promise(function (resolve) {\n        return RuntimeLoader.getInstance(function (rive) {\n            rive.decodeAudio(bytes, resolve);\n        });\n    });\n};\n/**\n * Decodes bytes into an image.\n *\n * Be sure to call `.unref()` on the image once it is no longer needed. This\n * allows the engine to clean it up when it is not used by any more animations.\n */\nvar decodeImage = function (bytes) {\n    return new Promise(function (resolve) {\n        return RuntimeLoader.getInstance(function (rive) {\n            rive.decodeImage(bytes, resolve);\n        });\n    });\n};\n/**\n * Decodes bytes into a font.\n *\n * Be sure to call `.unref()` on the font once it is no longer needed. This\n * allows the engine to clean it up when it is not used by any more animations.\n */\nvar decodeFont = function (bytes) {\n    return new Promise(function (resolve) {\n        return RuntimeLoader.getInstance(function (rive) {\n            rive.decodeFont(bytes, resolve);\n        });\n    });\n};\n// #endregion\n\n})();\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=rive.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJpdmUtYXBwL2NhbnZhcy9yaXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLcUI7QUFDM0IsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwQkFBbUIsRUFBRSw4QkFBbUI7O0FBRXJGLDhCQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxxQkFBcUIsOEJBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHNCQUFzQixlQUFlO0FBQ3BHO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMLHlEQUF5RDtBQUN6RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsRUFBRTtBQUNMLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvQ0FBb0MsbUNBQW1DLHlDQUF5QyxrQ0FBa0MsK0JBQStCLDhCQUE4QiwrRUFBK0UsbUJBQW1CO0FBQ3BXLHFEQUFxRCwwQ0FBMEMsa0NBQWtDLCtCQUErQiwwREFBMEQsbUJBQW1CO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQixZQUFZLElBQUk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUscUNBQXFDO0FBQzFDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHLEVBQUUsc0NBQXNDO0FBQzNDO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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LEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0I7QUFDckUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsdUJBQXVCO0FBQ3RGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrREFBK0Q7QUFDdkcscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQ0FBc0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNDQUFzQztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0NBQXNDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQSxxQ0FBcUMscUNBQXFDO0FBQzFFLGdFQUFnRSxnQ0FBZ0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLG1CQUFtQjtBQUN2RyxzRUFBc0UsbUNBQW1DO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxlQUFlO0FBQzNFLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRDQUE0QztBQUNsRixhQUFhO0FBQ2I7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBLHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1Q0FBdUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx5QkFBeUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFD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LG1CQUFtQixrQkFBa0IsSUFBSSxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsMkJBQTJCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0ksbUJBQW1CLFdBQVc7QUFDOUosU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx5QkFBeUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUM7O0FBRUQsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waGlzaG5jbGljay1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9Acml2ZS1hcHAvY2FudmFzL3JpdmUuanM/ZGFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJyaXZlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInJpdmVcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoW1xuLyogMCAqLyxcbi8qIDEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19fX3dlYnBhY2tfbW9kdWxlX18sIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuXG52YXIgUml2ZSA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIFxuICByZXR1cm4gKFxuZnVuY3Rpb24obW9kdWxlQXJnID0ge30pIHtcblxudmFyIG0gPSBtb2R1bGVBcmcsIGFhLCBiYTtcbm0ucmVhZHkgPSBuZXcgUHJvbWlzZSgoYSwgYikgPT4ge1xuICBhYSA9IGE7XG4gIGJhID0gYjtcbn0pO1xuZnVuY3Rpb24gZmEoKSB7XG4gIGZ1bmN0aW9uIGEoZykge1xuICAgIGNvbnN0IG4gPSBkO1xuICAgIGMgPSBiID0gMDtcbiAgICBkID0gbmV3IE1hcCgpO1xuICAgIG4uZm9yRWFjaChwID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHAoZyk7XG4gICAgICB9IGNhdGNoIChsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vYigpO1xuICAgIGUgJiYgZS5UYigpO1xuICB9XG4gIGxldCBiID0gMCwgYyA9IDAsIGQgPSBuZXcgTWFwKCksIGUgPSBudWxsLCBmID0gbnVsbDtcbiAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihnKSB7XG4gICAgYiB8fCAoYiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhLmJpbmQodGhpcykpKTtcbiAgICBjb25zdCBuID0gKytjO1xuICAgIGQuc2V0KG4sIGcpO1xuICAgIHJldHVybiBuO1xuICB9O1xuICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oZykge1xuICAgIGQuZGVsZXRlKGcpO1xuICAgIGIgJiYgMCA9PSBkLnNpemUgJiYgKGNhbmNlbEFuaW1hdGlvbkZyYW1lKGIpLCBiID0gMCk7XG4gIH07XG4gIHRoaXMuUmIgPSBmdW5jdGlvbihnKSB7XG4gICAgZiAmJiAoZG9jdW1lbnQuYm9keS5yZW1vdmUoZiksIGYgPSBudWxsKTtcbiAgICBnIHx8IChmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgZi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcImJsYWNrXCIsIGYuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCIsIGYuc3R5bGUucmlnaHQgPSAwLCBmLnN0eWxlLnRvcCA9IDAsIGYuc3R5bGUuY29sb3IgPSBcIndoaXRlXCIsIGYuc3R5bGUucGFkZGluZyA9IFwiNHB4XCIsIGYuaW5uZXJIVE1MID0gXCJSSVZFIEZQU1wiLCBnID0gZnVuY3Rpb24obikge1xuICAgICAgZi5pbm5lckhUTUwgPSBcIlJJVkUgRlBTIFwiICsgbi50b0ZpeGVkKDEpO1xuICAgIH0sIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZikpO1xuICAgIGUgPSBuZXcgZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IDAsIHAgPSAwO1xuICAgICAgdGhpcy5UYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBwID8gKCsrbiwgbCAtPSBwLCAxMDAwIDwgbCAmJiAoZygxMDAwICogbiAvIGwpLCBuID0gcCA9IDApKSA6IChwID0gbCwgbiA9IDApO1xuICAgICAgfTtcbiAgICB9KCk7XG4gIH07XG4gIHRoaXMuT2IgPSBmdW5jdGlvbigpIHtcbiAgICBmICYmIChkb2N1bWVudC5ib2R5LnJlbW92ZShmKSwgZiA9IG51bGwpO1xuICAgIGUgPSBudWxsO1xuICB9O1xuICB0aGlzLm9iID0gZnVuY3Rpb24oKSB7XG4gIH07XG59XG5mdW5jdGlvbiBoYShhKSB7XG4gIGNvbnNvbGUuYXNzZXJ0KCEwKTtcbiAgY29uc3QgYiA9IG5ldyBNYXAoKTtcbiAgbGV0IGMgPSAtSW5maW5pdHk7XG4gIHRoaXMucHVzaCA9IGZ1bmN0aW9uKGQpIHtcbiAgICBkID0gZCArICgoMSA8PCBhKSAtIDEpID4+IGE7XG4gICAgYi5oYXMoZCkgJiYgY2xlYXJUaW1lb3V0KGIuZ2V0KGQpKTtcbiAgICBiLnNldChkLCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgYi5kZWxldGUoZCk7XG4gICAgICAwID09IGIubGVuZ3RoID8gYyA9IC1JbmZpbml0eSA6IGQgPT0gYyAmJiAoYyA9IE1hdGgubWF4KC4uLmIua2V5cygpKSwgY29uc29sZS5hc3NlcnQoYyA8IGQpKTtcbiAgICB9LCAxMDAwKSk7XG4gICAgYyA9IE1hdGgubWF4KGQsIGMpO1xuICAgIHJldHVybiBjIDw8IGE7XG4gIH07XG59XG5jb25zdCBpYSA9IG0ub25SdW50aW1lSW5pdGlhbGl6ZWQ7XG5tLm9uUnVudGltZUluaXRpYWxpemVkID0gZnVuY3Rpb24oKSB7XG4gIGlhICYmIGlhKCk7XG4gIGxldCBhID0gbS5kZWNvZGVBdWRpbztcbiAgbS5kZWNvZGVBdWRpbyA9IGZ1bmN0aW9uKGUsIGYpIHtcbiAgICBlID0gYShlKTtcbiAgICBmKGUpO1xuICB9O1xuICBsZXQgYiA9IG0uZGVjb2RlRm9udDtcbiAgbS5kZWNvZGVGb250ID0gZnVuY3Rpb24oZSwgZikge1xuICAgIGUgPSBiKGUpO1xuICAgIGYoZSk7XG4gIH07XG4gIGNvbnN0IGMgPSBtLkZpbGVBc3NldExvYWRlcjtcbiAgbS5wdHJUb0Fzc2V0ID0gZSA9PiB7XG4gICAgbGV0IGYgPSBtLnB0clRvRmlsZUFzc2V0KGUpO1xuICAgIHJldHVybiBmLmlzSW1hZ2UgPyBtLnB0clRvSW1hZ2VBc3NldChlKSA6IGYuaXNGb250ID8gbS5wdHJUb0ZvbnRBc3NldChlKSA6IGYuaXNBdWRpbyA/IG0ucHRyVG9BdWRpb0Fzc2V0KGUpIDogZjtcbiAgfTtcbiAgbS5DdXN0b21GaWxlQXNzZXRMb2FkZXIgPSBjLmV4dGVuZChcIkN1c3RvbUZpbGVBc3NldExvYWRlclwiLCB7X19jb25zdHJ1Y3Q6ZnVuY3Rpb24oe2xvYWRDb250ZW50czplfSkge1xuICAgIHRoaXMuX19wYXJlbnQuX19jb25zdHJ1Y3QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLkdiID0gZTtcbiAgfSwgbG9hZENvbnRlbnRzOmZ1bmN0aW9uKGUsIGYpIHtcbiAgICBlID0gbS5wdHJUb0Fzc2V0KGUpO1xuICAgIHJldHVybiB0aGlzLkdiKGUsIGYpO1xuICB9LH0pO1xuICBtLkNETkZpbGVBc3NldExvYWRlciA9IGMuZXh0ZW5kKFwiQ0RORmlsZUFzc2V0TG9hZGVyXCIsIHtfX2NvbnN0cnVjdDpmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9fcGFyZW50Ll9fY29uc3RydWN0LmNhbGwodGhpcyk7XG4gIH0sIGxvYWRDb250ZW50czpmdW5jdGlvbihlKSB7XG4gICAgbGV0IGYgPSBtLnB0clRvQXNzZXQoZSk7XG4gICAgZSA9IGYuY2RuVXVpZDtcbiAgICBpZiAoXCJcIiA9PT0gZSkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICAoZnVuY3Rpb24oZywgbikge1xuICAgICAgdmFyIHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHAucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgcC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgNCA9PSBwLnJlYWR5U3RhdGUgJiYgMjAwID09IHAuc3RhdHVzICYmIG4ocCk7XG4gICAgICB9O1xuICAgICAgcC5vcGVuKFwiR0VUXCIsIGcsICEwKTtcbiAgICAgIHAuc2VuZChudWxsKTtcbiAgICB9KShmLmNkbkJhc2VVcmwgKyBcIi9cIiArIGUsIGcgPT4ge1xuICAgICAgZi5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZy5yZXNwb25zZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiAhMDtcbiAgfSx9KTtcbiAgbS5GYWxsYmFja0ZpbGVBc3NldExvYWRlciA9IGMuZXh0ZW5kKFwiRmFsbGJhY2tGaWxlQXNzZXRMb2FkZXJcIiwge19fY29uc3RydWN0OmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19wYXJlbnQuX19jb25zdHJ1Y3QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmtiID0gW107XG4gIH0sIGFkZExvYWRlcjpmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5rYi5wdXNoKGUpO1xuICB9LCBsb2FkQ29udGVudHM6ZnVuY3Rpb24oZSwgZikge1xuICAgIGZvciAobGV0IGcgb2YgdGhpcy5rYikge1xuICAgICAgaWYgKGcubG9hZENvbnRlbnRzKGUsIGYpKSB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9LH0pO1xuICBsZXQgZCA9IG0uY29tcHV0ZUFsaWdubWVudDtcbiAgbS5jb21wdXRlQWxpZ25tZW50ID0gZnVuY3Rpb24oZSwgZiwgZywgbiwgcCA9IDEuMCkge1xuICAgIHJldHVybiBkLmNhbGwodGhpcywgZSwgZiwgZywgbiwgcCk7XG4gIH07XG59O1xuY29uc3QgamEgPSBcImNyZWF0ZUNvbmljR3JhZGllbnQgY3JlYXRlSW1hZ2VEYXRhIGNyZWF0ZUxpbmVhckdyYWRpZW50IGNyZWF0ZVBhdHRlcm4gY3JlYXRlUmFkaWFsR3JhZGllbnQgZ2V0Q29udGV4dEF0dHJpYnV0ZXMgZ2V0SW1hZ2VEYXRhIGdldExpbmVEYXNoIGdldFRyYW5zZm9ybSBpc0NvbnRleHRMb3N0IGlzUG9pbnRJblBhdGggaXNQb2ludEluU3Ryb2tlIG1lYXN1cmVUZXh0XCIuc3BsaXQoXCIgXCIpLCBrYSA9IG5ldyBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gYSgpIHtcbiAgICBpZiAoIWIpIHtcbiAgICAgIHZhciBrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgdCA9IHthbHBoYToxLCBkZXB0aDowLCBzdGVuY2lsOjAsIGFudGlhbGlhczowLCBwcmVtdWx0aXBsaWVkQWxwaGE6MSwgcHJlc2VydmVEcmF3aW5nQnVmZmVyOjAsIHBvd2VyUHJlZmVyZW5jZTpcImhpZ2gtcGVyZm9ybWFuY2VcIiwgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDowLCBlbmFibGVFeHRlbnNpb25zQnlEZWZhdWx0OjEsIGV4cGxpY2l0U3dhcENvbnRyb2w6MSwgcmVuZGVyVmlhT2Zmc2NyZWVuQmFja0J1ZmZlcjoxLH07XG4gICAgICBsZXQgcjtcbiAgICAgIGlmICgvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgaWYgKHIgPSBrLmdldENvbnRleHQoXCJ3ZWJnbFwiLCB0KSwgYyA9IDEsICFyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiTm8gV2ViR0wgc3VwcG9ydC4gSW1hZ2UgbWVzaCB3aWxsIG5vdCBiZSBkcmF3bi5cIiksICExO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAociA9IGsuZ2V0Q29udGV4dChcIndlYmdsMlwiLCB0KSkge1xuICAgICAgICAgIGMgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyID0gay5nZXRDb250ZXh0KFwid2ViZ2xcIiwgdCkpIHtcbiAgICAgICAgICAgIGMgPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJObyBXZWJHTCBzdXBwb3J0LiBJbWFnZSBtZXNoIHdpbGwgbm90IGJlIGRyYXduLlwiKSwgITE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gbmV3IFByb3h5KHIsIHtnZXQoRCwgdykge1xuICAgICAgICBpZiAoRC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgICBpZiAocCB8fCAoY29uc29sZS5lcnJvcihcIkNhbm5vdCByZW5kZXIgdGhlIG1lc2ggYmVjYXVzZSB0aGUgR0wgQ29udGV4dCB3YXMgbG9zdC4gVHJpZWQgdG8gaW52b2tlIFwiLCB3KSwgcCA9ICEwKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRFt3XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIERbd10gPyBmdW5jdGlvbiguLi5NKSB7XG4gICAgICAgICAgICByZXR1cm4gRFt3XS5hcHBseShELCBNKTtcbiAgICAgICAgICB9IDogRFt3XTtcbiAgICAgICAgfVxuICAgICAgfSwgc2V0KEQsIHcsIE0pIHtcbiAgICAgICAgaWYgKEQuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgICAgcCB8fCAoY29uc29sZS5lcnJvcihcIkNhbm5vdCByZW5kZXIgdGhlIG1lc2ggYmVjYXVzZSB0aGUgR0wgQ29udGV4dCB3YXMgbG9zdC4gVHJpZWQgdG8gc2V0IHByb3BlcnR5IFwiICsgdyksIHAgPSAhMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIERbd10gPSBNLCAhMDtcbiAgICAgICAgfVxuICAgICAgfSx9KTtcbiAgICAgIGQgPSBNYXRoLm1pbihyLmdldFBhcmFtZXRlcihyLk1BWF9SRU5ERVJCVUZGRVJfU0laRSksIHIuZ2V0UGFyYW1ldGVyKHIuTUFYX1RFWFRVUkVfU0laRSkpO1xuICAgICAgZnVuY3Rpb24gQihELCB3LCBNKSB7XG4gICAgICAgIHcgPSByLmNyZWF0ZVNoYWRlcih3KTtcbiAgICAgICAgci5zaGFkZXJTb3VyY2UodywgTSk7XG4gICAgICAgIHIuY29tcGlsZVNoYWRlcih3KTtcbiAgICAgICAgTSA9IHIuZ2V0U2hhZGVySW5mb0xvZyh3KTtcbiAgICAgICAgaWYgKDAgPCAoTSB8fCBcIlwiKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBNO1xuICAgICAgICB9XG4gICAgICAgIHIuYXR0YWNoU2hhZGVyKEQsIHcpO1xuICAgICAgfVxuICAgICAgayA9IHIuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgQihrLCByLlZFUlRFWF9TSEFERVIsIFwiYXR0cmlidXRlIHZlYzIgdmVydGV4O1xcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiB1djtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IG1hdDtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIHRyYW5zbGF0ZTtcXG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHN0O1xcbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICAgICBzdCA9IHV2O1xcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KG1hdDIobWF0KSAqIHZlcnRleCArIHRyYW5zbGF0ZSwgMCwgMSk7XFxuICAgICAgICAgICAgICAgIH1cIik7XG4gICAgICBCKGssIHIuRlJBR01FTlRfU0hBREVSLCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgaW1hZ2U7XFxuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiBzdDtcXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGltYWdlLCBzdCk7XFxuICAgICAgICAgICAgICAgIH1cIik7XG4gICAgICByLmJpbmRBdHRyaWJMb2NhdGlvbihrLCAwLCBcInZlcnRleFwiKTtcbiAgICAgIHIuYmluZEF0dHJpYkxvY2F0aW9uKGssIDEsIFwidXZcIik7XG4gICAgICByLmxpbmtQcm9ncmFtKGspO1xuICAgICAgdCA9IHIuZ2V0UHJvZ3JhbUluZm9Mb2coayk7XG4gICAgICBpZiAoMCA8ICh0IHx8IFwiXCIpLnRyaW0oKS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgdDtcbiAgICAgIH1cbiAgICAgIGUgPSByLmdldFVuaWZvcm1Mb2NhdGlvbihrLCBcIm1hdFwiKTtcbiAgICAgIGYgPSByLmdldFVuaWZvcm1Mb2NhdGlvbihrLCBcInRyYW5zbGF0ZVwiKTtcbiAgICAgIHIudXNlUHJvZ3JhbShrKTtcbiAgICAgIHIuYmluZEJ1ZmZlcihyLkFSUkFZX0JVRkZFUiwgci5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICByLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KDApO1xuICAgICAgci5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSgxKTtcbiAgICAgIHIuYmluZEJ1ZmZlcihyLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCByLmNyZWF0ZUJ1ZmZlcigpKTtcbiAgICAgIHIudW5pZm9ybTFpKHIuZ2V0VW5pZm9ybUxvY2F0aW9uKGssIFwiaW1hZ2VcIiksIDApO1xuICAgICAgci5waXhlbFN0b3JlaShyLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgITApO1xuICAgICAgYiA9IHI7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICBsZXQgYiA9IG51bGwsIGMgPSAwLCBkID0gMCwgZSA9IG51bGwsIGYgPSBudWxsLCBnID0gMCwgbiA9IDAsIHAgPSAhMTtcbiAgYSgpO1xuICB0aGlzLmhjID0gZnVuY3Rpb24oKSB7XG4gICAgYSgpO1xuICAgIHJldHVybiBkO1xuICB9O1xuICB0aGlzLk1iID0gZnVuY3Rpb24oaykge1xuICAgIGIuZGVsZXRlVGV4dHVyZSAmJiBiLmRlbGV0ZVRleHR1cmUoayk7XG4gIH07XG4gIHRoaXMuTGIgPSBmdW5jdGlvbihrKSB7XG4gICAgaWYgKCFhKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0ID0gYi5jcmVhdGVUZXh0dXJlKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsIHQpO1xuICAgIGIudGV4SW1hZ2UyRChiLlRFWFRVUkVfMkQsIDAsIGIuUkdCQSwgYi5SR0JBLCBiLlVOU0lHTkVEX0JZVEUsIGspO1xuICAgIGIudGV4UGFyYW1ldGVyaShiLlRFWFRVUkVfMkQsIGIuVEVYVFVSRV9XUkFQX1MsIGIuQ0xBTVBfVE9fRURHRSk7XG4gICAgYi50ZXhQYXJhbWV0ZXJpKGIuVEVYVFVSRV8yRCwgYi5URVhUVVJFX1dSQVBfVCwgYi5DTEFNUF9UT19FREdFKTtcbiAgICBiLnRleFBhcmFtZXRlcmkoYi5URVhUVVJFXzJELCBiLlRFWFRVUkVfTUFHX0ZJTFRFUiwgYi5MSU5FQVIpO1xuICAgIDIgPT0gYyA/IChiLnRleFBhcmFtZXRlcmkoYi5URVhUVVJFXzJELCBiLlRFWFRVUkVfTUlOX0ZJTFRFUiwgYi5MSU5FQVJfTUlQTUFQX0xJTkVBUiksIGIuZ2VuZXJhdGVNaXBtYXAoYi5URVhUVVJFXzJEKSkgOiBiLnRleFBhcmFtZXRlcmkoYi5URVhUVVJFXzJELCBiLlRFWFRVUkVfTUlOX0ZJTFRFUiwgYi5MSU5FQVIpO1xuICAgIHJldHVybiB0O1xuICB9O1xuICBjb25zdCBsID0gbmV3IGhhKDgpLCB1ID0gbmV3IGhhKDgpLCB2ID0gbmV3IGhhKDEwKSwgeCA9IG5ldyBoYSgxMCk7XG4gIHRoaXMuUWIgPSBmdW5jdGlvbihrLCB0LCByLCBCLCBEKSB7XG4gICAgaWYgKGEoKSkge1xuICAgICAgdmFyIHcgPSBsLnB1c2goayksIE0gPSB1LnB1c2godCk7XG4gICAgICBpZiAoYi5jYW52YXMpIHtcbiAgICAgICAgaWYgKGIuY2FudmFzLndpZHRoICE9IHcgfHwgYi5jYW52YXMuaGVpZ2h0ICE9IE0pIHtcbiAgICAgICAgICBiLmNhbnZhcy53aWR0aCA9IHcsIGIuY2FudmFzLmhlaWdodCA9IE07XG4gICAgICAgIH1cbiAgICAgICAgYi52aWV3cG9ydCgwLCBNIC0gdCwgaywgdCk7XG4gICAgICAgIGIuZGlzYWJsZShiLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIGIuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgYi5jbGVhcihiLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICBiLmVuYWJsZShiLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIHIuc29ydCgoSCwgY2EpID0+IGNhLndiIC0gSC53Yik7XG4gICAgICAgIHcgPSB2LnB1c2goQik7XG4gICAgICAgIGcgIT0gdyAmJiAoYi5idWZmZXJEYXRhKGIuQVJSQVlfQlVGRkVSLCA4ICogdywgYi5EWU5BTUlDX0RSQVcpLCBnID0gdyk7XG4gICAgICAgIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBUIG9mIHIpIHtcbiAgICAgICAgICBiLmJ1ZmZlclN1YkRhdGEoYi5BUlJBWV9CVUZGRVIsIHcsIFQuVGEpLCB3ICs9IDQgKiBULlRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmFzc2VydCh3ID09IDQgKiBCKTtcbiAgICAgICAgZm9yICh2YXIgZGEgb2Ygcikge1xuICAgICAgICAgIGIuYnVmZmVyU3ViRGF0YShiLkFSUkFZX0JVRkZFUiwgdywgZGEuRGIpLCB3ICs9IDQgKiBkYS5EYi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5hc3NlcnQodyA9PSA4ICogQik7XG4gICAgICAgIHcgPSB4LnB1c2goRCk7XG4gICAgICAgIG4gIT0gdyAmJiAoYi5idWZmZXJEYXRhKGIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIDIgKiB3LCBiLkRZTkFNSUNfRFJBVyksIG4gPSB3KTtcbiAgICAgICAgVCA9IDA7XG4gICAgICAgIGZvciAodmFyIHJhIG9mIHIpIHtcbiAgICAgICAgICBiLmJ1ZmZlclN1YkRhdGEoYi5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgVCwgcmEuaW5kaWNlcyksIFQgKz0gMiAqIHJhLmluZGljZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KFQgPT0gMiAqIEQpO1xuICAgICAgICByYSA9IDA7XG4gICAgICAgIGRhID0gITA7XG4gICAgICAgIHcgPSBUID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBIIG9mIHIpIHtcbiAgICAgICAgICBILmltYWdlLkthICE9IHJhICYmIChiLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV8yRCwgSC5pbWFnZS5KYSB8fCBudWxsKSwgcmEgPSBILmltYWdlLkthKTtcbiAgICAgICAgICBILm1jID8gKGIuc2Npc3NvcihILllhLCBNIC0gSC5aYSAtIEguamIsIEguQWMsIEguamIpLCBkYSA9ICEwKSA6IGRhICYmIChiLnNjaXNzb3IoMCwgTSAtIHQsIGssIHQpLCBkYSA9ICExKTtcbiAgICAgICAgICByID0gMiAvIGs7XG4gICAgICAgICAgY29uc3QgY2EgPSAtMiAvIHQ7XG4gICAgICAgICAgYi51bmlmb3JtNGYoZSwgSC5oYVswXSAqIHIgKiBILkJhLCBILmhhWzFdICogY2EgKiBILkNhLCBILmhhWzJdICogciAqIEguQmEsIEguaGFbM10gKiBjYSAqIEguQ2EpO1xuICAgICAgICAgIGIudW5pZm9ybTJmKGYsIEguaGFbNF0gKiByICogSC5CYSArIHIgKiAoSC5ZYSAtIEguaWMgKiBILkJhKSAtIDEsIEguaGFbNV0gKiBjYSAqIEguQ2EgKyBjYSAqIChILlphIC0gSC5qYyAqIEguQ2EpICsgMSk7XG4gICAgICAgICAgYi52ZXJ0ZXhBdHRyaWJQb2ludGVyKDAsIDIsIGIuRkxPQVQsICExLCAwLCB3KTtcbiAgICAgICAgICBiLnZlcnRleEF0dHJpYlBvaW50ZXIoMSwgMiwgYi5GTE9BVCwgITEsIDAsIHcgKyA0ICogQik7XG4gICAgICAgICAgYi5kcmF3RWxlbWVudHMoYi5UUklBTkdMRVMsIEguaW5kaWNlcy5sZW5ndGgsIGIuVU5TSUdORURfU0hPUlQsIFQpO1xuICAgICAgICAgIHcgKz0gNCAqIEguVGEubGVuZ3RoO1xuICAgICAgICAgIFQgKz0gMiAqIEguaW5kaWNlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5hc3NlcnQodyA9PSA0ICogQik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KFQgPT0gMiAqIEQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdGhpcy5jYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSgpICYmIGIuY2FudmFzO1xuICB9O1xufSgpLCBsYSA9IG0ub25SdW50aW1lSW5pdGlhbGl6ZWQ7XG5tLm9uUnVudGltZUluaXRpYWxpemVkID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGEocSkge1xuICAgIHN3aXRjaChxKSB7XG4gICAgICBjYXNlIGwuc3JjT3ZlcjpcbiAgICAgICAgcmV0dXJuIFwic291cmNlLW92ZXJcIjtcbiAgICAgIGNhc2UgbC5zY3JlZW46XG4gICAgICAgIHJldHVybiBcInNjcmVlblwiO1xuICAgICAgY2FzZSBsLm92ZXJsYXk6XG4gICAgICAgIHJldHVybiBcIm92ZXJsYXlcIjtcbiAgICAgIGNhc2UgbC5kYXJrZW46XG4gICAgICAgIHJldHVybiBcImRhcmtlblwiO1xuICAgICAgY2FzZSBsLmxpZ2h0ZW46XG4gICAgICAgIHJldHVybiBcImxpZ2h0ZW5cIjtcbiAgICAgIGNhc2UgbC5jb2xvckRvZGdlOlxuICAgICAgICByZXR1cm4gXCJjb2xvci1kb2RnZVwiO1xuICAgICAgY2FzZSBsLmNvbG9yQnVybjpcbiAgICAgICAgcmV0dXJuIFwiY29sb3ItYnVyblwiO1xuICAgICAgY2FzZSBsLmhhcmRMaWdodDpcbiAgICAgICAgcmV0dXJuIFwiaGFyZC1saWdodFwiO1xuICAgICAgY2FzZSBsLnNvZnRMaWdodDpcbiAgICAgICAgcmV0dXJuIFwic29mdC1saWdodFwiO1xuICAgICAgY2FzZSBsLmRpZmZlcmVuY2U6XG4gICAgICAgIHJldHVybiBcImRpZmZlcmVuY2VcIjtcbiAgICAgIGNhc2UgbC5leGNsdXNpb246XG4gICAgICAgIHJldHVybiBcImV4Y2x1c2lvblwiO1xuICAgICAgY2FzZSBsLm11bHRpcGx5OlxuICAgICAgICByZXR1cm4gXCJtdWx0aXBseVwiO1xuICAgICAgY2FzZSBsLmh1ZTpcbiAgICAgICAgcmV0dXJuIFwiaHVlXCI7XG4gICAgICBjYXNlIGwuc2F0dXJhdGlvbjpcbiAgICAgICAgcmV0dXJuIFwic2F0dXJhdGlvblwiO1xuICAgICAgY2FzZSBsLmNvbG9yOlxuICAgICAgICByZXR1cm4gXCJjb2xvclwiO1xuICAgICAgY2FzZSBsLmx1bWlub3NpdHk6XG4gICAgICAgIHJldHVybiBcImx1bWlub3NpdHlcIjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYihxKSB7XG4gICAgcmV0dXJuIFwicmdiYShcIiArICgoMTY3MTE2ODAgJiBxKSA+Pj4gMTYpICsgXCIsXCIgKyAoKDY1MjgwICYgcSkgPj4+IDgpICsgXCIsXCIgKyAoKDI1NSAmIHEpID4+PiAwKSArIFwiLFwiICsgKCg0Mjc4MTkwMDgwICYgcSkgPj4+IDI0KSAvIDI1NSArIFwiKVwiO1xuICB9XG4gIGZ1bmN0aW9uIGMoKSB7XG4gICAgMCA8IE0ubGVuZ3RoICYmIChrYS5RYih3LmRyYXdXaWR0aCgpLCB3LmRyYXdIZWlnaHQoKSwgTSwgVCwgZGEpLCBNID0gW10sIGRhID0gVCA9IDAsIHcucmVzZXQoNTEyLCA1MTIpKTtcbiAgICBmb3IgKGNvbnN0IHEgb2YgRCkge1xuICAgICAgZm9yIChjb25zdCB5IG9mIHEuSCkge1xuICAgICAgICB5KCk7XG4gICAgICB9XG4gICAgICBxLkggPSBbXTtcbiAgICB9XG4gICAgRC5jbGVhcigpO1xuICB9XG4gIGxhICYmIGxhKCk7XG4gIHZhciBkID0gbS5SZW5kZXJQYWludFN0eWxlO1xuICBjb25zdCBlID0gbS5SZW5kZXJQYXRoLCBmID0gbS5SZW5kZXJQYWludCwgZyA9IG0uUmVuZGVyZXIsIG4gPSBtLlN0cm9rZUNhcCwgcCA9IG0uU3Ryb2tlSm9pbiwgbCA9IG0uQmxlbmRNb2RlLCB1ID0gZC5maWxsLCB2ID0gZC5zdHJva2UsIHggPSBtLkZpbGxSdWxlLmV2ZW5PZGQ7XG4gIGxldCBrID0gMTtcbiAgdmFyIHQgPSBtLlJlbmRlckltYWdlLmV4dGVuZChcIkNhbnZhc1JlbmRlckltYWdlXCIsIHtfX2NvbnN0cnVjdDpmdW5jdGlvbih7bGE6cSwgeGE6eX0gPSB7fSkge1xuICAgIHRoaXMuX19wYXJlbnQuX19jb25zdHJ1Y3QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLkthID0gaztcbiAgICBrID0gayArIDEgJiAyMTQ3NDgzNjQ3IHx8IDE7XG4gICAgdGhpcy5sYSA9IHE7XG4gICAgdGhpcy54YSA9IHk7XG4gIH0sIF9fZGVzdHJ1Y3Q6ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5KYSAmJiAoa2EuTWIodGhpcy5KYSksIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5XYSkpO1xuICAgIHRoaXMuX19wYXJlbnQuX19kZXN0cnVjdC5jYWxsKHRoaXMpO1xuICB9LCBkZWNvZGU6ZnVuY3Rpb24ocSkge1xuICAgIHZhciB5ID0gdGhpcztcbiAgICB5LnhhICYmIHkueGEoeSk7XG4gICAgdmFyIEYgPSBuZXcgSW1hZ2UoKTtcbiAgICB5LldhID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbcV0sIHt0eXBlOlwiaW1hZ2UvcG5nXCIsfSkpO1xuICAgIEYub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB5LkZiID0gRjtcbiAgICAgIHkuSmEgPSBrYS5MYihGKTtcbiAgICAgIHkuc2l6ZShGLndpZHRoLCBGLmhlaWdodCk7XG4gICAgICB5LmxhICYmIHkubGEoeSk7XG4gICAgfTtcbiAgICBGLnNyYyA9IHkuV2E7XG4gIH0sfSksIHIgPSBlLmV4dGVuZChcIkNhbnZhc1JlbmRlclBhdGhcIiwge19fY29uc3RydWN0OmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19wYXJlbnQuX19jb25zdHJ1Y3QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLlQgPSBuZXcgUGF0aDJEKCk7XG4gIH0sIHJld2luZDpmdW5jdGlvbigpIHtcbiAgICB0aGlzLlQgPSBuZXcgUGF0aDJEKCk7XG4gIH0sIGFkZFBhdGg6ZnVuY3Rpb24ocSwgeSwgRiwgRywgQSwgSSwgSikge1xuICAgIHZhciBLID0gdGhpcy5ULCBYID0gSy5hZGRQYXRoO1xuICAgIHEgPSBxLlQ7XG4gICAgY29uc3QgUSA9IG5ldyBET01NYXRyaXgoKTtcbiAgICBRLmEgPSB5O1xuICAgIFEuYiA9IEY7XG4gICAgUS5jID0gRztcbiAgICBRLmQgPSBBO1xuICAgIFEuZSA9IEk7XG4gICAgUS5mID0gSjtcbiAgICBYLmNhbGwoSywgcSwgUSk7XG4gIH0sIGZpbGxSdWxlOmZ1bmN0aW9uKHEpIHtcbiAgICB0aGlzLlZhID0gcTtcbiAgfSwgbW92ZVRvOmZ1bmN0aW9uKHEsIHkpIHtcbiAgICB0aGlzLlQubW92ZVRvKHEsIHkpO1xuICB9LCBsaW5lVG86ZnVuY3Rpb24ocSwgeSkge1xuICAgIHRoaXMuVC5saW5lVG8ocSwgeSk7XG4gIH0sIGN1YmljVG86ZnVuY3Rpb24ocSwgeSwgRiwgRywgQSwgSSkge1xuICAgIHRoaXMuVC5iZXppZXJDdXJ2ZVRvKHEsIHksIEYsIEcsIEEsIEkpO1xuICB9LCBjbG9zZTpmdW5jdGlvbigpIHtcbiAgICB0aGlzLlQuY2xvc2VQYXRoKCk7XG4gIH0sfSksIEIgPSBmLmV4dGVuZChcIkNhbnZhc1JlbmRlclBhaW50XCIsIHtjb2xvcjpmdW5jdGlvbihxKSB7XG4gICAgdGhpcy5YYSA9IGIocSk7XG4gIH0sIHRoaWNrbmVzczpmdW5jdGlvbihxKSB7XG4gICAgdGhpcy5JYiA9IHE7XG4gIH0sIGpvaW46ZnVuY3Rpb24ocSkge1xuICAgIHN3aXRjaChxKSB7XG4gICAgICBjYXNlIHAubWl0ZXI6XG4gICAgICAgIHRoaXMuSWEgPSBcIm1pdGVyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwLnJvdW5kOlxuICAgICAgICB0aGlzLklhID0gXCJyb3VuZFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcC5iZXZlbDpcbiAgICAgICAgdGhpcy5JYSA9IFwiYmV2ZWxcIjtcbiAgICB9XG4gIH0sIGNhcDpmdW5jdGlvbihxKSB7XG4gICAgc3dpdGNoKHEpIHtcbiAgICAgIGNhc2Ugbi5idXR0OlxuICAgICAgICB0aGlzLkhhID0gXCJidXR0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBuLnJvdW5kOlxuICAgICAgICB0aGlzLkhhID0gXCJyb3VuZFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugbi5zcXVhcmU6XG4gICAgICAgIHRoaXMuSGEgPSBcInNxdWFyZVwiO1xuICAgIH1cbiAgfSwgc3R5bGU6ZnVuY3Rpb24ocSkge1xuICAgIHRoaXMuSGIgPSBxO1xuICB9LCBibGVuZE1vZGU6ZnVuY3Rpb24ocSkge1xuICAgIHRoaXMuRWIgPSBhKHEpO1xuICB9LCBjbGVhckdyYWRpZW50OmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuamEgPSBudWxsO1xuICB9LCBsaW5lYXJHcmFkaWVudDpmdW5jdGlvbihxLCB5LCBGLCBHKSB7XG4gICAgdGhpcy5qYSA9IHt5YjpxLCB6Yjp5LCBiYjpGLCBjYjpHLCBSYTpbXSx9O1xuICB9LCByYWRpYWxHcmFkaWVudDpmdW5jdGlvbihxLCB5LCBGLCBHKSB7XG4gICAgdGhpcy5qYSA9IHt5YjpxLCB6Yjp5LCBiYjpGLCBjYjpHLCBSYTpbXSwgZWM6ITAsfTtcbiAgfSwgYWRkU3RvcDpmdW5jdGlvbihxLCB5KSB7XG4gICAgdGhpcy5qYS5SYS5wdXNoKHtjb2xvcjpxLCBzdG9wOnksfSk7XG4gIH0sIGNvbXBsZXRlR3JhZGllbnQ6ZnVuY3Rpb24oKSB7XG4gIH0sIGRyYXc6ZnVuY3Rpb24ocSwgeSwgRikge1xuICAgIGxldCBHID0gdGhpcy5IYjtcbiAgICB2YXIgQSA9IHRoaXMuWGEsIEkgPSB0aGlzLmphO1xuICAgIHEuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5FYjtcbiAgICBpZiAobnVsbCAhPSBJKSB7XG4gICAgICBBID0gSS55YjtcbiAgICAgIHZhciBKID0gSS56YjtcbiAgICAgIGNvbnN0IFggPSBJLmJiO1xuICAgICAgdmFyIEsgPSBJLmNiO1xuICAgICAgY29uc3QgUSA9IEkuUmE7XG4gICAgICBJLmVjID8gKEkgPSBYIC0gQSwgSyAtPSBKLCBBID0gcS5jcmVhdGVSYWRpYWxHcmFkaWVudChBLCBKLCAwLCBBLCBKLCBNYXRoLnNxcnQoSSAqIEkgKyBLICogSykpKSA6IEEgPSBxLmNyZWF0ZUxpbmVhckdyYWRpZW50KEEsIEosIFgsIEspO1xuICAgICAgZm9yIChsZXQgZWEgPSAwLCBSID0gUS5sZW5ndGg7IGVhIDwgUjsgZWErKykge1xuICAgICAgICBKID0gUVtlYV0sIEEuYWRkQ29sb3JTdG9wKEouc3RvcCwgYihKLmNvbG9yKSk7XG4gICAgICB9XG4gICAgICB0aGlzLlhhID0gQTtcbiAgICAgIHRoaXMuamEgPSBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2goRykge1xuICAgICAgY2FzZSB2OlxuICAgICAgICBxLnN0cm9rZVN0eWxlID0gQTtcbiAgICAgICAgcS5saW5lV2lkdGggPSB0aGlzLkliO1xuICAgICAgICBxLmxpbmVDYXAgPSB0aGlzLkhhO1xuICAgICAgICBxLmxpbmVKb2luID0gdGhpcy5JYTtcbiAgICAgICAgcS5zdHJva2UoeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB1OlxuICAgICAgICBxLmZpbGxTdHlsZSA9IEEsIHEuZmlsbCh5LCBGKTtcbiAgICB9XG4gIH0sfSk7XG4gIGNvbnN0IEQgPSBuZXcgU2V0KCk7XG4gIGxldCB3ID0gbnVsbCwgTSA9IFtdLCBUID0gMCwgZGEgPSAwO1xuICB2YXIgcmEgPSBtLkNhbnZhc1JlbmRlcmVyID0gZy5leHRlbmQoXCJSZW5kZXJlclwiLCB7X19jb25zdHJ1Y3Q6ZnVuY3Rpb24ocSkge1xuICAgIHRoaXMuX19wYXJlbnQuX19jb25zdHJ1Y3QuY2FsbCh0aGlzKTtcbiAgICB0aGlzLlMgPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgdGhpcy5DID0gcS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdGhpcy5VYSA9IHE7XG4gICAgdGhpcy5IID0gW107XG4gIH0sIHNhdmU6ZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5TLnB1c2goLi4udGhpcy5TLnNsaWNlKHRoaXMuUy5sZW5ndGggLSA2KSk7XG4gICAgdGhpcy5ILnB1c2godGhpcy5DLnNhdmUuYmluZCh0aGlzLkMpKTtcbiAgfSwgcmVzdG9yZTpmdW5jdGlvbigpIHtcbiAgICBjb25zdCBxID0gdGhpcy5TLmxlbmd0aCAtIDY7XG4gICAgaWYgKDYgPiBxKSB7XG4gICAgICB0aHJvdyBcInJlc3RvcmUoKSBjYWxsZWQgd2l0aG91dCBtYXRjaGluZyBzYXZlKCkuXCI7XG4gICAgfVxuICAgIHRoaXMuUy5zcGxpY2UocSk7XG4gICAgdGhpcy5ILnB1c2godGhpcy5DLnJlc3RvcmUuYmluZCh0aGlzLkMpKTtcbiAgfSwgdHJhbnNmb3JtOmZ1bmN0aW9uKHEsIHksIEYsIEcsIEEsIEkpIHtcbiAgICBjb25zdCBKID0gdGhpcy5TLCBLID0gSi5sZW5ndGggLSA2O1xuICAgIEouc3BsaWNlKEssIDYsIEpbS10gKiBxICsgSltLICsgMl0gKiB5LCBKW0sgKyAxXSAqIHEgKyBKW0sgKyAzXSAqIHksIEpbS10gKiBGICsgSltLICsgMl0gKiBHLCBKW0sgKyAxXSAqIEYgKyBKW0sgKyAzXSAqIEcsIEpbS10gKiBBICsgSltLICsgMl0gKiBJICsgSltLICsgNF0sIEpbSyArIDFdICogQSArIEpbSyArIDNdICogSSArIEpbSyArIDVdKTtcbiAgICB0aGlzLkgucHVzaCh0aGlzLkMudHJhbnNmb3JtLmJpbmQodGhpcy5DLCBxLCB5LCBGLCBHLCBBLCBJKSk7XG4gIH0sIHJvdGF0ZTpmdW5jdGlvbihxKSB7XG4gICAgY29uc3QgeSA9IE1hdGguc2luKHEpO1xuICAgIHEgPSBNYXRoLmNvcyhxKTtcbiAgICB0aGlzLnRyYW5zZm9ybShxLCB5LCAteSwgcSwgMCwgMCk7XG4gIH0sIF9kcmF3UGF0aDpmdW5jdGlvbihxLCB5KSB7XG4gICAgdGhpcy5ILnB1c2goeS5kcmF3LmJpbmQoeSwgdGhpcy5DLCBxLlQsIHEuVmEgPT09IHggPyBcImV2ZW5vZGRcIiA6IFwibm9uemVyb1wiKSk7XG4gIH0sIF9kcmF3Uml2ZUltYWdlOmZ1bmN0aW9uKHEsIHksIEYpIHtcbiAgICB2YXIgRyA9IHEuRmI7XG4gICAgaWYgKEcpIHtcbiAgICAgIHZhciBBID0gdGhpcy5DLCBJID0gYSh5KTtcbiAgICAgIHRoaXMuSC5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBBLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IEk7XG4gICAgICAgIEEuZ2xvYmFsQWxwaGEgPSBGO1xuICAgICAgICBBLmRyYXdJbWFnZShHLCAwLCAwKTtcbiAgICAgICAgQS5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIF9nZXRNYXRyaXg6ZnVuY3Rpb24ocSkge1xuICAgIGNvbnN0IHkgPSB0aGlzLlMsIEYgPSB5Lmxlbmd0aCAtIDY7XG4gICAgZm9yIChsZXQgRyA9IDA7IDYgPiBHOyArK0cpIHtcbiAgICAgIHFbR10gPSB5W0YgKyBHXTtcbiAgICB9XG4gIH0sIF9kcmF3SW1hZ2VNZXNoOmZ1bmN0aW9uKHEsIHksIEYsIEcsIEEsIEksIEosIEssIFgsIFEpIHtcbiAgICB2YXIgZWEgPSB0aGlzLkMuY2FudmFzLndpZHRoLCBSID0gdGhpcy5DLmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgWWIgPSBYIC0gSiwgWmIgPSBRIC0gSztcbiAgICBKID0gTWF0aC5tYXgoSiwgMCk7XG4gICAgSyA9IE1hdGgubWF4KEssIDApO1xuICAgIFggPSBNYXRoLm1pbihYLCBlYSk7XG4gICAgUSA9IE1hdGgubWluKFEsIFIpO1xuICAgIGNvbnN0IEdhID0gWCAtIEosIEhhID0gUSAtIEs7XG4gICAgY29uc29sZS5hc3NlcnQoR2EgPD0gTWF0aC5taW4oWWIsIGVhKSk7XG4gICAgY29uc29sZS5hc3NlcnQoSGEgPD0gTWF0aC5taW4oWmIsIFIpKTtcbiAgICBpZiAoISgwID49IEdhIHx8IDAgPj0gSGEpKSB7XG4gICAgICBYID0gR2EgPCBZYiB8fCBIYSA8IFpiO1xuICAgICAgZWEgPSBRID0gMTtcbiAgICAgIHZhciBzYSA9IE1hdGguY2VpbChHYSAqIFEpLCB0YSA9IE1hdGguY2VpbChIYSAqIGVhKTtcbiAgICAgIFIgPSBrYS5oYygpO1xuICAgICAgc2EgPiBSICYmIChRICo9IFIgLyBzYSwgc2EgPSBSKTtcbiAgICAgIHRhID4gUiAmJiAoZWEgKj0gUiAvIHRhLCB0YSA9IFIpO1xuICAgICAgdyB8fCAodyA9IG5ldyBtLkR5bmFtaWNSZWN0YW5pemVyKFIpLCB3LnJlc2V0KDUxMiwgNTEyKSk7XG4gICAgICBSID0gdy5hZGRSZWN0KHNhLCB0YSk7XG4gICAgICAwID4gUiAmJiAoYygpLCBELmFkZCh0aGlzKSwgUiA9IHcuYWRkUmVjdChzYSwgdGEpLCBjb25zb2xlLmFzc2VydCgwIDw9IFIpKTtcbiAgICAgIHZhciAkYiA9IFIgJiA2NTUzNSwgYWMgPSBSID4+IDE2O1xuICAgICAgTS5wdXNoKHtoYTp0aGlzLlMuc2xpY2UodGhpcy5TLmxlbmd0aCAtIDYpLCBpbWFnZTpxLCBZYTokYiwgWmE6YWMsIGljOkosIGpjOkssIEFjOnNhLCBqYjp0YSwgQmE6USwgQ2E6ZWEsIFRhOm5ldyBGbG9hdDMyQXJyYXkoRyksIERiOm5ldyBGbG9hdDMyQXJyYXkoQSksIGluZGljZXM6bmV3IFVpbnQxNkFycmF5KEkpLCBtYzpYLCB3YjpxLkthIDw8IDEgfCAoWCA/IDEgOiAwKSx9KTtcbiAgICAgIFQgKz0gRy5sZW5ndGg7XG4gICAgICBkYSArPSBJLmxlbmd0aDtcbiAgICAgIHZhciB6YSA9IHRoaXMuQywgcWQgPSBhKHkpO1xuICAgICAgdGhpcy5ILnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHphLnNhdmUoKTtcbiAgICAgICAgemEucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgemEuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gcWQ7XG4gICAgICAgIHphLmdsb2JhbEFscGhhID0gRjtcbiAgICAgICAgY29uc3QgYmMgPSBrYS5jYW52YXMoKTtcbiAgICAgICAgYmMgJiYgemEuZHJhd0ltYWdlKGJjLCAkYiwgYWMsIHNhLCB0YSwgSiwgSywgR2EsIEhhKTtcbiAgICAgICAgemEucmVzdG9yZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBfY2xpcFBhdGg6ZnVuY3Rpb24ocSkge1xuICAgIHRoaXMuSC5wdXNoKHRoaXMuQy5jbGlwLmJpbmQodGhpcy5DLCBxLlQsIHEuVmEgPT09IHggPyBcImV2ZW5vZGRcIiA6IFwibm9uemVyb1wiKSk7XG4gIH0sIGNsZWFyOmZ1bmN0aW9uKCkge1xuICAgIEQuYWRkKHRoaXMpO1xuICAgIHRoaXMuSC5wdXNoKHRoaXMuQy5jbGVhclJlY3QuYmluZCh0aGlzLkMsIDAsIDAsIHRoaXMuVWEud2lkdGgsIHRoaXMuVWEuaGVpZ2h0KSk7XG4gIH0sIGZsdXNoOmZ1bmN0aW9uKCkge1xuICB9LCB0cmFuc2xhdGU6ZnVuY3Rpb24ocSwgeSkge1xuICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHEsIHkpO1xuICB9LH0pO1xuICBtLm1ha2VSZW5kZXJlciA9IGZ1bmN0aW9uKHEpIHtcbiAgICBjb25zdCB5ID0gbmV3IHJhKHEpLCBGID0geS5DO1xuICAgIHJldHVybiBuZXcgUHJveHkoeSwge2dldChHLCBBKSB7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgR1tBXSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uSSkge1xuICAgICAgICAgIHJldHVybiBHW0FdLmFwcGx5KEcsIEkpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEZbQV0pIHtcbiAgICAgICAgaWYgKC0xIDwgamEuaW5kZXhPZihBKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiUml2ZUV4Y2VwdGlvbjogTWV0aG9kIGNhbGwgdG8gJ1wiICsgQSArIFwiKCknIGlzIG5vdCBhbGxvd2VkLCBhcyB0aGUgcmVuZGVyZXIgY2Fubm90IGltbWVkaWF0ZWx5IHBhc3MgdGhyb3VnaCB0aGUgcmV0dXJuICAgICAgICAgICAgICAgICB2YWx1ZXMgb2YgYW55IGNhbnZhcyAyZCBjb250ZXh0IG1ldGhvZHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5JKSB7XG4gICAgICAgICAgeS5ILnB1c2goRltBXS5iaW5kKEYsIC4uLkkpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBHW0FdO1xuICAgIH0sIHNldChHLCBBLCBJKSB7XG4gICAgICBpZiAoQSBpbiBGKSB7XG4gICAgICAgIHJldHVybiB5LkgucHVzaCgoKSA9PiB7XG4gICAgICAgICAgRltBXSA9IEk7XG4gICAgICAgIH0pLCAhMDtcbiAgICAgIH1cbiAgICB9LH0pO1xuICB9O1xuICBtLmRlY29kZUltYWdlID0gZnVuY3Rpb24ocSwgeSkge1xuICAgIChuZXcgdCh7bGE6eX0pKS5kZWNvZGUocSk7XG4gIH07XG4gIG0ucmVuZGVyRmFjdG9yeSA9IHttYWtlUmVuZGVyUGFpbnQ6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBCKCk7XG4gIH0sIG1ha2VSZW5kZXJQYXRoOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgcigpO1xuICB9LCBtYWtlUmVuZGVySW1hZ2U6ZnVuY3Rpb24oKSB7XG4gICAgbGV0IHEgPSBjYTtcbiAgICByZXR1cm4gbmV3IHQoe3hhOigpID0+IHtcbiAgICAgIHEudG90YWwrKztcbiAgICB9LCBsYTooKSA9PiB7XG4gICAgICBxLmxvYWRlZCsrO1xuICAgICAgaWYgKHEubG9hZGVkID09PSBxLnRvdGFsKSB7XG4gICAgICAgIGNvbnN0IHkgPSBxLnJlYWR5O1xuICAgICAgICB5ICYmICh5KCksIHEucmVhZHkgPSBudWxsKTtcbiAgICAgIH1cbiAgICB9LH0pO1xuICB9LH07XG4gIGxldCBIID0gbS5sb2FkLCBjYSA9IG51bGw7XG4gIG0ubG9hZCA9IGZ1bmN0aW9uKHEsIHksIEYgPSAhMCkge1xuICAgIGNvbnN0IEcgPSBuZXcgbS5GYWxsYmFja0ZpbGVBc3NldExvYWRlcigpO1xuICAgIHZvaWQgMCAhPT0geSAmJiBHLmFkZExvYWRlcih5KTtcbiAgICBGICYmICh5ID0gbmV3IG0uQ0RORmlsZUFzc2V0TG9hZGVyKCksIEcuYWRkTG9hZGVyKHkpKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oQSkge1xuICAgICAgbGV0IEkgPSBudWxsO1xuICAgICAgY2EgPSB7dG90YWw6MCwgbG9hZGVkOjAsIHJlYWR5OmZ1bmN0aW9uKCkge1xuICAgICAgICBBKEkpO1xuICAgICAgfSx9O1xuICAgICAgSSA9IEgocSwgRyk7XG4gICAgICAwID09IGNhLnRvdGFsICYmIEEoSSk7XG4gICAgfSk7XG4gIH07XG4gIGxldCByZCA9IG0uUmVuZGVyZXJXcmFwcGVyLnByb3RvdHlwZS5hbGlnbjtcbiAgbS5SZW5kZXJlcldyYXBwZXIucHJvdG90eXBlLmFsaWduID0gZnVuY3Rpb24ocSwgeSwgRiwgRywgQSA9IDEuMCkge1xuICAgIHJkLmNhbGwodGhpcywgcSwgeSwgRiwgRywgQSk7XG4gIH07XG4gIGQgPSBuZXcgZmEoKTtcbiAgbS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBkLnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGQpO1xuICBtLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZC5jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKGQpO1xuICBtLmVuYWJsZUZQU0NvdW50ZXIgPSBkLlJiLmJpbmQoZCk7XG4gIG0uZGlzYWJsZUZQU0NvdW50ZXIgPSBkLk9iO1xuICBkLm9iID0gYztcbiAgbS5yZXNvbHZlQW5pbWF0aW9uRnJhbWUgPSBjO1xuICBtLmNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB3ICYmIHcuZGVsZXRlKCk7XG4gIH07XG59O1xudmFyIG1hID0gT2JqZWN0LmFzc2lnbih7fSwgbSksIG5hID0gXCIuL3RoaXMucHJvZ3JhbVwiLCBvYSA9IFwib2JqZWN0XCIgPT0gdHlwZW9mIHdpbmRvdywgcGEgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGltcG9ydFNjcmlwdHMsIHFhID0gXCJcIiwgdWEsIHZhO1xuaWYgKG9hIHx8IHBhKSB7XG4gIHBhID8gcWEgPSBzZWxmLmxvY2F0aW9uLmhyZWYgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIChxYSA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSwgX3NjcmlwdERpciAmJiAocWEgPSBfc2NyaXB0RGlyKSwgMCAhPT0gcWEuaW5kZXhPZihcImJsb2I6XCIpID8gcWEgPSBxYS5zdWJzdHIoMCwgcWEucmVwbGFjZSgvWz8jXS4qLywgXCJcIikubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgOiBxYSA9IFwiXCIsIHBhICYmICh2YSA9IGEgPT4ge1xuICAgIHZhciBiID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgYi5vcGVuKFwiR0VUXCIsIGEsICExKTtcbiAgICBiLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBiLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIucmVzcG9uc2UpO1xuICB9KSwgdWEgPSAoYSwgYiwgYykgPT4ge1xuICAgIHZhciBkID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgZC5vcGVuKFwiR0VUXCIsIGEsICEwKTtcbiAgICBkLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICBkLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIDIwMCA9PSBkLnN0YXR1cyB8fCAwID09IGQuc3RhdHVzICYmIGQucmVzcG9uc2UgPyBiKGQucmVzcG9uc2UpIDogYygpO1xuICAgIH07XG4gICAgZC5vbmVycm9yID0gYztcbiAgICBkLnNlbmQobnVsbCk7XG4gIH07XG59XG52YXIgd2EgPSBtLnByaW50IHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksIHhhID0gbS5wcmludEVyciB8fCBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5PYmplY3QuYXNzaWduKG0sIG1hKTtcbm1hID0gbnVsbDtcbm0udGhpc1Byb2dyYW0gJiYgKG5hID0gbS50aGlzUHJvZ3JhbSk7XG52YXIgeWE7XG5tLndhc21CaW5hcnkgJiYgKHlhID0gbS53YXNtQmluYXJ5KTtcbnZhciBub0V4aXRSdW50aW1lID0gbS5ub0V4aXRSdW50aW1lIHx8ICEwO1xuXCJvYmplY3RcIiAhPSB0eXBlb2YgV2ViQXNzZW1ibHkgJiYgQWEoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO1xudmFyIEJhLCB6LCBDYSA9ICExLCBDLCBFLCBEYSwgRWEsIEwsIE4sIEZhLCBJYTtcbmZ1bmN0aW9uIEphKCkge1xuICB2YXIgYSA9IEJhLmJ1ZmZlcjtcbiAgbS5IRUFQOCA9IEMgPSBuZXcgSW50OEFycmF5KGEpO1xuICBtLkhFQVAxNiA9IERhID0gbmV3IEludDE2QXJyYXkoYSk7XG4gIG0uSEVBUDMyID0gTCA9IG5ldyBJbnQzMkFycmF5KGEpO1xuICBtLkhFQVBVOCA9IEUgPSBuZXcgVWludDhBcnJheShhKTtcbiAgbS5IRUFQVTE2ID0gRWEgPSBuZXcgVWludDE2QXJyYXkoYSk7XG4gIG0uSEVBUFUzMiA9IE4gPSBuZXcgVWludDMyQXJyYXkoYSk7XG4gIG0uSEVBUEYzMiA9IEZhID0gbmV3IEZsb2F0MzJBcnJheShhKTtcbiAgbS5IRUFQRjY0ID0gSWEgPSBuZXcgRmxvYXQ2NEFycmF5KGEpO1xufVxudmFyIEthLCBMYSA9IFtdLCBNYSA9IFtdLCBOYSA9IFtdO1xuZnVuY3Rpb24gT2EoKSB7XG4gIHZhciBhID0gbS5wcmVSdW4uc2hpZnQoKTtcbiAgTGEudW5zaGlmdChhKTtcbn1cbnZhciBQYSA9IDAsIFFhID0gbnVsbCwgUmEgPSBudWxsO1xuZnVuY3Rpb24gQWEoYSkge1xuICBpZiAobS5vbkFib3J0KSB7XG4gICAgbS5vbkFib3J0KGEpO1xuICB9XG4gIGEgPSBcIkFib3J0ZWQoXCIgKyBhICsgXCIpXCI7XG4gIHhhKGEpO1xuICBDYSA9ICEwO1xuICBhID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihhICsgXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpO1xuICBiYShhKTtcbiAgdGhyb3cgYTtcbn1cbmZ1bmN0aW9uIFNhKGEpIHtcbiAgcmV0dXJuIGEuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIik7XG59XG52YXIgVGE7XG5UYSA9IFwiY2FudmFzX2FkdmFuY2VkLndhc21cIjtcbmlmICghU2EoVGEpKSB7XG4gIHZhciBVYSA9IFRhO1xuICBUYSA9IG0ubG9jYXRlRmlsZSA/IG0ubG9jYXRlRmlsZShVYSwgcWEpIDogcWEgKyBVYTtcbn1cbmZ1bmN0aW9uIFZhKGEpIHtcbiAgaWYgKGEgPT0gVGEgJiYgeWEpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeWEpO1xuICB9XG4gIGlmICh2YSkge1xuICAgIHJldHVybiB2YShhKTtcbiAgfVxuICB0aHJvdyBcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7XG59XG5mdW5jdGlvbiBXYShhKSB7XG4gIGlmICgheWEgJiYgKG9hIHx8IHBhKSkge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGZldGNoICYmICFhLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKSB7XG4gICAgICByZXR1cm4gZmV0Y2goYSwge2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oYiA9PiB7XG4gICAgICAgIGlmICghYi5vaykge1xuICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIgKyBhICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGIuYXJyYXlCdWZmZXIoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IFZhKGEpKTtcbiAgICB9XG4gICAgaWYgKHVhKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGIsIGMpID0+IHtcbiAgICAgICAgdWEoYSwgZCA9PiBiKG5ldyBVaW50OEFycmF5KGQpKSwgYyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gVmEoYSkpO1xufVxuZnVuY3Rpb24gWGEoYSwgYiwgYykge1xuICByZXR1cm4gV2EoYSkudGhlbihkID0+IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGQsIGIpKS50aGVuKGQgPT4gZCkudGhlbihjLCBkID0+IHtcbiAgICB4YShcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiICsgZCk7XG4gICAgQWEoZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gWWEoYSwgYikge1xuICB2YXIgYyA9IFRhO1xuICByZXR1cm4geWEgfHwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyB8fCBTYShjKSB8fCBjLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpIHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZmV0Y2ggPyBYYShjLCBhLCBiKSA6IGZldGNoKGMsIHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKGQgPT4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoZCwgYSkudGhlbihiLCBmdW5jdGlvbihlKSB7XG4gICAgeGEoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIgKyBlKTtcbiAgICB4YShcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO1xuICAgIHJldHVybiBYYShjLCBhLCBiKTtcbiAgfSkpO1xufVxudmFyIFphLCAkYSwgZGIgPSB7NDQ5NDg0OihhLCBiLCBjLCBkLCBlKSA9PiB7XG4gIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93IHx8IHZvaWQgMCA9PT0gKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdy5oKSB7XG4gICAgd2luZG93LmggPSB7QWE6MH07XG4gICAgd2luZG93LmguSSA9IHt9O1xuICAgIHdpbmRvdy5oLkkueWEgPSBhO1xuICAgIHdpbmRvdy5oLkkuY2FwdHVyZSA9IGI7XG4gICAgd2luZG93LmguSS5MYSA9IGM7XG4gICAgd2luZG93LmguZ2EgPSB7fTtcbiAgICB3aW5kb3cuaC5nYS5zdG9wcGVkID0gZDtcbiAgICB3aW5kb3cuaC5nYS54YiA9IGU7XG4gICAgbGV0IGYgPSB3aW5kb3cuaDtcbiAgICBmLkQgPSBbXTtcbiAgICBmLnljID0gZnVuY3Rpb24oZykge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBmLkQubGVuZ3RoOyArK24pIHtcbiAgICAgICAgaWYgKG51bGwgPT0gZi5EW25dKSB7XG4gICAgICAgICAgcmV0dXJuIGYuRFtuXSA9IGcsIG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGYuRC5wdXNoKGcpO1xuICAgICAgcmV0dXJuIGYuRC5sZW5ndGggLSAxO1xuICAgIH07XG4gICAgZi5DYiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIGZvciAoZi5EW2ddID0gbnVsbDsgMCA8IGYuRC5sZW5ndGg7KSB7XG4gICAgICAgIGlmIChudWxsID09IGYuRFtmLkQubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICBmLkQucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGYuU2MgPSBmdW5jdGlvbihnKSB7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGYuRC5sZW5ndGg7ICsrbikge1xuICAgICAgICBpZiAoZi5EW25dID09IGcpIHtcbiAgICAgICAgICByZXR1cm4gZi5DYihuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZi5yYSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBmLkRbZ107XG4gICAgfTtcbiAgICBmLkJiID0gW1widG91Y2hlbmRcIiwgXCJjbGlja1wiXTtcbiAgICBmLnVubG9jayA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBmLkQubGVuZ3RoOyArK2cpIHtcbiAgICAgICAgdmFyIG4gPSBmLkRbZ107XG4gICAgICAgIG51bGwgIT0gbiAmJiBudWxsICE9IG4uSiAmJiBuLnN0YXRlID09PSBmLmdhLnhiICYmIG4uSi5yZXN1bWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBhYihuLnBiKTtcbiAgICAgICAgfSwgcCA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byByZXN1bWUgYXVkaW9jb250ZXh0XCIsIHApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGYuQmIubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihwLCBmLnVubG9jaywgITApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmLkJiLm1hcChmdW5jdGlvbihnKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGcsIGYudW5sb2NrLCAhMCk7XG4gICAgfSk7XG4gIH1cbiAgd2luZG93LmguQWEgKz0gMTtcbiAgcmV0dXJuIDE7XG59LCA0NTE2NjI6KCkgPT4ge1xuICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2Ygd2luZG93LmggJiYgKC0td2luZG93LmguQWEsIDAgPT09IHdpbmRvdy5oLkFhICYmIGRlbGV0ZSB3aW5kb3cuaCk7XG59LCA0NTE4MjY6KCkgPT4gdm9pZCAwICE9PSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIHZvaWQgMCAhPT0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEsIDQ1MTkzMDooKSA9PiB7XG4gIHRyeSB7XG4gICAgdmFyIGEgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKSwgYiA9IGEuc2FtcGxlUmF0ZTtcbiAgICBhLmNsb3NlKCk7XG4gICAgcmV0dXJuIGI7XG4gIH0gY2F0Y2ggKGMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufSwgNDUyMTAxOihhLCBiLCBjLCBkLCBlLCBmKSA9PiB7XG4gIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGcgPSB7fSwgbiA9IHt9O1xuICBhID09IHdpbmRvdy5oLkkueWEgJiYgMCAhPSBjICYmIChuLnNhbXBsZVJhdGUgPSBjKTtcbiAgZy5KID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKG4pO1xuICBnLkouc3VzcGVuZCgpO1xuICBnLnN0YXRlID0gd2luZG93LmguZ2Euc3RvcHBlZDtcbiAgYyA9IDA7XG4gIGEgIT0gd2luZG93LmguSS55YSAmJiAoYyA9IGIpO1xuICBnLlogPSBnLkouY3JlYXRlU2NyaXB0UHJvY2Vzc29yKGQsIGMsIGIpO1xuICBnLloub25hdWRpb3Byb2Nlc3MgPSBmdW5jdGlvbihwKSB7XG4gICAgaWYgKG51bGwgPT0gZy5zYSB8fCAwID09IGcuc2EubGVuZ3RoKSB7XG4gICAgICBnLnNhID0gbmV3IEZsb2F0MzJBcnJheShGYS5idWZmZXIsIGUsIGQgKiBiKTtcbiAgICB9XG4gICAgaWYgKGEgPT0gd2luZG93LmguSS5jYXB0dXJlIHx8IGEgPT0gd2luZG93LmguSS5MYSkge1xuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBiOyBsICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgdSA9IHAuaW5wdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEobCksIHYgPSBnLnNhLCB4ID0gMDsgeCA8IGQ7IHggKz0gMSkge1xuICAgICAgICAgIHZbeCAqIGIgKyBsXSA9IHVbeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJiKGYsIGQsIGUpO1xuICAgIH1cbiAgICBpZiAoYSA9PSB3aW5kb3cuaC5JLnlhIHx8IGEgPT0gd2luZG93LmguSS5MYSkge1xuICAgICAgZm9yIChjYihmLCBkLCBlKSwgbCA9IDA7IGwgPCBwLm91dHB1dEJ1ZmZlci5udW1iZXJPZkNoYW5uZWxzOyArK2wpIHtcbiAgICAgICAgZm9yICh1ID0gcC5vdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEobCksIHYgPSBnLnNhLCB4ID0gMDsgeCA8IGQ7IHggKz0gMSkge1xuICAgICAgICAgIHVbeF0gPSB2W3ggKiBiICsgbF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsID0gMDsgbCA8IHAub3V0cHV0QnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7ICsrbCkge1xuICAgICAgICBwLm91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShsKS5maWxsKDAuMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBhICE9IHdpbmRvdy5oLkkuY2FwdHVyZSAmJiBhICE9IHdpbmRvdy5oLkkuTGEgfHwgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe2F1ZGlvOiEwLCB2aWRlbzohMX0pLnRoZW4oZnVuY3Rpb24ocCkge1xuICAgIGcuRGEgPSBnLkouY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UocCk7XG4gICAgZy5EYS5jb25uZWN0KGcuWik7XG4gICAgZy5aLmNvbm5lY3QoZy5KLmRlc3RpbmF0aW9uKTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24ocCkge1xuICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIGdldCB1c2VyIG1lZGlhOiBcIiArIHApO1xuICB9KTtcbiAgYSA9PSB3aW5kb3cuaC5JLnlhICYmIGcuWi5jb25uZWN0KGcuSi5kZXN0aW5hdGlvbik7XG4gIGcucGIgPSBmO1xuICByZXR1cm4gd2luZG93LmgueWMoZyk7XG59LCA0NTQ5Nzg6YSA9PiB3aW5kb3cuaC5yYShhKS5KLnNhbXBsZVJhdGUsIDQ1NTA1MTphID0+IHtcbiAgYSA9IHdpbmRvdy5oLnJhKGEpO1xuICB2b2lkIDAgIT09IGEuWiAmJiAoYS5aLm9uYXVkaW9wcm9jZXNzID0gZnVuY3Rpb24oKSB7XG4gIH0sIGEuWi5kaXNjb25uZWN0KCksIGEuWiA9IHZvaWQgMCk7XG4gIHZvaWQgMCAhPT0gYS5EYSAmJiAoYS5EYS5kaXNjb25uZWN0KCksIGEuRGEgPSB2b2lkIDApO1xuICBhLkouY2xvc2UoKTtcbiAgYS5KID0gdm9pZCAwO1xuICBhLnBiID0gdm9pZCAwO1xufSwgNDU1NDUxOmEgPT4ge1xuICB3aW5kb3cuaC5DYihhKTtcbn0sIDQ1NTUwMTphID0+IHtcbiAgYSA9IHdpbmRvdy5oLnJhKGEpO1xuICBhLkoucmVzdW1lKCk7XG4gIGEuc3RhdGUgPSB3aW5kb3cuaC5nYS54Yjtcbn0sIDQ1NTY0MDphID0+IHtcbiAgYSA9IHdpbmRvdy5oLnJhKGEpO1xuICBhLkouc3VzcGVuZCgpO1xuICBhLnN0YXRlID0gd2luZG93LmguZ2Euc3RvcHBlZDtcbn19LCBlYiA9IGEgPT4ge1xuICBmb3IgKDsgMCA8IGEubGVuZ3RoOykge1xuICAgIGEuc2hpZnQoKShtKTtcbiAgfVxufSwgZmIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoIC0gMTsgMCA8PSBkOyBkLS0pIHtcbiAgICB2YXIgZSA9IGFbZF07XG4gICAgXCIuXCIgPT09IGUgPyBhLnNwbGljZShkLCAxKSA6IFwiLi5cIiA9PT0gZSA/IChhLnNwbGljZShkLCAxKSwgYysrKSA6IGMgJiYgKGEuc3BsaWNlKGQsIDEpLCBjLS0pO1xuICB9XG4gIGlmIChiKSB7XG4gICAgZm9yICg7IGM7IGMtLSkge1xuICAgICAgYS51bnNoaWZ0KFwiLi5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufSwgZ2IgPSBhID0+IHtcbiAgdmFyIGIgPSBcIi9cIiA9PT0gYS5jaGFyQXQoMCksIGMgPSBcIi9cIiA9PT0gYS5zdWJzdHIoLTEpO1xuICAoYSA9IGZiKGEuc3BsaXQoXCIvXCIpLmZpbHRlcihkID0+ICEhZCksICFiKS5qb2luKFwiL1wiKSkgfHwgYiB8fCAoYSA9IFwiLlwiKTtcbiAgYSAmJiBjICYmIChhICs9IFwiL1wiKTtcbiAgcmV0dXJuIChiID8gXCIvXCIgOiBcIlwiKSArIGE7XG59LCBoYiA9IGEgPT4ge1xuICB2YXIgYiA9IC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvLmV4ZWMoYSkuc2xpY2UoMSk7XG4gIGEgPSBiWzBdO1xuICBiID0gYlsxXTtcbiAgaWYgKCFhICYmICFiKSB7XG4gICAgcmV0dXJuIFwiLlwiO1xuICB9XG4gIGIgJiYgKGIgPSBiLnN1YnN0cigwLCBiLmxlbmd0aCAtIDEpKTtcbiAgcmV0dXJuIGEgKyBiO1xufSwgaWIgPSBhID0+IHtcbiAgaWYgKFwiL1wiID09PSBhKSB7XG4gICAgcmV0dXJuIFwiL1wiO1xuICB9XG4gIGEgPSBnYihhKTtcbiAgYSA9IGEucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB2YXIgYiA9IGEubGFzdEluZGV4T2YoXCIvXCIpO1xuICByZXR1cm4gLTEgPT09IGIgPyBhIDogYS5zdWJzdHIoYiArIDEpO1xufSwgamIgPSAoKSA9PiB7XG4gIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBjcnlwdG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgcmV0dXJuIGEgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhKTtcbiAgfVxuICBBYShcImluaXRSYW5kb21EZXZpY2VcIik7XG59LCBrYiA9IGEgPT4gKGtiID0gamIoKSkoYSk7XG5mdW5jdGlvbiBsYigpIHtcbiAgZm9yICh2YXIgYSA9IFwiXCIsIGIgPSAhMSwgYyA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyAtMSA8PSBjICYmICFiOyBjLS0pIHtcbiAgICBiID0gMCA8PSBjID8gYXJndW1lbnRzW2NdIDogXCIvXCI7XG4gICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5nc1wiKTtcbiAgICB9XG4gICAgaWYgKCFiKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgYSA9IGIgKyBcIi9cIiArIGE7XG4gICAgYiA9IFwiL1wiID09PSBiLmNoYXJBdCgwKTtcbiAgfVxuICBhID0gZmIoYS5zcGxpdChcIi9cIikuZmlsdGVyKGQgPT4gISFkKSwgIWIpLmpvaW4oXCIvXCIpO1xuICByZXR1cm4gKGIgPyBcIi9cIiA6IFwiXCIpICsgYSB8fCBcIi5cIjtcbn1cbnZhciBtYiA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFRleHREZWNvZGVyID8gbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKSA6IHZvaWQgMCwgbmIgPSAoYSwgYiwgYykgPT4ge1xuICB2YXIgZCA9IGIgKyBjO1xuICBmb3IgKGMgPSBiOyBhW2NdICYmICEoYyA+PSBkKTspIHtcbiAgICArK2M7XG4gIH1cbiAgaWYgKDE2IDwgYyAtIGIgJiYgYS5idWZmZXIgJiYgbWIpIHtcbiAgICByZXR1cm4gbWIuZGVjb2RlKGEuc3ViYXJyYXkoYiwgYykpO1xuICB9XG4gIGZvciAoZCA9IFwiXCI7IGIgPCBjOykge1xuICAgIHZhciBlID0gYVtiKytdO1xuICAgIGlmIChlICYgMTI4KSB7XG4gICAgICB2YXIgZiA9IGFbYisrXSAmIDYzO1xuICAgICAgaWYgKDE5MiA9PSAoZSAmIDIyNCkpIHtcbiAgICAgICAgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChlICYgMzEpIDw8IDYgfCBmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBnID0gYVtiKytdICYgNjM7XG4gICAgICAgIGUgPSAyMjQgPT0gKGUgJiAyNDApID8gKGUgJiAxNSkgPDwgMTIgfCBmIDw8IDYgfCBnIDogKGUgJiA3KSA8PCAxOCB8IGYgPDwgMTIgfCBnIDw8IDYgfCBhW2IrK10gJiA2MztcbiAgICAgICAgNjU1MzYgPiBlID8gZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpIDogKGUgLT0gNjU1MzYsIGQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IGUgPj4gMTAsIDU2MzIwIHwgZSAmIDEwMjMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZDtcbn0sIG9iID0gW10sIHBiID0gYSA9PiB7XG4gIGZvciAodmFyIGIgPSAwLCBjID0gMDsgYyA8IGEubGVuZ3RoOyArK2MpIHtcbiAgICB2YXIgZCA9IGEuY2hhckNvZGVBdChjKTtcbiAgICAxMjcgPj0gZCA/IGIrKyA6IDIwNDcgPj0gZCA/IGIgKz0gMiA6IDU1Mjk2IDw9IGQgJiYgNTczNDMgPj0gZCA/IChiICs9IDQsICsrYykgOiBiICs9IDM7XG4gIH1cbiAgcmV0dXJuIGI7XG59LCBxYiA9IChhLCBiLCBjLCBkKSA9PiB7XG4gIGlmICghKDAgPCBkKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBlID0gYztcbiAgZCA9IGMgKyBkIC0gMTtcbiAgZm9yICh2YXIgZiA9IDA7IGYgPCBhLmxlbmd0aDsgKytmKSB7XG4gICAgdmFyIGcgPSBhLmNoYXJDb2RlQXQoZik7XG4gICAgaWYgKDU1Mjk2IDw9IGcgJiYgNTczNDMgPj0gZykge1xuICAgICAgdmFyIG4gPSBhLmNoYXJDb2RlQXQoKytmKTtcbiAgICAgIGcgPSA2NTUzNiArICgoZyAmIDEwMjMpIDw8IDEwKSB8IG4gJiAxMDIzO1xuICAgIH1cbiAgICBpZiAoMTI3ID49IGcpIHtcbiAgICAgIGlmIChjID49IGQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBiW2MrK10gPSBnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoMjA0NyA+PSBnKSB7XG4gICAgICAgIGlmIChjICsgMSA+PSBkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYltjKytdID0gMTkyIHwgZyA+PiA2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKDY1NTM1ID49IGcpIHtcbiAgICAgICAgICBpZiAoYyArIDIgPj0gZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJbYysrXSA9IDIyNCB8IGcgPj4gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGMgKyAzID49IGQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiW2MrK10gPSAyNDAgfCBnID4+IDE4O1xuICAgICAgICAgIGJbYysrXSA9IDEyOCB8IGcgPj4gMTIgJiA2MztcbiAgICAgICAgfVxuICAgICAgICBiW2MrK10gPSAxMjggfCBnID4+IDYgJiA2MztcbiAgICAgIH1cbiAgICAgIGJbYysrXSA9IDEyOCB8IGcgJiA2MztcbiAgICB9XG4gIH1cbiAgYltjXSA9IDA7XG4gIHJldHVybiBjIC0gZTtcbn07XG5mdW5jdGlvbiByYihhLCBiKSB7XG4gIHZhciBjID0gQXJyYXkocGIoYSkgKyAxKTtcbiAgYSA9IHFiKGEsIGMsIDAsIGMubGVuZ3RoKTtcbiAgYiAmJiAoYy5sZW5ndGggPSBhKTtcbiAgcmV0dXJuIGM7XG59XG52YXIgc2IgPSBbXTtcbmZ1bmN0aW9uIHRiKGEsIGIpIHtcbiAgc2JbYV0gPSB7aW5wdXQ6W10sIEY6W10sIFY6Yn07XG4gIHViKGEsIHZiKTtcbn1cbnZhciB2YiA9IHtvcGVuOmZ1bmN0aW9uKGEpIHtcbiAgdmFyIGIgPSBzYlthLm5vZGUuemFdO1xuICBpZiAoIWIpIHtcbiAgICB0aHJvdyBuZXcgTyg0Myk7XG4gIH1cbiAgYS5zID0gYjtcbiAgYS5zZWVrYWJsZSA9ICExO1xufSwgY2xvc2U6ZnVuY3Rpb24oYSkge1xuICBhLnMuVi5xYShhLnMpO1xufSwgcWE6ZnVuY3Rpb24oYSkge1xuICBhLnMuVi5xYShhLnMpO1xufSwgcmVhZDpmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIGlmICghYS5zIHx8ICFhLnMuVi5pYikge1xuICAgIHRocm93IG5ldyBPKDYwKTtcbiAgfVxuICBmb3IgKHZhciBlID0gMCwgZiA9IDA7IGYgPCBkOyBmKyspIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGcgPSBhLnMuVi5pYihhLnMpO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHRocm93IG5ldyBPKDI5KTtcbiAgICB9XG4gICAgaWYgKHZvaWQgMCA9PT0gZyAmJiAwID09PSBlKSB7XG4gICAgICB0aHJvdyBuZXcgTyg2KTtcbiAgICB9XG4gICAgaWYgKG51bGwgPT09IGcgfHwgdm9pZCAwID09PSBnKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZSsrO1xuICAgIGJbYyArIGZdID0gZztcbiAgfVxuICBlICYmIChhLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKSk7XG4gIHJldHVybiBlO1xufSwgd3JpdGU6ZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBpZiAoIWEucyB8fCAhYS5zLlYuT2EpIHtcbiAgICB0aHJvdyBuZXcgTyg2MCk7XG4gIH1cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IGQ7IGUrKykge1xuICAgICAgYS5zLlYuT2EoYS5zLCBiW2MgKyBlXSk7XG4gICAgfVxuICB9IGNhdGNoIChmKSB7XG4gICAgdGhyb3cgbmV3IE8oMjkpO1xuICB9XG4gIGQgJiYgKGEubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpKTtcbiAgcmV0dXJuIGU7XG59LH0sIHdiID0ge2liOmZ1bmN0aW9uKCkge1xuICBhOiB7XG4gICAgaWYgKCFvYi5sZW5ndGgpIHtcbiAgICAgIHZhciBhID0gbnVsbDtcbiAgICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5wcm9tcHQgPyAoYSA9IHdpbmRvdy5wcm9tcHQoXCJJbnB1dDogXCIpLCBudWxsICE9PSBhICYmIChhICs9IFwiXFxuXCIpKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVhZGxpbmUgJiYgKGEgPSByZWFkbGluZSgpLCBudWxsICE9PSBhICYmIChhICs9IFwiXFxuXCIpKTtcbiAgICAgIGlmICghYSkge1xuICAgICAgICBhID0gbnVsbDtcbiAgICAgICAgYnJlYWsgYTtcbiAgICAgIH1cbiAgICAgIG9iID0gcmIoYSwgITApO1xuICAgIH1cbiAgICBhID0gb2Iuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gYTtcbn0sIE9hOmZ1bmN0aW9uKGEsIGIpIHtcbiAgbnVsbCA9PT0gYiB8fCAxMCA9PT0gYiA/ICh3YShuYihhLkYsIDApKSwgYS5GID0gW10pIDogMCAhPSBiICYmIGEuRi5wdXNoKGIpO1xufSwgcWE6ZnVuY3Rpb24oYSkge1xuICBhLkYgJiYgMCA8IGEuRi5sZW5ndGggJiYgKHdhKG5iKGEuRiwgMCkpLCBhLkYgPSBbXSk7XG59LCBiYzpmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtGYzoyNTg1NiwgSGM6NSwgRWM6MTkxLCBHYzozNTM4NywgRGM6WzMsIDI4LCAxMjcsIDIxLCA0LCAwLCAxLCAwLCAxNywgMTksIDI2LCAwLCAxOCwgMTUsIDIzLCAyMiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxdfTtcbn0sIGNjOmZ1bmN0aW9uKCkge1xuICByZXR1cm4gMDtcbn0sIGRjOmZ1bmN0aW9uKCkge1xuICByZXR1cm4gWzI0LCA4MF07XG59LH0sIHhiID0ge09hOmZ1bmN0aW9uKGEsIGIpIHtcbiAgbnVsbCA9PT0gYiB8fCAxMCA9PT0gYiA/ICh4YShuYihhLkYsIDApKSwgYS5GID0gW10pIDogMCAhPSBiICYmIGEuRi5wdXNoKGIpO1xufSwgcWE6ZnVuY3Rpb24oYSkge1xuICBhLkYgJiYgMCA8IGEuRi5sZW5ndGggJiYgKHhhKG5iKGEuRiwgMCkpLCBhLkYgPSBbXSk7XG59LH07XG5mdW5jdGlvbiB5YihhLCBiKSB7XG4gIHZhciBjID0gYS5qID8gYS5qLmxlbmd0aCA6IDA7XG4gIGMgPj0gYiB8fCAoYiA9IE1hdGgubWF4KGIsIGMgKiAoMTA0ODU3NiA+IGMgPyAyLjAgOiAxLjEyNSkgPj4+IDApLCAwICE9IGMgJiYgKGIgPSBNYXRoLm1heChiLCAyNTYpKSwgYyA9IGEuaiwgYS5qID0gbmV3IFVpbnQ4QXJyYXkoYiksIDAgPCBhLnYgJiYgYS5qLnNldChjLnN1YmFycmF5KDAsIGEudiksIDApKTtcbn1cbnZhciBQID0ge086bnVsbCwgVSgpIHtcbiAgcmV0dXJuIFAuY3JlYXRlTm9kZShudWxsLCBcIi9cIiwgMTY4OTUsIDApO1xufSwgY3JlYXRlTm9kZShhLCBiLCBjLCBkKSB7XG4gIGlmICgyNDU3NiA9PT0gKGMgJiA2MTQ0MCkgfHwgNDA5NiA9PT0gKGMgJiA2MTQ0MCkpIHtcbiAgICB0aHJvdyBuZXcgTyg2Myk7XG4gIH1cbiAgUC5PIHx8IChQLk8gPSB7ZGlyOntub2RlOntZOlAubC5ZLCBQOlAubC5QLCBrYTpQLmwua2EsIHZhOlAubC52YSwgdWI6UC5sLnViLCBBYjpQLmwuQWIsIHZiOlAubC52Yiwgc2I6UC5sLnNiLCBFYTpQLmwuRWF9LCBzdHJlYW06e2JhOlAubS5iYX19LCBmaWxlOntub2RlOntZOlAubC5ZLCBQOlAubC5QfSwgc3RyZWFtOntiYTpQLm0uYmEsIHJlYWQ6UC5tLnJlYWQsIHdyaXRlOlAubS53cml0ZSwgcGE6UC5tLnBhLCBsYjpQLm0ubGIsIG5iOlAubS5uYn19LCBsaW5rOntub2RlOntZOlAubC5ZLCBQOlAubC5QLCBtYTpQLmwubWF9LCBzdHJlYW06e319LCAkYTp7bm9kZTp7WTpQLmwuWSwgUDpQLmwuUH0sIHN0cmVhbTp6Yn19KTtcbiAgYyA9IEFiKGEsIGIsIGMsIGQpO1xuICAxNjM4NCA9PT0gKGMubW9kZSAmIDYxNDQwKSA/IChjLmwgPSBQLk8uZGlyLm5vZGUsIGMubSA9IFAuTy5kaXIuc3RyZWFtLCBjLmogPSB7fSkgOiAzMjc2OCA9PT0gKGMubW9kZSAmIDYxNDQwKSA/IChjLmwgPSBQLk8uZmlsZS5ub2RlLCBjLm0gPSBQLk8uZmlsZS5zdHJlYW0sIGMudiA9IDAsIGMuaiA9IG51bGwpIDogNDA5NjAgPT09IChjLm1vZGUgJiA2MTQ0MCkgPyAoYy5sID0gUC5PLmxpbmsubm9kZSwgYy5tID0gUC5PLmxpbmsuc3RyZWFtKSA6IDgxOTIgPT09IChjLm1vZGUgJiA2MTQ0MCkgJiYgKGMubCA9IFAuTy4kYS5ub2RlLCBjLm0gPSBQLk8uJGEuc3RyZWFtKTtcbiAgYy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICBhICYmIChhLmpbYl0gPSBjLCBhLnRpbWVzdGFtcCA9IGMudGltZXN0YW1wKTtcbiAgcmV0dXJuIGM7XG59LCBLYyhhKSB7XG4gIHJldHVybiBhLmogPyBhLmouc3ViYXJyYXkgPyBhLmouc3ViYXJyYXkoMCwgYS52KSA6IG5ldyBVaW50OEFycmF5KGEuaikgOiBuZXcgVWludDhBcnJheSgwKTtcbn0sIGw6e1koYSkge1xuICB2YXIgYiA9IHt9O1xuICBiLkpjID0gODE5MiA9PT0gKGEubW9kZSAmIDYxNDQwKSA/IGEuaWQgOiAxO1xuICBiLk1jID0gYS5pZDtcbiAgYi5tb2RlID0gYS5tb2RlO1xuICBiLk9jID0gMTtcbiAgYi51aWQgPSAwO1xuICBiLkxjID0gMDtcbiAgYi56YSA9IGEuemE7XG4gIDE2Mzg0ID09PSAoYS5tb2RlICYgNjE0NDApID8gYi5zaXplID0gNDA5NiA6IDMyNzY4ID09PSAoYS5tb2RlICYgNjE0NDApID8gYi5zaXplID0gYS52IDogNDA5NjAgPT09IChhLm1vZGUgJiA2MTQ0MCkgPyBiLnNpemUgPSBhLmxpbmsubGVuZ3RoIDogYi5zaXplID0gMDtcbiAgYi5CYyA9IG5ldyBEYXRlKGEudGltZXN0YW1wKTtcbiAgYi5OYyA9IG5ldyBEYXRlKGEudGltZXN0YW1wKTtcbiAgYi5JYyA9IG5ldyBEYXRlKGEudGltZXN0YW1wKTtcbiAgYi5KYiA9IDQwOTY7XG4gIGIuQ2MgPSBNYXRoLmNlaWwoYi5zaXplIC8gYi5KYik7XG4gIHJldHVybiBiO1xufSwgUChhLCBiKSB7XG4gIHZvaWQgMCAhPT0gYi5tb2RlICYmIChhLm1vZGUgPSBiLm1vZGUpO1xuICB2b2lkIDAgIT09IGIudGltZXN0YW1wICYmIChhLnRpbWVzdGFtcCA9IGIudGltZXN0YW1wKTtcbiAgaWYgKHZvaWQgMCAhPT0gYi5zaXplICYmIChiID0gYi5zaXplLCBhLnYgIT0gYikpIHtcbiAgICBpZiAoMCA9PSBiKSB7XG4gICAgICBhLmogPSBudWxsLCBhLnYgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYyA9IGEuajtcbiAgICAgIGEuaiA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgICAgYyAmJiBhLmouc2V0KGMuc3ViYXJyYXkoMCwgTWF0aC5taW4oYiwgYS52KSkpO1xuICAgICAgYS52ID0gYjtcbiAgICB9XG4gIH1cbn0sIGthKCkge1xuICB0aHJvdyBCYls0NF07XG59LCB2YShhLCBiLCBjLCBkKSB7XG4gIHJldHVybiBQLmNyZWF0ZU5vZGUoYSwgYiwgYywgZCk7XG59LCB1YihhLCBiLCBjKSB7XG4gIGlmICgxNjM4NCA9PT0gKGEubW9kZSAmIDYxNDQwKSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZCA9IENiKGIsIGMpO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICB9XG4gICAgaWYgKGQpIHtcbiAgICAgIGZvciAodmFyIGUgaW4gZC5qKSB7XG4gICAgICAgIHRocm93IG5ldyBPKDU1KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIGEucGFyZW50LmpbYS5uYW1lXTtcbiAgYS5wYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgYS5uYW1lID0gYztcbiAgYi5qW2NdID0gYTtcbiAgYi50aW1lc3RhbXAgPSBhLnBhcmVudC50aW1lc3RhbXA7XG4gIGEucGFyZW50ID0gYjtcbn0sIEFiKGEsIGIpIHtcbiAgZGVsZXRlIGEualtiXTtcbiAgYS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xufSwgdmIoYSwgYikge1xuICB2YXIgYyA9IENiKGEsIGIpLCBkO1xuICBmb3IgKGQgaW4gYy5qKSB7XG4gICAgdGhyb3cgbmV3IE8oNTUpO1xuICB9XG4gIGRlbGV0ZSBhLmpbYl07XG4gIGEudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbn0sIHNiKGEpIHtcbiAgdmFyIGIgPSBbXCIuXCIsIFwiLi5cIl0sIGM7XG4gIGZvciAoYyBpbiBhLmopIHtcbiAgICBhLmouaGFzT3duUHJvcGVydHkoYykgJiYgYi5wdXNoKGMpO1xuICB9XG4gIHJldHVybiBiO1xufSwgRWEoYSwgYiwgYykge1xuICBhID0gUC5jcmVhdGVOb2RlKGEsIGIsIDQxNDcxLCAwKTtcbiAgYS5saW5rID0gYztcbiAgcmV0dXJuIGE7XG59LCBtYShhKSB7XG4gIGlmICg0MDk2MCAhPT0gKGEubW9kZSAmIDYxNDQwKSkge1xuICAgIHRocm93IG5ldyBPKDI4KTtcbiAgfVxuICByZXR1cm4gYS5saW5rO1xufSx9LCBtOntyZWFkKGEsIGIsIGMsIGQsIGUpIHtcbiAgdmFyIGYgPSBhLm5vZGUuajtcbiAgaWYgKGUgPj0gYS5ub2RlLnYpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBhID0gTWF0aC5taW4oYS5ub2RlLnYgLSBlLCBkKTtcbiAgaWYgKDggPCBhICYmIGYuc3ViYXJyYXkpIHtcbiAgICBiLnNldChmLnN1YmFycmF5KGUsIGUgKyBhKSwgYyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChkID0gMDsgZCA8IGE7IGQrKykge1xuICAgICAgYltjICsgZF0gPSBmW2UgKyBkXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59LCB3cml0ZShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGIuYnVmZmVyID09PSBDLmJ1ZmZlciAmJiAoZiA9ICExKTtcbiAgaWYgKCFkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgYSA9IGEubm9kZTtcbiAgYS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICBpZiAoYi5zdWJhcnJheSAmJiAoIWEuaiB8fCBhLmouc3ViYXJyYXkpKSB7XG4gICAgaWYgKGYpIHtcbiAgICAgIHJldHVybiBhLmogPSBiLnN1YmFycmF5KGMsIGMgKyBkKSwgYS52ID0gZDtcbiAgICB9XG4gICAgaWYgKDAgPT09IGEudiAmJiAwID09PSBlKSB7XG4gICAgICByZXR1cm4gYS5qID0gYi5zbGljZShjLCBjICsgZCksIGEudiA9IGQ7XG4gICAgfVxuICAgIGlmIChlICsgZCA8PSBhLnYpIHtcbiAgICAgIHJldHVybiBhLmouc2V0KGIuc3ViYXJyYXkoYywgYyArIGQpLCBlKSwgZDtcbiAgICB9XG4gIH1cbiAgeWIoYSwgZSArIGQpO1xuICBpZiAoYS5qLnN1YmFycmF5ICYmIGIuc3ViYXJyYXkpIHtcbiAgICBhLmouc2V0KGIuc3ViYXJyYXkoYywgYyArIGQpLCBlKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGYgPSAwOyBmIDwgZDsgZisrKSB7XG4gICAgICBhLmpbZSArIGZdID0gYltjICsgZl07XG4gICAgfVxuICB9XG4gIGEudiA9IE1hdGgubWF4KGEudiwgZSArIGQpO1xuICByZXR1cm4gZDtcbn0sIGJhKGEsIGIsIGMpIHtcbiAgMSA9PT0gYyA/IGIgKz0gYS5wb3NpdGlvbiA6IDIgPT09IGMgJiYgMzI3NjggPT09IChhLm5vZGUubW9kZSAmIDYxNDQwKSAmJiAoYiArPSBhLm5vZGUudik7XG4gIGlmICgwID4gYikge1xuICAgIHRocm93IG5ldyBPKDI4KTtcbiAgfVxuICByZXR1cm4gYjtcbn0sIHBhKGEsIGIsIGMpIHtcbiAgeWIoYS5ub2RlLCBiICsgYyk7XG4gIGEubm9kZS52ID0gTWF0aC5tYXgoYS5ub2RlLnYsIGIgKyBjKTtcbn0sIGxiKGEsIGIsIGMsIGQsIGUpIHtcbiAgaWYgKDMyNzY4ICE9PSAoYS5ub2RlLm1vZGUgJiA2MTQ0MCkpIHtcbiAgICB0aHJvdyBuZXcgTyg0Myk7XG4gIH1cbiAgYSA9IGEubm9kZS5qO1xuICBpZiAoZSAmIDIgfHwgYS5idWZmZXIgIT09IEMuYnVmZmVyKSB7XG4gICAgaWYgKDAgPCBjIHx8IGMgKyBiIDwgYS5sZW5ndGgpIHtcbiAgICAgIGEuc3ViYXJyYXkgPyBhID0gYS5zdWJhcnJheShjLCBjICsgYikgOiBhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwgYywgYyArIGIpO1xuICAgIH1cbiAgICBjID0gITA7XG4gICAgQWEoKTtcbiAgICBiID0gdm9pZCAwO1xuICAgIGlmICghYikge1xuICAgICAgdGhyb3cgbmV3IE8oNDgpO1xuICAgIH1cbiAgICBDLnNldChhLCBiKTtcbiAgfSBlbHNlIHtcbiAgICBjID0gITEsIGIgPSBhLmJ5dGVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHtvOmIsIE06Y307XG59LCBuYihhLCBiLCBjLCBkKSB7XG4gIFAubS53cml0ZShhLCBiLCAwLCBkLCBjLCAhMSk7XG4gIHJldHVybiAwO1xufSx9LH07XG5mdW5jdGlvbiBEYihhLCBiKSB7XG4gIHZhciBjID0gMDtcbiAgYSAmJiAoYyB8PSAzNjUpO1xuICBiICYmIChjIHw9IDE0Nik7XG4gIHJldHVybiBjO1xufVxudmFyIEViID0gbnVsbCwgRmIgPSB7fSwgR2IgPSBbXSwgSGIgPSAxLCBJYiA9IG51bGwsIEpiID0gITAsIE8gPSBudWxsLCBCYiA9IHt9LCBMYiA9IChhLCBiID0ge30pID0+IHtcbiAgYSA9IGxiKGEpO1xuICBpZiAoIWEpIHtcbiAgICByZXR1cm4ge3BhdGg6XCJcIiwgbm9kZTpudWxsfTtcbiAgfVxuICBiID0gT2JqZWN0LmFzc2lnbih7Z2I6ITAsIFFhOjB9LCBiKTtcbiAgaWYgKDggPCBiLlFhKSB7XG4gICAgdGhyb3cgbmV3IE8oMzIpO1xuICB9XG4gIGEgPSBhLnNwbGl0KFwiL1wiKS5maWx0ZXIoZyA9PiAhIWcpO1xuICBmb3IgKHZhciBjID0gRWIsIGQgPSBcIi9cIiwgZSA9IDA7IGUgPCBhLmxlbmd0aDsgZSsrKSB7XG4gICAgdmFyIGYgPSBlID09PSBhLmxlbmd0aCAtIDE7XG4gICAgaWYgKGYgJiYgYi5wYXJlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjID0gQ2IoYywgYVtlXSk7XG4gICAgZCA9IGdiKGQgKyBcIi9cIiArIGFbZV0pO1xuICAgIGMud2EgJiYgKCFmIHx8IGYgJiYgYi5nYikgJiYgKGMgPSBjLndhLnJvb3QpO1xuICAgIGlmICghZiB8fCBiLmZiKSB7XG4gICAgICBmb3IgKGYgPSAwOyA0MDk2MCA9PT0gKGMubW9kZSAmIDYxNDQwKTspIHtcbiAgICAgICAgaWYgKGMgPSBLYihkKSwgZCA9IGxiKGhiKGQpLCBjKSwgYyA9IExiKGQsIHtRYTpiLlFhICsgMX0pLm5vZGUsIDQwIDwgZisrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE8oMzIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7cGF0aDpkLCBub2RlOmN9O1xufSwgTWIgPSBhID0+IHtcbiAgZm9yICh2YXIgYjs7KSB7XG4gICAgaWYgKGEgPT09IGEucGFyZW50KSB7XG4gICAgICByZXR1cm4gYSA9IGEuVS5tYiwgYiA/IFwiL1wiICE9PSBhW2EubGVuZ3RoIC0gMV0gPyBgJHthfS8ke2J9YCA6IGEgKyBiIDogYTtcbiAgICB9XG4gICAgYiA9IGIgPyBgJHthLm5hbWV9LyR7Yn1gIDogYS5uYW1lO1xuICAgIGEgPSBhLnBhcmVudDtcbiAgfVxufSwgTmIgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBjID0gMCwgZCA9IDA7IGQgPCBiLmxlbmd0aDsgZCsrKSB7XG4gICAgYyA9IChjIDw8IDUpIC0gYyArIGIuY2hhckNvZGVBdChkKSB8IDA7XG4gIH1cbiAgcmV0dXJuIChhICsgYyA+Pj4gMCkgJSBJYi5sZW5ndGg7XG59LCBDYiA9IChhLCBiKSA9PiB7XG4gIHZhciBjO1xuICBpZiAoYyA9IChjID0gT2IoYSwgXCJ4XCIpKSA/IGMgOiBhLmwua2EgPyAwIDogMikge1xuICAgIHRocm93IG5ldyBPKGMsIGEpO1xuICB9XG4gIGZvciAoYyA9IEliW05iKGEuaWQsIGIpXTsgYzsgYyA9IGMubGMpIHtcbiAgICB2YXIgZCA9IGMubmFtZTtcbiAgICBpZiAoYy5wYXJlbnQuaWQgPT09IGEuaWQgJiYgZCA9PT0gYikge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICB9XG4gIHJldHVybiBhLmwua2EoYSwgYik7XG59LCBBYiA9IChhLCBiLCBjLCBkKSA9PiB7XG4gIGEgPSBuZXcgUGIoYSwgYiwgYywgZCk7XG4gIGIgPSBOYihhLnBhcmVudC5pZCwgYS5uYW1lKTtcbiAgYS5sYyA9IEliW2JdO1xuICByZXR1cm4gSWJbYl0gPSBhO1xufSwgUWIgPSBhID0+IHtcbiAgdmFyIGIgPSBbXCJyXCIsIFwid1wiLCBcInJ3XCJdW2EgJiAzXTtcbiAgYSAmIDUxMiAmJiAoYiArPSBcIndcIik7XG4gIHJldHVybiBiO1xufSwgT2IgPSAoYSwgYikgPT4ge1xuICBpZiAoSmIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoIWIuaW5jbHVkZXMoXCJyXCIpIHx8IGEubW9kZSAmIDI5Mikge1xuICAgIGlmIChiLmluY2x1ZGVzKFwid1wiKSAmJiAhKGEubW9kZSAmIDE0NikgfHwgYi5pbmNsdWRlcyhcInhcIikgJiYgIShhLm1vZGUgJiA3MykpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gMDtcbn0sIFJiID0gKGEsIGIpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gQ2IoYSwgYiksIDIwO1xuICB9IGNhdGNoIChjKSB7XG4gIH1cbiAgcmV0dXJuIE9iKGEsIFwid3hcIik7XG59LCBTYiA9ICgpID0+IHtcbiAgZm9yICh2YXIgYSA9IDA7IDQwOTYgPj0gYTsgYSsrKSB7XG4gICAgaWYgKCFHYlthXSkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBPKDMzKTtcbn0sIFRiID0gYSA9PiB7XG4gIGEgPSBHYlthXTtcbiAgaWYgKCFhKSB7XG4gICAgdGhyb3cgbmV3IE8oOCk7XG4gIH1cbiAgcmV0dXJuIGE7XG59LCBWYiA9IChhLCBiID0gLTEpID0+IHtcbiAgVWIgfHwgKFViID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oID0ge307XG4gIH0sIFViLnByb3RvdHlwZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhVYi5wcm90b3R5cGUsIHtvYmplY3Q6e2dldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9LCBzZXQoYykge1xuICAgIHRoaXMubm9kZSA9IGM7XG4gIH19LCBmbGFnczp7Z2V0KCkge1xuICAgIHJldHVybiB0aGlzLmguZmxhZ3M7XG4gIH0sIHNldChjKSB7XG4gICAgdGhpcy5oLmZsYWdzID0gYztcbiAgfSx9LCBwb3NpdGlvbjp7Z2V0KCkge1xuICAgIHJldHVybiB0aGlzLmgucG9zaXRpb247XG4gIH0sIHNldChjKSB7XG4gICAgdGhpcy5oLnBvc2l0aW9uID0gYztcbiAgfSx9LH0pKTtcbiAgYSA9IE9iamVjdC5hc3NpZ24obmV3IFViKCksIGEpO1xuICAtMSA9PSBiICYmIChiID0gU2IoKSk7XG4gIGEuWCA9IGI7XG4gIHJldHVybiBHYltiXSA9IGE7XG59LCB6YiA9IHtvcGVuOmEgPT4ge1xuICBhLm0gPSBGYlthLm5vZGUuemFdLm07XG4gIGEubS5vcGVuICYmIGEubS5vcGVuKGEpO1xufSwgYmE6KCkgPT4ge1xuICB0aHJvdyBuZXcgTyg3MCk7XG59LH0sIHViID0gKGEsIGIpID0+IHtcbiAgRmJbYV0gPSB7bTpifTtcbn0sIFdiID0gKGEsIGIpID0+IHtcbiAgdmFyIGMgPSBcIi9cIiA9PT0gYiwgZCA9ICFiO1xuICBpZiAoYyAmJiBFYikge1xuICAgIHRocm93IG5ldyBPKDEwKTtcbiAgfVxuICBpZiAoIWMgJiYgIWQpIHtcbiAgICB2YXIgZSA9IExiKGIsIHtnYjohMX0pO1xuICAgIGIgPSBlLnBhdGg7XG4gICAgZSA9IGUubm9kZTtcbiAgICBpZiAoZS53YSkge1xuICAgICAgdGhyb3cgbmV3IE8oMTApO1xuICAgIH1cbiAgICBpZiAoMTYzODQgIT09IChlLm1vZGUgJiA2MTQ0MCkpIHtcbiAgICAgIHRocm93IG5ldyBPKDU0KTtcbiAgICB9XG4gIH1cbiAgYiA9IHt0eXBlOmEsIFFjOnt9LCBtYjpiLCBrYzpbXX07XG4gIGEgPSBhLlUoYik7XG4gIGEuVSA9IGI7XG4gIGIucm9vdCA9IGE7XG4gIGMgPyBFYiA9IGEgOiBlICYmIChlLndhID0gYiwgZS5VICYmIGUuVS5rYy5wdXNoKGIpKTtcbn0sIFMgPSAoYSwgYiwgYykgPT4ge1xuICB2YXIgZCA9IExiKGEsIHtwYXJlbnQ6ITB9KS5ub2RlO1xuICBhID0gaWIoYSk7XG4gIGlmICghYSB8fCBcIi5cIiA9PT0gYSB8fCBcIi4uXCIgPT09IGEpIHtcbiAgICB0aHJvdyBuZXcgTygyOCk7XG4gIH1cbiAgdmFyIGUgPSBSYihkLCBhKTtcbiAgaWYgKGUpIHtcbiAgICB0aHJvdyBuZXcgTyhlKTtcbiAgfVxuICBpZiAoIWQubC52YSkge1xuICAgIHRocm93IG5ldyBPKDYzKTtcbiAgfVxuICByZXR1cm4gZC5sLnZhKGQsIGEsIGIsIGMpO1xufSwgWGIgPSAoYSwgYiwgYykgPT4ge1xuICBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBjICYmIChjID0gYiwgYiA9IDQzOCk7XG4gIFMoYSwgYiB8IDgxOTIsIGMpO1xufSwgY2MgPSAoYSwgYikgPT4ge1xuICBpZiAoIWxiKGEpKSB7XG4gICAgdGhyb3cgbmV3IE8oNDQpO1xuICB9XG4gIHZhciBjID0gTGIoYiwge3BhcmVudDohMH0pLm5vZGU7XG4gIGlmICghYykge1xuICAgIHRocm93IG5ldyBPKDQ0KTtcbiAgfVxuICBiID0gaWIoYik7XG4gIHZhciBkID0gUmIoYywgYik7XG4gIGlmIChkKSB7XG4gICAgdGhyb3cgbmV3IE8oZCk7XG4gIH1cbiAgaWYgKCFjLmwuRWEpIHtcbiAgICB0aHJvdyBuZXcgTyg2Myk7XG4gIH1cbiAgYy5sLkVhKGMsIGIsIGEpO1xufSwgS2IgPSBhID0+IHtcbiAgYSA9IExiKGEpLm5vZGU7XG4gIGlmICghYSkge1xuICAgIHRocm93IG5ldyBPKDQ0KTtcbiAgfVxuICBpZiAoIWEubC5tYSkge1xuICAgIHRocm93IG5ldyBPKDI4KTtcbiAgfVxuICByZXR1cm4gbGIoTWIoYS5wYXJlbnQpLCBhLmwubWEoYSkpO1xufSwgZWMgPSAoYSwgYiwgYykgPT4ge1xuICBpZiAoXCJcIiA9PT0gYSkge1xuICAgIHRocm93IG5ldyBPKDQ0KTtcbiAgfVxuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgYikge1xuICAgIHZhciBkID0ge3I6MCwgXCJyK1wiOjIsIHc6NTc3LCBcIncrXCI6NTc4LCBhOjEwODksIFwiYStcIjoxMDkwLH1bYl07XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGQpIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmtub3duIGZpbGUgb3BlbiBtb2RlOiAke2J9YCk7XG4gICAgfVxuICAgIGIgPSBkO1xuICB9XG4gIGMgPSBiICYgNjQgPyAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgYyA/IDQzOCA6IGMpICYgNDA5NSB8IDMyNzY4IDogMDtcbiAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGEpIHtcbiAgICB2YXIgZSA9IGE7XG4gIH0gZWxzZSB7XG4gICAgYSA9IGdiKGEpO1xuICAgIHRyeSB7XG4gICAgICBlID0gTGIoYSwge2ZiOiEoYiAmIDEzMTA3Mil9KS5ub2RlO1xuICAgIH0gY2F0Y2ggKGYpIHtcbiAgICB9XG4gIH1cbiAgZCA9ICExO1xuICBpZiAoYiAmIDY0KSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIGlmIChiICYgMTI4KSB7XG4gICAgICAgIHRocm93IG5ldyBPKDIwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZSA9IFMoYSwgYywgMCksIGQgPSAhMDtcbiAgICB9XG4gIH1cbiAgaWYgKCFlKSB7XG4gICAgdGhyb3cgbmV3IE8oNDQpO1xuICB9XG4gIDgxOTIgPT09IChlLm1vZGUgJiA2MTQ0MCkgJiYgKGIgJj0gLTUxMyk7XG4gIGlmIChiICYgNjU1MzYgJiYgMTYzODQgIT09IChlLm1vZGUgJiA2MTQ0MCkpIHtcbiAgICB0aHJvdyBuZXcgTyg1NCk7XG4gIH1cbiAgaWYgKCFkICYmIChjID0gZSA/IDQwOTYwID09PSAoZS5tb2RlICYgNjE0NDApID8gMzIgOiAxNjM4NCA9PT0gKGUubW9kZSAmIDYxNDQwKSAmJiAoXCJyXCIgIT09IFFiKGIpIHx8IGIgJiA1MTIpID8gMzEgOiBPYihlLCBRYihiKSkgOiA0NCkpIHtcbiAgICB0aHJvdyBuZXcgTyhjKTtcbiAgfVxuICBpZiAoYiAmIDUxMiAmJiAhZCkge1xuICAgIGMgPSBlO1xuICAgIGMgPSBcInN0cmluZ1wiID09IHR5cGVvZiBjID8gTGIoYywge2ZiOiEwfSkubm9kZSA6IGM7XG4gICAgaWYgKCFjLmwuUCkge1xuICAgICAgdGhyb3cgbmV3IE8oNjMpO1xuICAgIH1cbiAgICBpZiAoMTYzODQgPT09IChjLm1vZGUgJiA2MTQ0MCkpIHtcbiAgICAgIHRocm93IG5ldyBPKDMxKTtcbiAgICB9XG4gICAgaWYgKDMyNzY4ICE9PSAoYy5tb2RlICYgNjE0NDApKSB7XG4gICAgICB0aHJvdyBuZXcgTygyOCk7XG4gICAgfVxuICAgIGlmIChkID0gT2IoYywgXCJ3XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgTyhkKTtcbiAgICB9XG4gICAgYy5sLlAoYywge3NpemU6MCwgdGltZXN0YW1wOkRhdGUubm93KCl9KTtcbiAgfVxuICBiICY9IC0xMzE3MTM7XG4gIGUgPSBWYih7bm9kZTplLCBwYXRoOk1iKGUpLCBmbGFnczpiLCBzZWVrYWJsZTohMCwgcG9zaXRpb246MCwgbTplLm0sIHpjOltdLCBlcnJvcjohMX0pO1xuICBlLm0ub3BlbiAmJiBlLm0ub3BlbihlKTtcbiAgIW0ubG9nUmVhZEZpbGVzIHx8IGIgJiAxIHx8IChkYyB8fCAoZGMgPSB7fSksIGEgaW4gZGMgfHwgKGRjW2FdID0gMSkpO1xuICByZXR1cm4gZTtcbn0sIGZjID0gKGEsIGIsIGMpID0+IHtcbiAgaWYgKG51bGwgPT09IGEuWCkge1xuICAgIHRocm93IG5ldyBPKDgpO1xuICB9XG4gIGlmICghYS5zZWVrYWJsZSB8fCAhYS5tLmJhKSB7XG4gICAgdGhyb3cgbmV3IE8oNzApO1xuICB9XG4gIGlmICgwICE9IGMgJiYgMSAhPSBjICYmIDIgIT0gYykge1xuICAgIHRocm93IG5ldyBPKDI4KTtcbiAgfVxuICBhLnBvc2l0aW9uID0gYS5tLmJhKGEsIGIsIGMpO1xuICBhLnpjID0gW107XG59LCBnYyA9ICgpID0+IHtcbiAgTyB8fCAoTyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB0aGlzLm5hbWUgPSBcIkVycm5vRXJyb3JcIjtcbiAgICB0aGlzLm5vZGUgPSBiO1xuICAgIHRoaXMucGMgPSBmdW5jdGlvbihjKSB7XG4gICAgICB0aGlzLmFhID0gYztcbiAgICB9O1xuICAgIHRoaXMucGMoYSk7XG4gICAgdGhpcy5tZXNzYWdlID0gXCJGUyBlcnJvclwiO1xuICB9LCBPLnByb3RvdHlwZSA9IEVycm9yKCksIE8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTywgWzQ0XS5mb3JFYWNoKGEgPT4ge1xuICAgIEJiW2FdID0gbmV3IE8oYSk7XG4gICAgQmJbYV0uc3RhY2sgPSBcIjxnZW5lcmljIGVycm9yLCBubyBzdGFjaz5cIjtcbiAgfSkpO1xufSwgaGMsIGpjID0gKGEsIGIsIGMpID0+IHtcbiAgYSA9IGdiKFwiL2Rldi9cIiArIGEpO1xuICB2YXIgZCA9IERiKCEhYiwgISFjKTtcbiAgaWMgfHwgKGljID0gNjQpO1xuICB2YXIgZSA9IGljKysgPDwgOCB8IDA7XG4gIHViKGUsIHtvcGVuOmYgPT4ge1xuICAgIGYuc2Vla2FibGUgPSAhMTtcbiAgfSwgY2xvc2U6KCkgPT4ge1xuICAgIGMgJiYgYy5idWZmZXIgJiYgYy5idWZmZXIubGVuZ3RoICYmIGMoMTApO1xuICB9LCByZWFkOihmLCBnLCBuLCBwKSA9PiB7XG4gICAgZm9yICh2YXIgbCA9IDAsIHUgPSAwOyB1IDwgcDsgdSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdiA9IGIoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IE8oMjkpO1xuICAgICAgfVxuICAgICAgaWYgKHZvaWQgMCA9PT0gdiAmJiAwID09PSBsKSB7XG4gICAgICAgIHRocm93IG5ldyBPKDYpO1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgPT09IHYgfHwgdm9pZCAwID09PSB2KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbCsrO1xuICAgICAgZ1tuICsgdV0gPSB2O1xuICAgIH1cbiAgICBsICYmIChmLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKSk7XG4gICAgcmV0dXJuIGw7XG4gIH0sIHdyaXRlOihmLCBnLCBuLCBwKSA9PiB7XG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBwOyBsKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGMoZ1tuICsgbF0pO1xuICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICB0aHJvdyBuZXcgTygyOSk7XG4gICAgICB9XG4gICAgfVxuICAgIHAgJiYgKGYubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpKTtcbiAgICByZXR1cm4gbDtcbiAgfX0pO1xuICBYYihhLCBkLCBlKTtcbn0sIGljLCBrYyA9IHt9LCBVYiwgZGMsIGxjID0gdm9pZCAwO1xuZnVuY3Rpb24gbWMoKSB7XG4gIGxjICs9IDQ7XG4gIHJldHVybiBMW2xjIC0gNCA+PiAyXTtcbn1cbmZ1bmN0aW9uIG5jKGEpIHtcbiAgaWYgKHZvaWQgMCA9PT0gYSkge1xuICAgIHJldHVybiBcIl91bmtub3duXCI7XG4gIH1cbiAgYSA9IGEucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCBcIiRcIik7XG4gIHZhciBiID0gYS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gNDggPD0gYiAmJiA1NyA+PSBiID8gYF8ke2F9YCA6IGE7XG59XG5mdW5jdGlvbiBvYyhhLCBiKSB7XG4gIGEgPSBuYyhhKTtcbiAgcmV0dXJuIHtbYV06ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfX1bYV07XG59XG5mdW5jdGlvbiBwYygpIHtcbiAgdGhpcy5NID0gW3ZvaWQgMF07XG4gIHRoaXMuaGIgPSBbXTtcbn1cbnZhciBVID0gbmV3IHBjKCksIHFjID0gdm9pZCAwO1xuZnVuY3Rpb24gVihhKSB7XG4gIHRocm93IG5ldyBxYyhhKTtcbn1cbnZhciByYyA9IGEgPT4ge1xuICBhIHx8IFYoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIiArIGEpO1xuICByZXR1cm4gVS5nZXQoYSkudmFsdWU7XG59LCBzYyA9IGEgPT4ge1xuICBzd2l0Y2goYSkge1xuICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBudWxsOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAhMDpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgITE6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFUucGEoe3RiOjEsIHZhbHVlOmF9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRjKGEpIHtcbiAgdmFyIGIgPSBFcnJvciwgYyA9IG9jKGEsIGZ1bmN0aW9uKGQpIHtcbiAgICB0aGlzLm5hbWUgPSBhO1xuICAgIHRoaXMubWVzc2FnZSA9IGQ7XG4gICAgZCA9IEVycm9yKGQpLnN0YWNrO1xuICAgIHZvaWQgMCAhPT0gZCAmJiAodGhpcy5zdGFjayA9IHRoaXMudG9TdHJpbmcoKSArIFwiXFxuXCIgKyBkLnJlcGxhY2UoL15FcnJvcig6W15cXG5dKik/XFxuLywgXCJcIikpO1xuICB9KTtcbiAgYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGIucHJvdG90eXBlKTtcbiAgYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjO1xuICBjLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2b2lkIDAgPT09IHRoaXMubWVzc2FnZSA/IHRoaXMubmFtZSA6IGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWA7XG4gIH07XG4gIHJldHVybiBjO1xufVxudmFyIHVjID0gdm9pZCAwLCB2YyA9IHZvaWQgMDtcbmZ1bmN0aW9uIFcoYSkge1xuICBmb3IgKHZhciBiID0gXCJcIjsgRVthXTspIHtcbiAgICBiICs9IHZjW0VbYSsrXV07XG4gIH1cbiAgcmV0dXJuIGI7XG59XG52YXIgd2MgPSBbXTtcbmZ1bmN0aW9uIHhjKCkge1xuICBmb3IgKDsgd2MubGVuZ3RoOykge1xuICAgIHZhciBhID0gd2MucG9wKCk7XG4gICAgYS5nLmZhID0gITE7XG4gICAgYVtcImRlbGV0ZVwiXSgpO1xuICB9XG59XG52YXIgeWMgPSB2b2lkIDAsIHpjID0ge307XG5mdW5jdGlvbiBBYyhhLCBiKSB7XG4gIGZvciAodm9pZCAwID09PSBiICYmIFYoXCJwdHIgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWRcIik7IGEuQTspIHtcbiAgICBiID0gYS5uYShiKSwgYSA9IGEuQTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbnZhciBCYyA9IHt9O1xuZnVuY3Rpb24gQ2MoYSkge1xuICBhID0gRGMoYSk7XG4gIHZhciBiID0gVyhhKTtcbiAgRWMoYSk7XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gRmMoYSwgYikge1xuICB2YXIgYyA9IEJjW2FdO1xuICB2b2lkIDAgPT09IGMgJiYgVihiICsgXCIgaGFzIHVua25vd24gdHlwZSBcIiArIENjKGEpKTtcbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBHYygpIHtcbn1cbnZhciBIYyA9ICExO1xuZnVuY3Rpb24gSWMoYSkge1xuICAtLWEuY291bnQudmFsdWU7XG4gIDAgPT09IGEuY291bnQudmFsdWUgJiYgKGEuRyA/IGEuTC5XKGEuRykgOiBhLnUuaS5XKGEubykpO1xufVxuZnVuY3Rpb24gSmMoYSwgYiwgYykge1xuICBpZiAoYiA9PT0gYykge1xuICAgIHJldHVybiBhO1xuICB9XG4gIGlmICh2b2lkIDAgPT09IGMuQSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGEgPSBKYyhhLCBiLCBjLkEpO1xuICByZXR1cm4gbnVsbCA9PT0gYSA/IG51bGwgOiBjLlBiKGEpO1xufVxudmFyIEtjID0ge307XG5mdW5jdGlvbiBMYyhhLCBiKSB7XG4gIGIgPSBBYyhhLCBiKTtcbiAgcmV0dXJuIHpjW2JdO1xufVxudmFyIE1jID0gdm9pZCAwO1xuZnVuY3Rpb24gTmMoYSkge1xuICB0aHJvdyBuZXcgTWMoYSk7XG59XG5mdW5jdGlvbiBPYyhhLCBiKSB7XG4gIGIudSAmJiBiLm8gfHwgTmMoXCJtYWtlQ2xhc3NIYW5kbGUgcmVxdWlyZXMgcHRyIGFuZCBwdHJUeXBlXCIpO1xuICAhIWIuTCAhPT0gISFiLkcgJiYgTmMoXCJCb3RoIHNtYXJ0UHRyVHlwZSBhbmQgc21hcnRQdHIgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gIGIuY291bnQgPSB7dmFsdWU6MX07XG4gIHJldHVybiBQYyhPYmplY3QuY3JlYXRlKGEsIHtnOnt2YWx1ZTpiLH0sfSkpO1xufVxuZnVuY3Rpb24gUGMoYSkge1xuICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5KSB7XG4gICAgcmV0dXJuIFBjID0gYiA9PiBiLCBhO1xuICB9XG4gIEhjID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KGIgPT4ge1xuICAgIEljKGIuZyk7XG4gIH0pO1xuICBQYyA9IGIgPT4ge1xuICAgIHZhciBjID0gYi5nO1xuICAgIGMuRyAmJiBIYy5yZWdpc3RlcihiLCB7ZzpjfSwgYik7XG4gICAgcmV0dXJuIGI7XG4gIH07XG4gIEdjID0gYiA9PiB7XG4gICAgSGMudW5yZWdpc3RlcihiKTtcbiAgfTtcbiAgcmV0dXJuIFBjKGEpO1xufVxudmFyIFFjID0ge307XG5mdW5jdGlvbiBSYyhhKSB7XG4gIGZvciAoOyBhLmxlbmd0aDspIHtcbiAgICB2YXIgYiA9IGEucG9wKCk7XG4gICAgYS5wb3AoKShiKTtcbiAgfVxufVxuZnVuY3Rpb24gU2MoYSkge1xuICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoTFthID4+IDJdKTtcbn1cbnZhciBUYyA9IHt9LCBVYyA9IHt9O1xuZnVuY3Rpb24gWShhLCBiLCBjKSB7XG4gIGZ1bmN0aW9uIGQobikge1xuICAgIG4gPSBjKG4pO1xuICAgIG4ubGVuZ3RoICE9PSBhLmxlbmd0aCAmJiBOYyhcIk1pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnRcIik7XG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBhLmxlbmd0aDsgKytwKSB7XG4gICAgICBWYyhhW3BdLCBuW3BdKTtcbiAgICB9XG4gIH1cbiAgYS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBVY1tuXSA9IGI7XG4gIH0pO1xuICB2YXIgZSA9IEFycmF5KGIubGVuZ3RoKSwgZiA9IFtdLCBnID0gMDtcbiAgYi5mb3JFYWNoKChuLCBwKSA9PiB7XG4gICAgQmMuaGFzT3duUHJvcGVydHkobikgPyBlW3BdID0gQmNbbl0gOiAoZi5wdXNoKG4pLCBUYy5oYXNPd25Qcm9wZXJ0eShuKSB8fCAoVGNbbl0gPSBbXSksIFRjW25dLnB1c2goKCkgPT4ge1xuICAgICAgZVtwXSA9IEJjW25dO1xuICAgICAgKytnO1xuICAgICAgZyA9PT0gZi5sZW5ndGggJiYgZChlKTtcbiAgICB9KSk7XG4gIH0pO1xuICAwID09PSBmLmxlbmd0aCAmJiBkKGUpO1xufVxuZnVuY3Rpb24gV2MoYSkge1xuICBzd2l0Y2goYSkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiAzO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIHR5cGUgc2l6ZTogJHthfWApO1xuICB9XG59XG5mdW5jdGlvbiBYYyhhLCBiLCBjID0ge30pIHtcbiAgdmFyIGQgPSBiLm5hbWU7XG4gIGEgfHwgVihgdHlwZSBcIiR7ZH1cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7XG4gIGlmIChCYy5oYXNPd25Qcm9wZXJ0eShhKSkge1xuICAgIGlmIChjLiRiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFYoYENhbm5vdCByZWdpc3RlciB0eXBlICcke2R9JyB0d2ljZWApO1xuICB9XG4gIEJjW2FdID0gYjtcbiAgZGVsZXRlIFVjW2FdO1xuICBUYy5oYXNPd25Qcm9wZXJ0eShhKSAmJiAoYiA9IFRjW2FdLCBkZWxldGUgVGNbYV0sIGIuZm9yRWFjaChlID0+IGUoKSkpO1xufVxuZnVuY3Rpb24gVmMoYSwgYiwgYyA9IHt9KSB7XG4gIGlmICghKFwiYXJnUGFja0FkdmFuY2VcIiBpbiBiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlXCIpO1xuICB9XG4gIFhjKGEsIGIsIGMpO1xufVxuZnVuY3Rpb24gWWMoYSkge1xuICBWKGEuZy51LmkubmFtZSArIFwiIGluc3RhbmNlIGFscmVhZHkgZGVsZXRlZFwiKTtcbn1cbmZ1bmN0aW9uIFpjKCkge1xufVxuZnVuY3Rpb24gJGMoYSwgYiwgYykge1xuICBpZiAodm9pZCAwID09PSBhW2JdLkIpIHtcbiAgICB2YXIgZCA9IGFbYl07XG4gICAgYVtiXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgYVtiXS5CLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpIHx8IFYoYEZ1bmN0aW9uICcke2N9JyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCR7YXJndW1lbnRzLmxlbmd0aH0pIC0gZXhwZWN0cyBvbmUgb2YgKCR7YVtiXS5CfSkhYCk7XG4gICAgICByZXR1cm4gYVtiXS5CW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBhW2JdLkIgPSBbXTtcbiAgICBhW2JdLkJbZC5lYV0gPSBkO1xuICB9XG59XG5mdW5jdGlvbiBhZChhLCBiLCBjKSB7XG4gIG0uaGFzT3duUHJvcGVydHkoYSkgPyAoKHZvaWQgMCA9PT0gYyB8fCB2b2lkIDAgIT09IG1bYV0uQiAmJiB2b2lkIDAgIT09IG1bYV0uQltjXSkgJiYgVihgQ2Fubm90IHJlZ2lzdGVyIHB1YmxpYyBuYW1lICcke2F9JyB0d2ljZWApLCAkYyhtLCBhLCBhKSwgbS5oYXNPd25Qcm9wZXJ0eShjKSAmJiBWKGBDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICgke2N9KSFgKSwgbVthXS5CW2NdID0gYikgOiAobVthXSA9IGIsIHZvaWQgMCAhPT0gYyAmJiAobVthXS5QYyA9IGMpKTtcbn1cbmZ1bmN0aW9uIGJkKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4pIHtcbiAgdGhpcy5uYW1lID0gYTtcbiAgdGhpcy5jb25zdHJ1Y3RvciA9IGI7XG4gIHRoaXMuTiA9IGM7XG4gIHRoaXMuVyA9IGQ7XG4gIHRoaXMuQSA9IGU7XG4gIHRoaXMuVWIgPSBmO1xuICB0aGlzLm5hID0gZztcbiAgdGhpcy5QYiA9IG47XG4gIHRoaXMucWIgPSBbXTtcbn1cbmZ1bmN0aW9uIGNkKGEsIGIsIGMpIHtcbiAgZm9yICg7IGIgIT09IGM7KSB7XG4gICAgYi5uYSB8fCBWKGBFeHBlY3RlZCBudWxsIG9yIGluc3RhbmNlIG9mICR7Yy5uYW1lfSwgZ290IGFuIGluc3RhbmNlIG9mICR7Yi5uYW1lfWApLCBhID0gYi5uYShhKSwgYiA9IGIuQTtcbiAgfVxuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGRkKGEsIGIpIHtcbiAgaWYgKG51bGwgPT09IGIpIHtcbiAgICByZXR1cm4gdGhpcy5OYSAmJiBWKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApLCAwO1xuICB9XG4gIGIuZyB8fCBWKGBDYW5ub3QgcGFzcyBcIiR7ZWQoYil9XCIgYXMgYSAke3RoaXMubmFtZX1gKTtcbiAgYi5nLm8gfHwgVihgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gIHJldHVybiBjZChiLmcubywgYi5nLnUuaSwgdGhpcy5pKTtcbn1cbmZ1bmN0aW9uIGZkKGEsIGIpIHtcbiAgaWYgKG51bGwgPT09IGIpIHtcbiAgICB0aGlzLk5hICYmIFYoYG51bGwgaXMgbm90IGEgdmFsaWQgJHt0aGlzLm5hbWV9YCk7XG4gICAgaWYgKHRoaXMudWEpIHtcbiAgICAgIHZhciBjID0gdGhpcy5QYSgpO1xuICAgICAgbnVsbCAhPT0gYSAmJiBhLnB1c2godGhpcy5XLCBjKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBiLmcgfHwgVihgQ2Fubm90IHBhc3MgXCIke2VkKGIpfVwiIGFzIGEgJHt0aGlzLm5hbWV9YCk7XG4gIGIuZy5vIHx8IFYoYENhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAhdGhpcy50YSAmJiBiLmcudS50YSAmJiBWKGBDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICR7Yi5nLkwgPyBiLmcuTC5uYW1lIDogYi5nLnUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gIGMgPSBjZChiLmcubywgYi5nLnUuaSwgdGhpcy5pKTtcbiAgaWYgKHRoaXMudWEpIHtcbiAgICBzd2l0Y2godm9pZCAwID09PSBiLmcuRyAmJiBWKFwiUGFzc2luZyByYXcgcG9pbnRlciB0byBzbWFydCBwb2ludGVyIGlzIGlsbGVnYWxcIiksIHRoaXMudGMpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgYi5nLkwgPT09IHRoaXMgPyBjID0gYi5nLkcgOiBWKGBDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICR7Yi5nLkwgPyBiLmcuTC5uYW1lIDogYi5nLnUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjID0gYi5nLkc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAoYi5nLkwgPT09IHRoaXMpIHtcbiAgICAgICAgICBjID0gYi5nLkc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGQgPSBiLmNsb25lKCk7XG4gICAgICAgICAgYyA9IHRoaXMub2MoYywgc2MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkW1wiZGVsZXRlXCJdKCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIG51bGwgIT09IGEgJiYgYS5wdXNoKHRoaXMuVywgYyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBWKFwiVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5XCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGdkKGEsIGIpIHtcbiAgaWYgKG51bGwgPT09IGIpIHtcbiAgICByZXR1cm4gdGhpcy5OYSAmJiBWKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApLCAwO1xuICB9XG4gIGIuZyB8fCBWKGBDYW5ub3QgcGFzcyBcIiR7ZWQoYil9XCIgYXMgYSAke3RoaXMubmFtZX1gKTtcbiAgYi5nLm8gfHwgVihgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCk7XG4gIGIuZy51LnRhICYmIFYoYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHtiLmcudS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgcmV0dXJuIGNkKGIuZy5vLCBiLmcudS5pLCB0aGlzLmkpO1xufVxuZnVuY3Rpb24gaGQoYSwgYiwgYywgZCkge1xuICB0aGlzLm5hbWUgPSBhO1xuICB0aGlzLmkgPSBiO1xuICB0aGlzLk5hID0gYztcbiAgdGhpcy50YSA9IGQ7XG4gIHRoaXMudWEgPSAhMTtcbiAgdGhpcy5XID0gdGhpcy5vYyA9IHRoaXMuUGEgPSB0aGlzLnJiID0gdGhpcy50YyA9IHRoaXMubmMgPSB2b2lkIDA7XG4gIHZvaWQgMCAhPT0gYi5BID8gdGhpcy50b1dpcmVUeXBlID0gZmQgOiAodGhpcy50b1dpcmVUeXBlID0gZCA/IGRkIDogZ2QsIHRoaXMuSyA9IG51bGwpO1xufVxuZnVuY3Rpb24gamQoYSwgYiwgYykge1xuICBtLmhhc093blByb3BlcnR5KGEpIHx8IE5jKFwiUmVwbGFjaW5nIG5vbmV4aXN0YW50IHB1YmxpYyBzeW1ib2xcIik7XG4gIHZvaWQgMCAhPT0gbVthXS5CICYmIHZvaWQgMCAhPT0gYyA/IG1bYV0uQltjXSA9IGIgOiAobVthXSA9IGIsIG1bYV0uZWEgPSBjKTtcbn1cbnZhciBrZCA9IFtdLCBsZCA9IGEgPT4ge1xuICB2YXIgYiA9IGtkW2FdO1xuICBiIHx8IChhID49IGtkLmxlbmd0aCAmJiAoa2QubGVuZ3RoID0gYSArIDEpLCBrZFthXSA9IGIgPSBLYS5nZXQoYSkpO1xuICByZXR1cm4gYjtcbn0sIG1kID0gKGEsIGIpID0+IHtcbiAgdmFyIGMgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGMubGVuZ3RoID0gMDtcbiAgICBPYmplY3QuYXNzaWduKGMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEuaW5jbHVkZXMoXCJqXCIpKSB7XG4gICAgICB2YXIgZCA9IG1bXCJkeW5DYWxsX1wiICsgYV07XG4gICAgICBkID0gYyAmJiBjLmxlbmd0aCA/IGQuYXBwbHkobnVsbCwgW2JdLmNvbmNhdChjKSkgOiBkLmNhbGwobnVsbCwgYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBsZChiKS5hcHBseShudWxsLCBjKTtcbiAgICB9XG4gICAgcmV0dXJuIGQ7XG4gIH07XG59O1xuZnVuY3Rpb24gWihhLCBiKSB7XG4gIGEgPSBXKGEpO1xuICB2YXIgYyA9IGEuaW5jbHVkZXMoXCJqXCIpID8gbWQoYSwgYikgOiBsZChiKTtcbiAgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjICYmIFYoYHVua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSAke2F9OiAke2J9YCk7XG4gIHJldHVybiBjO1xufVxudmFyIG5kID0gdm9pZCAwO1xuZnVuY3Rpb24gb2QoYSwgYikge1xuICBmdW5jdGlvbiBjKGYpIHtcbiAgICBlW2ZdIHx8IEJjW2ZdIHx8IChVY1tmXSA/IFVjW2ZdLmZvckVhY2goYykgOiAoZC5wdXNoKGYpLCBlW2ZdID0gITApKTtcbiAgfVxuICB2YXIgZCA9IFtdLCBlID0ge307XG4gIGIuZm9yRWFjaChjKTtcbiAgdGhyb3cgbmV3IG5kKGAke2F9OiBgICsgZC5tYXAoQ2MpLmpvaW4oW1wiLCBcIl0pKTtcbn1cbmZ1bmN0aW9uIHBkKGEsIGIsIGMsIGQsIGUpIHtcbiAgdmFyIGYgPSBiLmxlbmd0aDtcbiAgMiA+IGYgJiYgVihcImFyZ1R5cGVzIGFycmF5IHNpemUgbWlzbWF0Y2ghIE11c3QgYXQgbGVhc3QgZ2V0IHJldHVybiB2YWx1ZSBhbmQgJ3RoaXMnIHR5cGVzIVwiKTtcbiAgdmFyIGcgPSBudWxsICE9PSBiWzFdICYmIG51bGwgIT09IGMsIG4gPSAhMTtcbiAgZm9yIChjID0gMTsgYyA8IGIubGVuZ3RoOyArK2MpIHtcbiAgICBpZiAobnVsbCAhPT0gYltjXSAmJiB2b2lkIDAgPT09IGJbY10uSykge1xuICAgICAgbiA9ICEwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBwID0gXCJ2b2lkXCIgIT09IGJbMF0ubmFtZSwgbCA9IGYgLSAyLCB1ID0gQXJyYXkobCksIHYgPSBbXSwgeCA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgYXJndW1lbnRzLmxlbmd0aCAhPT0gbCAmJiBWKGBmdW5jdGlvbiAke2F9IGNhbGxlZCB3aXRoICR7YXJndW1lbnRzLmxlbmd0aH0gYXJndW1lbnRzLCBleHBlY3RlZCAke2x9IGFyZ3MhYCk7XG4gICAgeC5sZW5ndGggPSAwO1xuICAgIHYubGVuZ3RoID0gZyA/IDIgOiAxO1xuICAgIHZbMF0gPSBlO1xuICAgIGlmIChnKSB7XG4gICAgICB2YXIgayA9IGJbMV0udG9XaXJlVHlwZSh4LCB0aGlzKTtcbiAgICAgIHZbMV0gPSBrO1xuICAgIH1cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGw7ICsrdCkge1xuICAgICAgdVt0XSA9IGJbdCArIDJdLnRvV2lyZVR5cGUoeCwgYXJndW1lbnRzW3RdKSwgdi5wdXNoKHVbdF0pO1xuICAgIH1cbiAgICB0ID0gZC5hcHBseShudWxsLCB2KTtcbiAgICBpZiAobikge1xuICAgICAgUmMoeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHIgPSBnID8gMSA6IDI7IHIgPCBiLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHZhciBCID0gMSA9PT0gciA/IGsgOiB1W3IgLSAyXTtcbiAgICAgICAgbnVsbCAhPT0gYltyXS5LICYmIGJbcl0uSyhCKTtcbiAgICAgIH1cbiAgICB9XG4gICAgayA9IHAgPyBiWzBdLmZyb21XaXJlVHlwZSh0KSA6IHZvaWQgMDtcbiAgICByZXR1cm4gaztcbiAgfTtcbn1cbmZ1bmN0aW9uIHNkKGEsIGIpIHtcbiAgZm9yICh2YXIgYyA9IFtdLCBkID0gMDsgZCA8IGE7IGQrKykge1xuICAgIGMucHVzaChOW2IgKyA0ICogZCA+PiAyXSk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiB0ZChhLCBiLCBjKSB7XG4gIGEgaW5zdGFuY2VvZiBPYmplY3QgfHwgVihgJHtjfSB3aXRoIGludmFsaWQgXCJ0aGlzXCI6ICR7YX1gKTtcbiAgYSBpbnN0YW5jZW9mIGIuaS5jb25zdHJ1Y3RvciB8fCBWKGAke2N9IGluY29tcGF0aWJsZSB3aXRoIFwidGhpc1wiIG9mIHR5cGUgJHthLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIGEuZy5vIHx8IFYoYGNhbm5vdCBjYWxsIGVtc2NyaXB0ZW4gYmluZGluZyBtZXRob2QgJHtjfSBvbiBkZWxldGVkIG9iamVjdGApO1xuICByZXR1cm4gY2QoYS5nLm8sIGEuZy51LmksIGIuaSk7XG59XG5mdW5jdGlvbiB1ZChhKSB7XG4gIGEgPj0gVS5oICYmIDAgPT09IC0tVS5nZXQoYSkudGIgJiYgVS5aYihhKTtcbn1cbmZ1bmN0aW9uIHZkKGEsIGIsIGMpIHtcbiAgc3dpdGNoKGIpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoKGMgPyBDIDogRSlbZF0pO1xuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoKGMgPyBEYSA6IEVhKVtkID4+IDFdKTtcbiAgICAgIH07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKChjID8gTCA6IE4pW2QgPj4gMl0pO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gaW50ZWdlciB0eXBlOiBcIiArIGEpO1xuICB9XG59XG5mdW5jdGlvbiBlZChhKSB7XG4gIGlmIChudWxsID09PSBhKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIHZhciBiID0gdHlwZW9mIGE7XG4gIHJldHVybiBcIm9iamVjdFwiID09PSBiIHx8IFwiYXJyYXlcIiA9PT0gYiB8fCBcImZ1bmN0aW9uXCIgPT09IGIgPyBhLnRvU3RyaW5nKCkgOiBcIlwiICsgYTtcbn1cbmZ1bmN0aW9uIHdkKGEsIGIpIHtcbiAgc3dpdGNoKGIpIHtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoRmFbYyA+PiAyXSk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShJYVtjID4+IDNdKTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGZsb2F0IHR5cGU6IFwiICsgYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHhkKGEsIGIsIGMpIHtcbiAgc3dpdGNoKGIpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gYyA/IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIENbZF07XG4gICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gRVtkXTtcbiAgICAgIH07XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGMgPyBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBEYVtkID4+IDFdO1xuICAgICAgfSA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIEVhW2QgPj4gMV07XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBjID8gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gTFtkID4+IDJdO1xuICAgICAgfSA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIE5bZCA+PiAyXTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGludGVnZXIgdHlwZTogXCIgKyBhKTtcbiAgfVxufVxudmFyIHlkID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgVGV4dERlY29kZXIgPyBuZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiKSA6IHZvaWQgMCwgemQgPSAoYSwgYikgPT4ge1xuICB2YXIgYyA9IGEgPj4gMTtcbiAgZm9yICh2YXIgZCA9IGMgKyBiIC8gMjsgIShjID49IGQpICYmIEVhW2NdOykge1xuICAgICsrYztcbiAgfVxuICBjIDw8PSAxO1xuICBpZiAoMzIgPCBjIC0gYSAmJiB5ZCkge1xuICAgIHJldHVybiB5ZC5kZWNvZGUoRS5zdWJhcnJheShhLCBjKSk7XG4gIH1cbiAgYyA9IFwiXCI7XG4gIGZvciAoZCA9IDA7ICEoZCA+PSBiIC8gMik7ICsrZCkge1xuICAgIHZhciBlID0gRGFbYSArIDIgKiBkID4+IDFdO1xuICAgIGlmICgwID09IGUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZSk7XG4gIH1cbiAgcmV0dXJuIGM7XG59LCBBZCA9IChhLCBiLCBjKSA9PiB7XG4gIHZvaWQgMCA9PT0gYyAmJiAoYyA9IDIxNDc0ODM2NDcpO1xuICBpZiAoMiA+IGMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjIC09IDI7XG4gIHZhciBkID0gYjtcbiAgYyA9IGMgPCAyICogYS5sZW5ndGggPyBjIC8gMiA6IGEubGVuZ3RoO1xuICBmb3IgKHZhciBlID0gMDsgZSA8IGM7ICsrZSkge1xuICAgIERhW2IgPj4gMV0gPSBhLmNoYXJDb2RlQXQoZSksIGIgKz0gMjtcbiAgfVxuICBEYVtiID4+IDFdID0gMDtcbiAgcmV0dXJuIGIgLSBkO1xufSwgQmQgPSBhID0+IDIgKiBhLmxlbmd0aCwgQ2QgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBjID0gMCwgZCA9IFwiXCI7ICEoYyA+PSBiIC8gNCk7KSB7XG4gICAgdmFyIGUgPSBMW2EgKyA0ICogYyA+PiAyXTtcbiAgICBpZiAoMCA9PSBlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICAgIDY1NTM2IDw9IGUgPyAoZSAtPSA2NTUzNiwgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgZSA+PiAxMCwgNTYzMjAgfCBlICYgMTAyMykpIDogZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICB9XG4gIHJldHVybiBkO1xufSwgRGQgPSAoYSwgYiwgYykgPT4ge1xuICB2b2lkIDAgPT09IGMgJiYgKGMgPSAyMTQ3NDgzNjQ3KTtcbiAgaWYgKDQgPiBjKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIGQgPSBiO1xuICBjID0gZCArIGMgLSA0O1xuICBmb3IgKHZhciBlID0gMDsgZSA8IGEubGVuZ3RoOyArK2UpIHtcbiAgICB2YXIgZiA9IGEuY2hhckNvZGVBdChlKTtcbiAgICBpZiAoNTUyOTYgPD0gZiAmJiA1NzM0MyA+PSBmKSB7XG4gICAgICB2YXIgZyA9IGEuY2hhckNvZGVBdCgrK2UpO1xuICAgICAgZiA9IDY1NTM2ICsgKChmICYgMTAyMykgPDwgMTApIHwgZyAmIDEwMjM7XG4gICAgfVxuICAgIExbYiA+PiAyXSA9IGY7XG4gICAgYiArPSA0O1xuICAgIGlmIChiICsgNCA+IGMpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBMW2IgPj4gMl0gPSAwO1xuICByZXR1cm4gYiAtIGQ7XG59LCBFZCA9IGEgPT4ge1xuICBmb3IgKHZhciBiID0gMCwgYyA9IDA7IGMgPCBhLmxlbmd0aDsgKytjKSB7XG4gICAgdmFyIGQgPSBhLmNoYXJDb2RlQXQoYyk7XG4gICAgNTUyOTYgPD0gZCAmJiA1NzM0MyA+PSBkICYmICsrYztcbiAgICBiICs9IDQ7XG4gIH1cbiAgcmV0dXJuIGI7XG59LCBGZCA9IHt9O1xuZnVuY3Rpb24gR2QoYSkge1xuICB2YXIgYiA9IEZkW2FdO1xuICByZXR1cm4gdm9pZCAwID09PSBiID8gVyhhKSA6IGI7XG59XG52YXIgSGQgPSBbXTtcbmZ1bmN0aW9uIElkKGEpIHtcbiAgdmFyIGIgPSBIZC5sZW5ndGg7XG4gIEhkLnB1c2goYSk7XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gSmQoYSwgYikge1xuICBmb3IgKHZhciBjID0gQXJyYXkoYSksIGQgPSAwOyBkIDwgYTsgKytkKSB7XG4gICAgY1tkXSA9IEZjKE5bYiArIDQgKiBkID4+IDJdLCBcInBhcmFtZXRlciBcIiArIGQpO1xuICB9XG4gIHJldHVybiBjO1xufVxudmFyIEtkID0gW10sIExkID0gW10sIE1kID0ge30sIE9kID0gKCkgPT4ge1xuICBpZiAoIU5kKSB7XG4gICAgdmFyIGEgPSB7VVNFUjpcIndlYl91c2VyXCIsIExPR05BTUU6XCJ3ZWJfdXNlclwiLCBQQVRIOlwiL1wiLCBQV0Q6XCIvXCIsIEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLCBMQU5HOihcIm9iamVjdFwiID09IHR5cGVvZiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IFwiQ1wiKS5yZXBsYWNlKFwiLVwiLCBcIl9cIikgKyBcIi5VVEYtOFwiLCBfOm5hIHx8IFwiLi90aGlzLnByb2dyYW1cIn0sIGI7XG4gICAgZm9yIChiIGluIE1kKSB7XG4gICAgICB2b2lkIDAgPT09IE1kW2JdID8gZGVsZXRlIGFbYl0gOiBhW2JdID0gTWRbYl07XG4gICAgfVxuICAgIHZhciBjID0gW107XG4gICAgZm9yIChiIGluIGEpIHtcbiAgICAgIGMucHVzaChgJHtifT0ke2FbYl19YCk7XG4gICAgfVxuICAgIE5kID0gYztcbiAgfVxuICByZXR1cm4gTmQ7XG59LCBOZCwgUGQgPSBhID0+IDAgPT09IGEgJSA0ICYmICgwICE9PSBhICUgMTAwIHx8IDAgPT09IGEgJSA0MDApLCBRZCA9IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSwgUmQgPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sIFNkID0gKGEsIGIsIGMsIGQpID0+IHtcbiAgZnVuY3Rpb24gZShrLCB0LCByKSB7XG4gICAgZm9yIChrID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgayA/IGsudG9TdHJpbmcoKSA6IGsgfHwgXCJcIjsgay5sZW5ndGggPCB0Oykge1xuICAgICAgayA9IHJbMF0gKyBrO1xuICAgIH1cbiAgICByZXR1cm4gaztcbiAgfVxuICBmdW5jdGlvbiBmKGssIHQpIHtcbiAgICByZXR1cm4gZShrLCB0LCBcIjBcIik7XG4gIH1cbiAgZnVuY3Rpb24gZyhrLCB0KSB7XG4gICAgZnVuY3Rpb24gcihEKSB7XG4gICAgICByZXR1cm4gMCA+IEQgPyAtMSA6IDAgPCBEID8gMSA6IDA7XG4gICAgfVxuICAgIHZhciBCO1xuICAgIDAgPT09IChCID0gcihrLmdldEZ1bGxZZWFyKCkgLSB0LmdldEZ1bGxZZWFyKCkpKSAmJiAwID09PSAoQiA9IHIoay5nZXRNb250aCgpIC0gdC5nZXRNb250aCgpKSkgJiYgKEIgPSByKGsuZ2V0RGF0ZSgpIC0gdC5nZXREYXRlKCkpKTtcbiAgICByZXR1cm4gQjtcbiAgfVxuICBmdW5jdGlvbiBuKGspIHtcbiAgICBzd2l0Y2goay5nZXREYXkoKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gbmV3IERhdGUoay5nZXRGdWxsWWVhcigpIC0gMSwgMTEsIDI5KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShrLmdldEZ1bGxZZWFyKCksIDAsIDMpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gbmV3IERhdGUoay5nZXRGdWxsWWVhcigpLCAwLCAyKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGsuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShrLmdldEZ1bGxZZWFyKCkgLSAxLCAxMSwgMzEpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gbmV3IERhdGUoay5nZXRGdWxsWWVhcigpIC0gMSwgMTEsIDMwKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcChrKSB7XG4gICAgdmFyIHQgPSBrLmNhO1xuICAgIGZvciAoayA9IG5ldyBEYXRlKChuZXcgRGF0ZShrLmRhICsgMTkwMCwgMCwgMSkpLmdldFRpbWUoKSk7IDAgPCB0Oykge1xuICAgICAgdmFyIHIgPSBrLmdldE1vbnRoKCksIEIgPSAoUGQoay5nZXRGdWxsWWVhcigpKSA/IFFkIDogUmQpW3JdO1xuICAgICAgaWYgKHQgPiBCIC0gay5nZXREYXRlKCkpIHtcbiAgICAgICAgdCAtPSBCIC0gay5nZXREYXRlKCkgKyAxLCBrLnNldERhdGUoMSksIDExID4gciA/IGsuc2V0TW9udGgociArIDEpIDogKGsuc2V0TW9udGgoMCksIGsuc2V0RnVsbFllYXIoay5nZXRGdWxsWWVhcigpICsgMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgay5zZXREYXRlKGsuZ2V0RGF0ZSgpICsgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByID0gbmV3IERhdGUoay5nZXRGdWxsWWVhcigpICsgMSwgMCwgNCk7XG4gICAgdCA9IG4obmV3IERhdGUoay5nZXRGdWxsWWVhcigpLCAwLCA0KSk7XG4gICAgciA9IG4ocik7XG4gICAgcmV0dXJuIDAgPj0gZyh0LCBrKSA/IDAgPj0gZyhyLCBrKSA/IGsuZ2V0RnVsbFllYXIoKSArIDEgOiBrLmdldEZ1bGxZZWFyKCkgOiBrLmdldEZ1bGxZZWFyKCkgLSAxO1xuICB9XG4gIHZhciBsID0gTFtkICsgNDAgPj4gMl07XG4gIGQgPSB7d2M6TFtkID4+IDJdLCB2YzpMW2QgKyA0ID4+IDJdLCBGYTpMW2QgKyA4ID4+IDJdLCBTYTpMW2QgKyAxMiA+PiAyXSwgR2E6TFtkICsgMTYgPj4gMl0sIGRhOkxbZCArIDIwID4+IDJdLCBSOkxbZCArIDI0ID4+IDJdLCBjYTpMW2QgKyAyOCA+PiAyXSwgUmM6TFtkICsgMzIgPj4gMl0sIHVjOkxbZCArIDM2ID4+IDJdLCB4YzpsID8gbCA/IG5iKEUsIGwpIDogXCJcIiA6IFwiXCJ9O1xuICBjID0gYyA/IG5iKEUsIGMpIDogXCJcIjtcbiAgbCA9IHtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLCBcIiVEXCI6XCIlbS8lZC8leVwiLCBcIiVGXCI6XCIlWS0lbS0lZFwiLCBcIiVoXCI6XCIlYlwiLCBcIiVyXCI6XCIlSTolTTolUyAlcFwiLCBcIiVSXCI6XCIlSDolTVwiLCBcIiVUXCI6XCIlSDolTTolU1wiLCBcIiV4XCI6XCIlbS8lZC8leVwiLCBcIiVYXCI6XCIlSDolTTolU1wiLCBcIiVFY1wiOlwiJWNcIiwgXCIlRUNcIjpcIiVDXCIsIFwiJUV4XCI6XCIlbS8lZC8leVwiLCBcIiVFWFwiOlwiJUg6JU06JVNcIiwgXCIlRXlcIjpcIiV5XCIsIFwiJUVZXCI6XCIlWVwiLCBcIiVPZFwiOlwiJWRcIiwgXCIlT2VcIjpcIiVlXCIsIFwiJU9IXCI6XCIlSFwiLCBcIiVPSVwiOlwiJUlcIiwgXCIlT21cIjpcIiVtXCIsIFwiJU9NXCI6XCIlTVwiLCBcIiVPU1wiOlwiJVNcIiwgXCIlT3VcIjpcIiV1XCIsIFwiJU9VXCI6XCIlVVwiLCBcIiVPVlwiOlwiJVZcIiwgXCIlT3dcIjpcIiV3XCIsIFwiJU9XXCI6XCIlV1wiLCBcIiVPeVwiOlwiJXlcIix9O1xuICBmb3IgKHZhciB1IGluIGwpIHtcbiAgICBjID0gYy5yZXBsYWNlKG5ldyBSZWdFeHAodSwgXCJnXCIpLCBsW3VdKTtcbiAgfVxuICB2YXIgdiA9IFwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksIHggPSBcIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7XG4gIGwgPSB7XCIlYVwiOmsgPT4gdltrLlJdLnN1YnN0cmluZygwLCAzKSwgXCIlQVwiOmsgPT4gdltrLlJdLCBcIiViXCI6ayA9PiB4W2suR2FdLnN1YnN0cmluZygwLCAzKSwgXCIlQlwiOmsgPT4geFtrLkdhXSwgXCIlQ1wiOmsgPT4gZigoay5kYSArIDE5MDApIC8gMTAwIHwgMCwgMiksIFwiJWRcIjprID0+IGYoay5TYSwgMiksIFwiJWVcIjprID0+IGUoay5TYSwgMiwgXCIgXCIpLCBcIiVnXCI6ayA9PiBwKGspLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLCBcIiVHXCI6ayA9PiBwKGspLCBcIiVIXCI6ayA9PiBmKGsuRmEsIDIpLCBcIiVJXCI6ayA9PiB7XG4gICAgayA9IGsuRmE7XG4gICAgMCA9PSBrID8gayA9IDEyIDogMTIgPCBrICYmIChrIC09IDEyKTtcbiAgICByZXR1cm4gZihrLCAyKTtcbiAgfSwgXCIlalwiOmsgPT4ge1xuICAgIGZvciAodmFyIHQgPSAwLCByID0gMDsgciA8PSBrLkdhIC0gMTsgdCArPSAoUGQoay5kYSArIDE5MDApID8gUWQgOiBSZClbcisrXSkge1xuICAgIH1cbiAgICByZXR1cm4gZihrLlNhICsgdCwgMyk7XG4gIH0sIFwiJW1cIjprID0+IGYoay5HYSArIDEsIDIpLCBcIiVNXCI6ayA9PiBmKGsudmMsIDIpLCBcIiVuXCI6KCkgPT4gXCJcXG5cIiwgXCIlcFwiOmsgPT4gMCA8PSBrLkZhICYmIDEyID4gay5GYSA/IFwiQU1cIiA6IFwiUE1cIiwgXCIlU1wiOmsgPT4gZihrLndjLCAyKSwgXCIldFwiOigpID0+IFwiXFx0XCIsIFwiJXVcIjprID0+IGsuUiB8fCA3LCBcIiVVXCI6ayA9PiBmKE1hdGguZmxvb3IoKGsuY2EgKyA3IC0gay5SKSAvIDcpLCAyKSwgXCIlVlwiOmsgPT4ge1xuICAgIHZhciB0ID0gTWF0aC5mbG9vcigoay5jYSArIDcgLSAoay5SICsgNikgJSA3KSAvIDcpO1xuICAgIDIgPj0gKGsuUiArIDM3MSAtIGsuY2EgLSAyKSAlIDcgJiYgdCsrO1xuICAgIGlmICh0KSB7XG4gICAgICA1MyA9PSB0ICYmIChyID0gKGsuUiArIDM3MSAtIGsuY2EpICUgNywgNCA9PSByIHx8IDMgPT0gciAmJiBQZChrLmRhKSB8fCAodCA9IDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdCA9IDUyO1xuICAgICAgdmFyIHIgPSAoay5SICsgNyAtIGsuY2EgLSAxKSAlIDc7XG4gICAgICAoNCA9PSByIHx8IDUgPT0gciAmJiBQZChrLmRhICUgNDAwIC0gMSkpICYmIHQrKztcbiAgICB9XG4gICAgcmV0dXJuIGYodCwgMik7XG4gIH0sIFwiJXdcIjprID0+IGsuUiwgXCIlV1wiOmsgPT4gZihNYXRoLmZsb29yKChrLmNhICsgNyAtIChrLlIgKyA2KSAlIDcpIC8gNyksIDIpLCBcIiV5XCI6ayA9PiAoay5kYSArIDE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLCBcIiVZXCI6ayA9PiBrLmRhICsgMTkwMCwgXCIlelwiOmsgPT4ge1xuICAgIGsgPSBrLnVjO1xuICAgIHZhciB0ID0gMCA8PSBrO1xuICAgIGsgPSBNYXRoLmFicyhrKSAvIDYwO1xuICAgIHJldHVybiAodCA/IFwiK1wiIDogXCItXCIpICsgU3RyaW5nKFwiMDAwMFwiICsgKGsgLyA2MCAqIDEwMCArIGsgJSA2MCkpLnNsaWNlKC00KTtcbiAgfSwgXCIlWlwiOmsgPT4gay54YywgXCIlJVwiOigpID0+IFwiJVwifTtcbiAgYyA9IGMucmVwbGFjZSgvJSUvZywgXCJcXHgwMFxceDAwXCIpO1xuICBmb3IgKHUgaW4gbCkge1xuICAgIGMuaW5jbHVkZXModSkgJiYgKGMgPSBjLnJlcGxhY2UobmV3IFJlZ0V4cCh1LCBcImdcIiksIGxbdV0oZCkpKTtcbiAgfVxuICBjID0gYy5yZXBsYWNlKC9cXDBcXDAvZywgXCIlXCIpO1xuICB1ID0gcmIoYywgITEpO1xuICBpZiAodS5sZW5ndGggPiBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgQy5zZXQodSwgYSk7XG4gIHJldHVybiB1Lmxlbmd0aCAtIDE7XG59O1xuZnVuY3Rpb24gUGIoYSwgYiwgYywgZCkge1xuICBhIHx8IChhID0gdGhpcyk7XG4gIHRoaXMucGFyZW50ID0gYTtcbiAgdGhpcy5VID0gYS5VO1xuICB0aGlzLndhID0gbnVsbDtcbiAgdGhpcy5pZCA9IEhiKys7XG4gIHRoaXMubmFtZSA9IGI7XG4gIHRoaXMubW9kZSA9IGM7XG4gIHRoaXMubCA9IHt9O1xuICB0aGlzLm0gPSB7fTtcbiAgdGhpcy56YSA9IGQ7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhQYi5wcm90b3R5cGUsIHtyZWFkOntnZXQ6ZnVuY3Rpb24oKSB7XG4gIHJldHVybiAzNjUgPT09ICh0aGlzLm1vZGUgJiAzNjUpO1xufSwgc2V0OmZ1bmN0aW9uKGEpIHtcbiAgYSA/IHRoaXMubW9kZSB8PSAzNjUgOiB0aGlzLm1vZGUgJj0gLTM2Njtcbn19LCB3cml0ZTp7Z2V0OmZ1bmN0aW9uKCkge1xuICByZXR1cm4gMTQ2ID09PSAodGhpcy5tb2RlICYgMTQ2KTtcbn0sIHNldDpmdW5jdGlvbihhKSB7XG4gIGEgPyB0aGlzLm1vZGUgfD0gMTQ2IDogdGhpcy5tb2RlICY9IC0xNDc7XG59fX0pO1xuZ2MoKTtcbkliID0gQXJyYXkoNDA5Nik7XG5XYihQLCBcIi9cIik7XG5TKFwiL3RtcFwiLCAxNjg5NSwgMCk7XG5TKFwiL2hvbWVcIiwgMTY4OTUsIDApO1xuUyhcIi9ob21lL3dlYl91c2VyXCIsIDE2ODk1LCAwKTtcbigoKSA9PiB7XG4gIFMoXCIvZGV2XCIsIDE2ODk1LCAwKTtcbiAgdWIoMjU5LCB7cmVhZDooKSA9PiAwLCB3cml0ZTooZCwgZSwgZiwgZykgPT4gZyx9KTtcbiAgWGIoXCIvZGV2L251bGxcIiwgMjU5KTtcbiAgdGIoMTI4MCwgd2IpO1xuICB0YigxNTM2LCB4Yik7XG4gIFhiKFwiL2Rldi90dHlcIiwgMTI4MCk7XG4gIFhiKFwiL2Rldi90dHkxXCIsIDE1MzYpO1xuICB2YXIgYSA9IG5ldyBVaW50OEFycmF5KDEwMjQpLCBiID0gMCwgYyA9ICgpID0+IHtcbiAgICAwID09PSBiICYmIChiID0ga2IoYSkuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGFbLS1iXTtcbiAgfTtcbiAgamMoXCJyYW5kb21cIiwgYyk7XG4gIGpjKFwidXJhbmRvbVwiLCBjKTtcbiAgUyhcIi9kZXYvc2htXCIsIDE2ODk1LCAwKTtcbiAgUyhcIi9kZXYvc2htL3RtcFwiLCAxNjg5NSwgMCk7XG59KSgpO1xuKCgpID0+IHtcbiAgUyhcIi9wcm9jXCIsIDE2ODk1LCAwKTtcbiAgdmFyIGEgPSBTKFwiL3Byb2Mvc2VsZlwiLCAxNjg5NSwgMCk7XG4gIFMoXCIvcHJvYy9zZWxmL2ZkXCIsIDE2ODk1LCAwKTtcbiAgV2Ioe1U6KCkgPT4ge1xuICAgIHZhciBiID0gQWIoYSwgXCJmZFwiLCAxNjg5NSwgNzMpO1xuICAgIGIubCA9IHtrYTooYywgZCkgPT4ge1xuICAgICAgdmFyIGUgPSBUYigrZCk7XG4gICAgICBjID0ge3BhcmVudDpudWxsLCBVOnttYjpcImZha2VcIn0sIGw6e21hOigpID0+IGUucGF0aH0sfTtcbiAgICAgIHJldHVybiBjLnBhcmVudCA9IGM7XG4gICAgfX07XG4gICAgcmV0dXJuIGI7XG4gIH19LCBcIi9wcm9jL3NlbGYvZmRcIik7XG59KSgpO1xuT2JqZWN0LmFzc2lnbihwYy5wcm90b3R5cGUsIHtnZXQoYSkge1xuICByZXR1cm4gdGhpcy5NW2FdO1xufSwgaGFzKGEpIHtcbiAgcmV0dXJuIHZvaWQgMCAhPT0gdGhpcy5NW2FdO1xufSwgcGEoYSkge1xuICB2YXIgYiA9IHRoaXMuaGIucG9wKCkgfHwgdGhpcy5NLmxlbmd0aDtcbiAgdGhpcy5NW2JdID0gYTtcbiAgcmV0dXJuIGI7XG59LCBaYihhKSB7XG4gIHRoaXMuTVthXSA9IHZvaWQgMDtcbiAgdGhpcy5oYi5wdXNoKGEpO1xufX0pO1xucWMgPSBtLkJpbmRpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihhKSB7XG4gICAgc3VwZXIoYSk7XG4gICAgdGhpcy5uYW1lID0gXCJCaW5kaW5nRXJyb3JcIjtcbiAgfVxufTtcblUuTS5wdXNoKHt2YWx1ZTp2b2lkIDB9LCB7dmFsdWU6bnVsbH0sIHt2YWx1ZTohMH0sIHt2YWx1ZTohMX0sKTtcblUuaCA9IFUuTS5sZW5ndGg7XG5tLmNvdW50X2VtdmFsX2hhbmRsZXMgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgYSA9IDAsIGIgPSBVLmg7IGIgPCBVLk0ubGVuZ3RoOyArK2IpIHtcbiAgICB2b2lkIDAgIT09IFUuTVtiXSAmJiArK2E7XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xudWMgPSBtLlB1cmVWaXJ0dWFsRXJyb3IgPSB0YyhcIlB1cmVWaXJ0dWFsRXJyb3JcIik7XG5mb3IgKHZhciBUZCA9IEFycmF5KDI1NiksIFVkID0gMDsgMjU2ID4gVWQ7ICsrVWQpIHtcbiAgVGRbVWRdID0gU3RyaW5nLmZyb21DaGFyQ29kZShVZCk7XG59XG52YyA9IFRkO1xubS5nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh6YykubGVuZ3RoO1xufTtcbm0uZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IFtdLCBiO1xuICBmb3IgKGIgaW4gemMpIHtcbiAgICB6Yy5oYXNPd25Qcm9wZXJ0eShiKSAmJiBhLnB1c2goemNbYl0pO1xuICB9XG4gIHJldHVybiBhO1xufTtcbm0uZmx1c2hQZW5kaW5nRGVsZXRlcyA9IHhjO1xubS5zZXREZWxheUZ1bmN0aW9uID0gZnVuY3Rpb24oYSkge1xuICB5YyA9IGE7XG4gIHdjLmxlbmd0aCAmJiB5YyAmJiB5Yyh4Yyk7XG59O1xuTWMgPSBtLkludGVybmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoYSkge1xuICAgIHN1cGVyKGEpO1xuICAgIHRoaXMubmFtZSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICB9XG59O1xuWmMucHJvdG90eXBlLmlzQWxpYXNPZiA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFpjICYmIGEgaW5zdGFuY2VvZiBaYykpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgdmFyIGIgPSB0aGlzLmcudS5pLCBjID0gdGhpcy5nLm8sIGQgPSBhLmcudS5pO1xuICBmb3IgKGEgPSBhLmcubzsgYi5BOykge1xuICAgIGMgPSBiLm5hKGMpLCBiID0gYi5BO1xuICB9XG4gIGZvciAoOyBkLkE7KSB7XG4gICAgYSA9IGQubmEoYSksIGQgPSBkLkE7XG4gIH1cbiAgcmV0dXJuIGIgPT09IGQgJiYgYyA9PT0gYTtcbn07XG5aYy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nLm8gfHwgWWModGhpcyk7XG4gIGlmICh0aGlzLmcuaWEpIHtcbiAgICByZXR1cm4gdGhpcy5nLmNvdW50LnZhbHVlICs9IDEsIHRoaXM7XG4gIH1cbiAgdmFyIGEgPSBQYywgYiA9IE9iamVjdCwgYyA9IGIuY3JlYXRlLCBkID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBlID0gdGhpcy5nO1xuICBhID0gYShjLmNhbGwoYiwgZCwge2c6e3ZhbHVlOntjb3VudDplLmNvdW50LCBmYTplLmZhLCBpYTplLmlhLCBvOmUubywgdTplLnUsIEc6ZS5HLCBMOmUuTCx9LH19KSk7XG4gIGEuZy5jb3VudC52YWx1ZSArPSAxO1xuICBhLmcuZmEgPSAhMTtcbiAgcmV0dXJuIGE7XG59O1xuWmMucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZy5vIHx8IFljKHRoaXMpO1xuICB0aGlzLmcuZmEgJiYgIXRoaXMuZy5pYSAmJiBWKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKTtcbiAgR2ModGhpcyk7XG4gIEljKHRoaXMuZyk7XG4gIHRoaXMuZy5pYSB8fCAodGhpcy5nLkcgPSB2b2lkIDAsIHRoaXMuZy5vID0gdm9pZCAwKTtcbn07XG5aYy5wcm90b3R5cGUuaXNEZWxldGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5nLm87XG59O1xuWmMucHJvdG90eXBlLmRlbGV0ZUxhdGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZy5vIHx8IFljKHRoaXMpO1xuICB0aGlzLmcuZmEgJiYgIXRoaXMuZy5pYSAmJiBWKFwiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvblwiKTtcbiAgd2MucHVzaCh0aGlzKTtcbiAgMSA9PT0gd2MubGVuZ3RoICYmIHljICYmIHljKHhjKTtcbiAgdGhpcy5nLmZhID0gITA7XG4gIHJldHVybiB0aGlzO1xufTtcbmhkLnByb3RvdHlwZS5WYiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5yYiAmJiAoYSA9IHRoaXMucmIoYSkpO1xuICByZXR1cm4gYTtcbn07XG5oZC5wcm90b3R5cGUuYWIgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuVyAmJiB0aGlzLlcoYSk7XG59O1xuaGQucHJvdG90eXBlLmFyZ1BhY2tBZHZhbmNlID0gODtcbmhkLnByb3RvdHlwZS5yZWFkVmFsdWVGcm9tUG9pbnRlciA9IFNjO1xuaGQucHJvdG90eXBlLmRlbGV0ZU9iamVjdCA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYgKG51bGwgIT09IGEpIHtcbiAgICBhW1wiZGVsZXRlXCJdKCk7XG4gIH1cbn07XG5oZC5wcm90b3R5cGUuZnJvbVdpcmVUeXBlID0gZnVuY3Rpb24oYSkge1xuICBmdW5jdGlvbiBiKCkge1xuICAgIHJldHVybiB0aGlzLnVhID8gT2ModGhpcy5pLk4sIHt1OnRoaXMubmMsIG86YywgTDp0aGlzLCBHOmEsfSkgOiBPYyh0aGlzLmkuTiwge3U6dGhpcywgbzphLH0pO1xuICB9XG4gIHZhciBjID0gdGhpcy5WYihhKTtcbiAgaWYgKCFjKSB7XG4gICAgcmV0dXJuIHRoaXMuYWIoYSksIG51bGw7XG4gIH1cbiAgdmFyIGQgPSBMYyh0aGlzLmksIGMpO1xuICBpZiAodm9pZCAwICE9PSBkKSB7XG4gICAgaWYgKDAgPT09IGQuZy5jb3VudC52YWx1ZSkge1xuICAgICAgcmV0dXJuIGQuZy5vID0gYywgZC5nLkcgPSBhLCBkLmNsb25lKCk7XG4gICAgfVxuICAgIGQgPSBkLmNsb25lKCk7XG4gICAgdGhpcy5hYihhKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuICBkID0gdGhpcy5pLlViKGMpO1xuICBkID0gS2NbZF07XG4gIGlmICghZCkge1xuICAgIHJldHVybiBiLmNhbGwodGhpcyk7XG4gIH1cbiAgZCA9IHRoaXMudGEgPyBkLktiIDogZC5wb2ludGVyVHlwZTtcbiAgdmFyIGUgPSBKYyhjLCB0aGlzLmksIGQuaSk7XG4gIHJldHVybiBudWxsID09PSBlID8gYi5jYWxsKHRoaXMpIDogdGhpcy51YSA/IE9jKGQuaS5OLCB7dTpkLCBvOmUsIEw6dGhpcywgRzphLH0pIDogT2MoZC5pLk4sIHt1OmQsIG86ZSx9KTtcbn07XG5uZCA9IG0uVW5ib3VuZFR5cGVFcnJvciA9IHRjKFwiVW5ib3VuZFR5cGVFcnJvclwiKTtcbnZhciBYZCA9IHtfX3N5c2NhbGxfZmNudGw2NDpmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGxjID0gYztcbiAgdHJ5IHtcbiAgICB2YXIgZCA9IFRiKGEpO1xuICAgIHN3aXRjaChiKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHZhciBlID0gbWMoKTtcbiAgICAgICAgcmV0dXJuIDAgPiBlID8gLTI4IDogVmIoZCwgZSkuWDtcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBkLmZsYWdzO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gZSA9IG1jKCksIGQuZmxhZ3MgfD0gZSwgMDtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIGUgPSBtYygpLCBEYVtlICsgMCA+PiAxXSA9IDIsIDA7XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgY2FzZSAxNjpcbiAgICAgIGNhc2UgODpcbiAgICAgICAgcmV0dXJuIC0yODtcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgcmV0dXJuIExbVmQoKSA+PiAyXSA9IDI4LCAtMTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAtMjg7XG4gICAgfVxuICB9IGNhdGNoIChmKSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGtjIHx8IFwiRXJybm9FcnJvclwiICE9PSBmLm5hbWUpIHtcbiAgICAgIHRocm93IGY7XG4gICAgfVxuICAgIHJldHVybiAtZi5hYTtcbiAgfVxufSwgX19zeXNjYWxsX2lvY3RsOmZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgbGMgPSBjO1xuICB0cnkge1xuICAgIHZhciBkID0gVGIoYSk7XG4gICAgc3dpdGNoKGIpIHtcbiAgICAgIGNhc2UgMjE1MDk6XG4gICAgICAgIHJldHVybiBkLnMgPyAwIDogLTU5O1xuICAgICAgY2FzZSAyMTUwNTpcbiAgICAgICAgaWYgKCFkLnMpIHtcbiAgICAgICAgICByZXR1cm4gLTU5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkLnMuVi5iYykge1xuICAgICAgICAgIGIgPSBbMywgMjgsIDEyNywgMjEsIDQsIDAsIDEsIDAsIDE3LCAxOSwgMjYsIDAsIDE4LCAxNSwgMjMsIDIyLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLF07XG4gICAgICAgICAgdmFyIGUgPSBtYygpO1xuICAgICAgICAgIExbZSA+PiAyXSA9IDI1ODU2O1xuICAgICAgICAgIExbZSArIDQgPj4gMl0gPSA1O1xuICAgICAgICAgIExbZSArIDggPj4gMl0gPSAxOTE7XG4gICAgICAgICAgTFtlICsgMTIgPj4gMl0gPSAzNTM4NztcbiAgICAgICAgICBmb3IgKHZhciBmID0gMDsgMzIgPiBmOyBmKyspIHtcbiAgICAgICAgICAgIENbZSArIGYgKyAxNyA+PiAwXSA9IGJbZl0gfHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIDIxNTEwOlxuICAgICAgY2FzZSAyMTUxMTpcbiAgICAgIGNhc2UgMjE1MTI6XG4gICAgICAgIHJldHVybiBkLnMgPyAwIDogLTU5O1xuICAgICAgY2FzZSAyMTUwNjpcbiAgICAgIGNhc2UgMjE1MDc6XG4gICAgICBjYXNlIDIxNTA4OlxuICAgICAgICBpZiAoIWQucykge1xuICAgICAgICAgIHJldHVybiAtNTk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQucy5WLmNjKSB7XG4gICAgICAgICAgZm9yIChlID0gbWMoKSwgYiA9IFtdLCBmID0gMDsgMzIgPiBmOyBmKyspIHtcbiAgICAgICAgICAgIGIucHVzaChDW2UgKyBmICsgMTcgPj4gMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgMjE1MTk6XG4gICAgICAgIGlmICghZC5zKSB7XG4gICAgICAgICAgcmV0dXJuIC01OTtcbiAgICAgICAgfVxuICAgICAgICBlID0gbWMoKTtcbiAgICAgICAgcmV0dXJuIExbZSA+PiAyXSA9IDA7XG4gICAgICBjYXNlIDIxNTIwOlxuICAgICAgICByZXR1cm4gZC5zID8gLTI4IDogLTU5O1xuICAgICAgY2FzZSAyMTUzMTpcbiAgICAgICAgZSA9IG1jKCk7XG4gICAgICAgIGlmICghZC5tLmFjKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE8oNTkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkLm0uYWMoZCwgYiwgZSk7XG4gICAgICBjYXNlIDIxNTIzOlxuICAgICAgICBpZiAoIWQucykge1xuICAgICAgICAgIHJldHVybiAtNTk7XG4gICAgICAgIH1cbiAgICAgICAgZC5zLlYuZGMgJiYgKGYgPSBbMjQsIDgwXSwgZSA9IG1jKCksIERhW2UgPj4gMV0gPSBmWzBdLCBEYVtlICsgMiA+PiAxXSA9IGZbMV0pO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgMjE1MjQ6XG4gICAgICAgIHJldHVybiBkLnMgPyAwIDogLTU5O1xuICAgICAgY2FzZSAyMTUxNTpcbiAgICAgICAgcmV0dXJuIGQucyA/IDAgOiAtNTk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gLTI4O1xuICAgIH1cbiAgfSBjYXRjaCAoZykge1xuICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBrYyB8fCBcIkVycm5vRXJyb3JcIiAhPT0gZy5uYW1lKSB7XG4gICAgICB0aHJvdyBnO1xuICAgIH1cbiAgICByZXR1cm4gLWcuYWE7XG4gIH1cbn0sIF9fc3lzY2FsbF9vcGVuYXQ6ZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBsYyA9IGQ7XG4gIHRyeSB7XG4gICAgYiA9IGIgPyBuYihFLCBiKSA6IFwiXCI7XG4gICAgdmFyIGUgPSBiO1xuICAgIGlmIChcIi9cIiA9PT0gZS5jaGFyQXQoMCkpIHtcbiAgICAgIGIgPSBlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZiA9IC0xMDAgPT09IGEgPyBcIi9cIiA6IFRiKGEpLnBhdGg7XG4gICAgICBpZiAoMCA9PSBlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgTyg0NCk7XG4gICAgICB9XG4gICAgICBiID0gZ2IoZiArIFwiL1wiICsgZSk7XG4gICAgfVxuICAgIHZhciBnID0gZCA/IG1jKCkgOiAwO1xuICAgIHJldHVybiBlYyhiLCBjLCBnKS5YO1xuICB9IGNhdGNoIChuKSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGtjIHx8IFwiRXJybm9FcnJvclwiICE9PSBuLm5hbWUpIHtcbiAgICAgIHRocm93IG47XG4gICAgfVxuICAgIHJldHVybiAtbi5hYTtcbiAgfVxufSwgX2VtYmluZF9jcmVhdGVfaW5oZXJpdGluZ19jb25zdHJ1Y3RvcjpmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGEgPSBXKGEpO1xuICBiID0gRmMoYiwgXCJ3cmFwcGVyXCIpO1xuICBjID0gcmMoYyk7XG4gIHZhciBkID0gW10uc2xpY2UsIGUgPSBiLmksIGYgPSBlLk4sIGcgPSBlLkEuTiwgbiA9IGUuQS5jb25zdHJ1Y3RvcjtcbiAgYSA9IG9jKGEsIGZ1bmN0aW9uKCkge1xuICAgIGUuQS5xYi5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgIGlmICh0aGlzW2xdID09PSBnW2xdKSB7XG4gICAgICAgIHRocm93IG5ldyB1YyhgUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uICR7bH0gbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBKYXZhU2NyaXB0YCk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX3BhcmVudFwiLCB7dmFsdWU6Zn0pO1xuICAgIHRoaXMuX19jb25zdHJ1Y3QuYXBwbHkodGhpcywgZC5jYWxsKGFyZ3VtZW50cykpO1xuICB9KTtcbiAgZi5fX2NvbnN0cnVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMgPT09IGYgJiYgVihcIlBhc3MgY29ycmVjdCAndGhpcycgdG8gX19jb25zdHJ1Y3RcIik7XG4gICAgdmFyIGwgPSBuLmltcGxlbWVudC5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQoZC5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICBHYyhsKTtcbiAgICB2YXIgdSA9IGwuZztcbiAgICBsLm5vdGlmeU9uRGVzdHJ1Y3Rpb24oKTtcbiAgICB1LmlhID0gITA7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge2c6e3ZhbHVlOnV9fSk7XG4gICAgUGModGhpcyk7XG4gICAgbCA9IHUubztcbiAgICBsID0gQWMoZSwgbCk7XG4gICAgemMuaGFzT3duUHJvcGVydHkobCkgPyBWKGBUcmllZCB0byByZWdpc3RlciByZWdpc3RlcmVkIGluc3RhbmNlOiAke2x9YCkgOiB6Y1tsXSA9IHRoaXM7XG4gIH07XG4gIGYuX19kZXN0cnVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMgPT09IGYgJiYgVihcIlBhc3MgY29ycmVjdCAndGhpcycgdG8gX19kZXN0cnVjdFwiKTtcbiAgICBHYyh0aGlzKTtcbiAgICB2YXIgbCA9IHRoaXMuZy5vO1xuICAgIGwgPSBBYyhlLCBsKTtcbiAgICB6Yy5oYXNPd25Qcm9wZXJ0eShsKSA/IGRlbGV0ZSB6Y1tsXSA6IFYoYFRyaWVkIHRvIHVucmVnaXN0ZXIgdW5yZWdpc3RlcmVkIGluc3RhbmNlOiAke2x9YCk7XG4gIH07XG4gIGEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmKTtcbiAgZm9yICh2YXIgcCBpbiBjKSB7XG4gICAgYS5wcm90b3R5cGVbcF0gPSBjW3BdO1xuICB9XG4gIHJldHVybiBzYyhhKTtcbn0sIF9lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0OmZ1bmN0aW9uKGEpIHtcbiAgdmFyIGIgPSBRY1thXTtcbiAgZGVsZXRlIFFjW2FdO1xuICB2YXIgYyA9IGIuUGEsIGQgPSBiLlcsIGUgPSBiLmViLCBmID0gZS5tYXAoZyA9PiBnLlliKS5jb25jYXQoZS5tYXAoZyA9PiBnLnJjKSk7XG4gIFkoW2FdLCBmLCBnID0+IHtcbiAgICB2YXIgbiA9IHt9O1xuICAgIGUuZm9yRWFjaCgocCwgbCkgPT4ge1xuICAgICAgdmFyIHUgPSBnW2xdLCB2ID0gcC5XYiwgeCA9IHAuWGIsIGsgPSBnW2wgKyBlLmxlbmd0aF0sIHQgPSBwLnFjLCByID0gcC5zYztcbiAgICAgIG5bcC5TYl0gPSB7cmVhZDpCID0+IHUuZnJvbVdpcmVUeXBlKHYoeCwgQikpLCB3cml0ZTooQiwgRCkgPT4ge1xuICAgICAgICB2YXIgdyA9IFtdO1xuICAgICAgICB0KHIsIEIsIGsudG9XaXJlVHlwZSh3LCBEKSk7XG4gICAgICAgIFJjKHcpO1xuICAgICAgfX07XG4gICAgfSk7XG4gICAgcmV0dXJuIFt7bmFtZTpiLm5hbWUsIGZyb21XaXJlVHlwZTpmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgbCA9IHt9LCB1O1xuICAgICAgZm9yICh1IGluIG4pIHtcbiAgICAgICAgbFt1XSA9IG5bdV0ucmVhZChwKTtcbiAgICAgIH1cbiAgICAgIGQocCk7XG4gICAgICByZXR1cm4gbDtcbiAgICB9LCB0b1dpcmVUeXBlOmZ1bmN0aW9uKHAsIGwpIHtcbiAgICAgIGZvciAodmFyIHUgaW4gbikge1xuICAgICAgICBpZiAoISh1IGluIGwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWlzc2luZyBmaWVsZDogXCIke3V9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHYgPSBjKCk7XG4gICAgICBmb3IgKHUgaW4gbikge1xuICAgICAgICBuW3VdLndyaXRlKHYsIGxbdV0pO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gcCAmJiBwLnB1c2goZCwgdik7XG4gICAgICByZXR1cm4gdjtcbiAgICB9LCBhcmdQYWNrQWR2YW5jZTo4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjpTYywgSzpkLH1dO1xuICB9KTtcbn0sIF9lbWJpbmRfcmVnaXN0ZXJfYmlnaW50OmZ1bmN0aW9uKCkge1xufSwgX2VtYmluZF9yZWdpc3Rlcl9ib29sOmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUpIHtcbiAgdmFyIGYgPSBXYyhjKTtcbiAgYiA9IFcoYik7XG4gIFZjKGEsIHtuYW1lOmIsIGZyb21XaXJlVHlwZTpmdW5jdGlvbihnKSB7XG4gICAgcmV0dXJuICEhZztcbiAgfSwgdG9XaXJlVHlwZTpmdW5jdGlvbihnLCBuKSB7XG4gICAgcmV0dXJuIG4gPyBkIDogZTtcbiAgfSwgYXJnUGFja0FkdmFuY2U6OCwgcmVhZFZhbHVlRnJvbVBvaW50ZXI6ZnVuY3Rpb24oZykge1xuICAgIGlmICgxID09PSBjKSB7XG4gICAgICB2YXIgbiA9IEM7XG4gICAgfSBlbHNlIGlmICgyID09PSBjKSB7XG4gICAgICBuID0gRGE7XG4gICAgfSBlbHNlIGlmICg0ID09PSBjKSB7XG4gICAgICBuID0gTDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gYm9vbGVhbiB0eXBlIHNpemU6IFwiICsgYik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShuW2cgPj4gZl0pO1xuICB9LCBLOm51bGwsfSk7XG59LCBfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzOmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4sIHAsIGwsIHUsIHYsIHgpIHtcbiAgdSA9IFcodSk7XG4gIGYgPSBaKGUsIGYpO1xuICBuICYmIChuID0gWihnLCBuKSk7XG4gIGwgJiYgKGwgPSBaKHAsIGwpKTtcbiAgeCA9IFoodiwgeCk7XG4gIHZhciBrID0gbmModSk7XG4gIGFkKGssIGZ1bmN0aW9uKCkge1xuICAgIG9kKGBDYW5ub3QgY29uc3RydWN0ICR7dX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBbZF0pO1xuICB9KTtcbiAgWShbYSwgYiwgY10sIGQgPyBbZF0gOiBbXSwgZnVuY3Rpb24odCkge1xuICAgIHQgPSB0WzBdO1xuICAgIGlmIChkKSB7XG4gICAgICB2YXIgciA9IHQuaTtcbiAgICAgIHZhciBCID0gci5OO1xuICAgIH0gZWxzZSB7XG4gICAgICBCID0gWmMucHJvdG90eXBlO1xuICAgIH1cbiAgICB0ID0gb2MoaywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBEKSB7XG4gICAgICAgIHRocm93IG5ldyBxYyhcIlVzZSAnbmV3JyB0byBjb25zdHJ1Y3QgXCIgKyB1KTtcbiAgICAgIH1cbiAgICAgIGlmICh2b2lkIDAgPT09IHcuJCkge1xuICAgICAgICB0aHJvdyBuZXcgcWModSArIFwiIGhhcyBubyBhY2Nlc3NpYmxlIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgdmFyIFQgPSB3LiRbYXJndW1lbnRzLmxlbmd0aF07XG4gICAgICBpZiAodm9pZCAwID09PSBUKSB7XG4gICAgICAgIHRocm93IG5ldyBxYyhgVHJpZWQgdG8gaW52b2tlIGN0b3Igb2YgJHt1fSB3aXRoIGludmFsaWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCR7YXJndW1lbnRzLmxlbmd0aH0pIC0gZXhwZWN0ZWQgKCR7T2JqZWN0LmtleXMody4kKS50b1N0cmluZygpfSkgcGFyYW1ldGVycyBpbnN0ZWFkIWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgICB2YXIgRCA9IE9iamVjdC5jcmVhdGUoQiwge2NvbnN0cnVjdG9yOnt2YWx1ZTp0fSx9KTtcbiAgICB0LnByb3RvdHlwZSA9IEQ7XG4gICAgdmFyIHcgPSBuZXcgYmQodSwgdCwgRCwgeCwgciwgZiwgbiwgbCk7XG4gICAgdy5BICYmICh2b2lkIDAgPT09IHcuQS5vYSAmJiAody5BLm9hID0gW10pLCB3LkEub2EucHVzaCh3KSk7XG4gICAgciA9IG5ldyBoZCh1LCB3LCAhMCwgITEpO1xuICAgIEIgPSBuZXcgaGQodSArIFwiKlwiLCB3LCAhMSwgITEpO1xuICAgIHZhciBNID0gbmV3IGhkKHUgKyBcIiBjb25zdCpcIiwgdywgITEsICEwKTtcbiAgICBLY1thXSA9IHtwb2ludGVyVHlwZTpCLCBLYjpNfTtcbiAgICBqZChrLCB0KTtcbiAgICByZXR1cm4gW3IsIEIsIE1dO1xuICB9KTtcbn0sIF9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY2xhc3NfZnVuY3Rpb246ZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZykge1xuICB2YXIgbiA9IHNkKGMsIGQpO1xuICBiID0gVyhiKTtcbiAgZiA9IFooZSwgZik7XG4gIFkoW10sIFthXSwgZnVuY3Rpb24ocCkge1xuICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICBvZChgQ2Fubm90IGNhbGwgJHt1fSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIG4pO1xuICAgIH1cbiAgICBwID0gcFswXTtcbiAgICB2YXIgdSA9IGAke3AubmFtZX0uJHtifWA7XG4gICAgYi5zdGFydHNXaXRoKFwiQEBcIikgJiYgKGIgPSBTeW1ib2xbYi5zdWJzdHJpbmcoMildKTtcbiAgICB2YXIgdiA9IHAuaS5jb25zdHJ1Y3RvcjtcbiAgICB2b2lkIDAgPT09IHZbYl0gPyAobC5lYSA9IGMgLSAxLCB2W2JdID0gbCkgOiAoJGModiwgYiwgdSksIHZbYl0uQltjIC0gMV0gPSBsKTtcbiAgICBZKFtdLCBuLCBmdW5jdGlvbih4KSB7XG4gICAgICB4ID0gcGQodSwgW3hbMF0sIG51bGxdLmNvbmNhdCh4LnNsaWNlKDEpKSwgbnVsbCwgZiwgZyk7XG4gICAgICB2b2lkIDAgPT09IHZbYl0uQiA/ICh4LmVhID0gYyAtIDEsIHZbYl0gPSB4KSA6IHZbYl0uQltjIC0gMV0gPSB4O1xuICAgICAgaWYgKHAuaS5vYSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgcC5pLm9hKSB7XG4gICAgICAgICAgay5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShiKSB8fCAoay5jb25zdHJ1Y3RvcltiXSA9IHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSk7XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbn0sIF9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY2xhc3NfcHJvcGVydHk6ZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgbikge1xuICBiID0gVyhiKTtcbiAgZiA9IFooZSwgZik7XG4gIFkoW10sIFthXSwgZnVuY3Rpb24ocCkge1xuICAgIHAgPSBwWzBdO1xuICAgIHZhciBsID0gYCR7cC5uYW1lfS4ke2J9YCwgdSA9IHtnZXQoKSB7XG4gICAgICBvZChgQ2Fubm90IGFjY2VzcyAke2x9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgW2NdKTtcbiAgICB9LCBlbnVtZXJhYmxlOiEwLCBjb25maWd1cmFibGU6ITB9O1xuICAgIHUuc2V0ID0gbiA/ICgpID0+IHtcbiAgICAgIG9kKGBDYW5ub3QgYWNjZXNzICR7bH0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBbY10pO1xuICAgIH0gOiAoKSA9PiB7XG4gICAgICBWKGAke2x9IGlzIGEgcmVhZC1vbmx5IHByb3BlcnR5YCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocC5pLmNvbnN0cnVjdG9yLCBiLCB1KTtcbiAgICBZKFtdLCBbY10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHYgPSB2WzBdO1xuICAgICAgdmFyIHggPSB7Z2V0KCkge1xuICAgICAgICByZXR1cm4gdi5mcm9tV2lyZVR5cGUoZihkKSk7XG4gICAgICB9LCBlbnVtZXJhYmxlOiEwfTtcbiAgICAgIG4gJiYgKG4gPSBaKGcsIG4pLCB4LnNldCA9IGsgPT4ge1xuICAgICAgICB2YXIgdCA9IFtdO1xuICAgICAgICBuKGQsIHYudG9XaXJlVHlwZSh0LCBrKSk7XG4gICAgICAgIFJjKHQpO1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocC5pLmNvbnN0cnVjdG9yLCBiLCB4KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgICByZXR1cm4gW107XG4gIH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcjpmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBnID0gc2QoYiwgYyk7XG4gIGUgPSBaKGQsIGUpO1xuICBZKFtdLCBbYV0sIGZ1bmN0aW9uKG4pIHtcbiAgICBuID0gblswXTtcbiAgICB2YXIgcCA9IGBjb25zdHJ1Y3RvciAke24ubmFtZX1gO1xuICAgIHZvaWQgMCA9PT0gbi5pLiQgJiYgKG4uaS4kID0gW10pO1xuICAgIGlmICh2b2lkIDAgIT09IG4uaS4kW2IgLSAxXSkge1xuICAgICAgdGhyb3cgbmV3IHFjKGBDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgke2IgLSAxfSkgZm9yIGNsYXNzICcke24ubmFtZX0nISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFgKTtcbiAgICB9XG4gICAgbi5pLiRbYiAtIDFdID0gKCkgPT4ge1xuICAgICAgb2QoYENhbm5vdCBjb25zdHJ1Y3QgJHtuLm5hbWV9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgZyk7XG4gICAgfTtcbiAgICBZKFtdLCBnLCBmdW5jdGlvbihsKSB7XG4gICAgICBsLnNwbGljZSgxLCAwLCBudWxsKTtcbiAgICAgIG4uaS4kW2IgLSAxXSA9IHBkKHAsIGwsIG51bGwsIGUsIGYpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG59LCBfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uOmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4pIHtcbiAgdmFyIHAgPSBzZChjLCBkKTtcbiAgYiA9IFcoYik7XG4gIGYgPSBaKGUsIGYpO1xuICBZKFtdLCBbYV0sIGZ1bmN0aW9uKGwpIHtcbiAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgb2QoYENhbm5vdCBjYWxsICR7dn0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBwKTtcbiAgICB9XG4gICAgbCA9IGxbMF07XG4gICAgdmFyIHYgPSBgJHtsLm5hbWV9LiR7Yn1gO1xuICAgIGIuc3RhcnRzV2l0aChcIkBAXCIpICYmIChiID0gU3ltYm9sW2Iuc3Vic3RyaW5nKDIpXSk7XG4gICAgbiAmJiBsLmkucWIucHVzaChiKTtcbiAgICB2YXIgeCA9IGwuaS5OLCBrID0geFtiXTtcbiAgICB2b2lkIDAgPT09IGsgfHwgdm9pZCAwID09PSBrLkIgJiYgay5jbGFzc05hbWUgIT09IGwubmFtZSAmJiBrLmVhID09PSBjIC0gMiA/ICh1LmVhID0gYyAtIDIsIHUuY2xhc3NOYW1lID0gbC5uYW1lLCB4W2JdID0gdSkgOiAoJGMoeCwgYiwgdiksIHhbYl0uQltjIC0gMl0gPSB1KTtcbiAgICBZKFtdLCBwLCBmdW5jdGlvbih0KSB7XG4gICAgICB0ID0gcGQodiwgdCwgbCwgZiwgZyk7XG4gICAgICB2b2lkIDAgPT09IHhbYl0uQiA/ICh0LmVhID0gYyAtIDIsIHhbYl0gPSB0KSA6IHhbYl0uQltjIC0gMl0gPSB0O1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG59LCBfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX3Byb3BlcnR5OmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4sIHAsIGwpIHtcbiAgYiA9IFcoYik7XG4gIGUgPSBaKGQsIGUpO1xuICBZKFtdLCBbYV0sIGZ1bmN0aW9uKHUpIHtcbiAgICB1ID0gdVswXTtcbiAgICB2YXIgdiA9IGAke3UubmFtZX0uJHtifWAsIHggPSB7Z2V0KCkge1xuICAgICAgb2QoYENhbm5vdCBhY2Nlc3MgJHt2fSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIFtjLCBnXSk7XG4gICAgfSwgZW51bWVyYWJsZTohMCwgY29uZmlndXJhYmxlOiEwfTtcbiAgICB4LnNldCA9IHAgPyAoKSA9PiB7XG4gICAgICBvZChgQ2Fubm90IGFjY2VzcyAke3Z9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgW2MsIGddKTtcbiAgICB9IDogKCkgPT4ge1xuICAgICAgVih2ICsgXCIgaXMgYSByZWFkLW9ubHkgcHJvcGVydHlcIik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5pLk4sIGIsIHgpO1xuICAgIFkoW10sIHAgPyBbYywgZ10gOiBbY10sIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciB0ID0ga1swXSwgciA9IHtnZXQoKSB7XG4gICAgICAgIHZhciBEID0gdGQodGhpcywgdSwgdiArIFwiIGdldHRlclwiKTtcbiAgICAgICAgcmV0dXJuIHQuZnJvbVdpcmVUeXBlKGUoZiwgRCkpO1xuICAgICAgfSwgZW51bWVyYWJsZTohMH07XG4gICAgICBpZiAocCkge1xuICAgICAgICBwID0gWihuLCBwKTtcbiAgICAgICAgdmFyIEIgPSBrWzFdO1xuICAgICAgICByLnNldCA9IGZ1bmN0aW9uKEQpIHtcbiAgICAgICAgICB2YXIgdyA9IHRkKHRoaXMsIHUsIHYgKyBcIiBzZXR0ZXJcIiksIE0gPSBbXTtcbiAgICAgICAgICBwKGwsIHcsIEIudG9XaXJlVHlwZShNLCBEKSk7XG4gICAgICAgICAgUmMoTSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5pLk4sIGIsIHIpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG59LCBfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsOmZ1bmN0aW9uKGEsIGIpIHtcbiAgYiA9IFcoYik7XG4gIFZjKGEsIHtuYW1lOmIsIGZyb21XaXJlVHlwZTpmdW5jdGlvbihjKSB7XG4gICAgdmFyIGQgPSByYyhjKTtcbiAgICB1ZChjKTtcbiAgICByZXR1cm4gZDtcbiAgfSwgdG9XaXJlVHlwZTpmdW5jdGlvbihjLCBkKSB7XG4gICAgcmV0dXJuIHNjKGQpO1xuICB9LCBhcmdQYWNrQWR2YW5jZTo4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjpTYywgSzpudWxsLH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9lbnVtOmZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgfVxuICBjID0gV2MoYyk7XG4gIGIgPSBXKGIpO1xuICBlLnZhbHVlcyA9IHt9O1xuICBWYyhhLCB7bmFtZTpiLCBjb25zdHJ1Y3RvcjplLCBmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnZhbHVlc1tmXTtcbiAgfSwgdG9XaXJlVHlwZTpmdW5jdGlvbihmLCBnKSB7XG4gICAgcmV0dXJuIGcudmFsdWU7XG4gIH0sIGFyZ1BhY2tBZHZhbmNlOjgsIHJlYWRWYWx1ZUZyb21Qb2ludGVyOnZkKGIsIGMsIGQpLCBLOm51bGwsfSk7XG4gIGFkKGIsIGUpO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9lbnVtX3ZhbHVlOmZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgdmFyIGQgPSBGYyhhLCBcImVudW1cIik7XG4gIGIgPSBXKGIpO1xuICBhID0gZC5jb25zdHJ1Y3RvcjtcbiAgZCA9IE9iamVjdC5jcmVhdGUoZC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHt2YWx1ZTp7dmFsdWU6Y30sIGNvbnN0cnVjdG9yOnt2YWx1ZTpvYyhgJHtkLm5hbWV9XyR7Yn1gLCBmdW5jdGlvbigpIHtcbiAgfSl9LH0pO1xuICBhLnZhbHVlc1tjXSA9IGQ7XG4gIGFbYl0gPSBkO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9mbG9hdDpmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGMgPSBXYyhjKTtcbiAgYiA9IFcoYik7XG4gIFZjKGEsIHtuYW1lOmIsIGZyb21XaXJlVHlwZTpmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH0sIHRvV2lyZVR5cGU6ZnVuY3Rpb24oZCwgZSkge1xuICAgIHJldHVybiBlO1xuICB9LCBhcmdQYWNrQWR2YW5jZTo4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjp3ZChiLCBjKSwgSzpudWxsLH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbjpmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBnID0gc2QoYiwgYyk7XG4gIGEgPSBXKGEpO1xuICBlID0gWihkLCBlKTtcbiAgYWQoYSwgZnVuY3Rpb24oKSB7XG4gICAgb2QoYENhbm5vdCBjYWxsICR7YX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBnKTtcbiAgfSwgYiAtIDEpO1xuICBZKFtdLCBnLCBmdW5jdGlvbihuKSB7XG4gICAgamQoYSwgcGQoYSwgW25bMF0sIG51bGxdLmNvbmNhdChuLnNsaWNlKDEpKSwgbnVsbCwgZSwgZiksIGIgLSAxKTtcbiAgICByZXR1cm4gW107XG4gIH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyOmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUpIHtcbiAgYiA9IFcoYik7XG4gIC0xID09PSBlICYmIChlID0gNDI5NDk2NzI5NSk7XG4gIGUgPSBXYyhjKTtcbiAgdmFyIGYgPSBuID0+IG47XG4gIGlmICgwID09PSBkKSB7XG4gICAgdmFyIGcgPSAzMiAtIDggKiBjO1xuICAgIGYgPSBuID0+IG4gPDwgZyA+Pj4gZztcbiAgfVxuICBjID0gYi5pbmNsdWRlcyhcInVuc2lnbmVkXCIpID8gZnVuY3Rpb24obiwgcCkge1xuICAgIHJldHVybiBwID4+PiAwO1xuICB9IDogZnVuY3Rpb24obiwgcCkge1xuICAgIHJldHVybiBwO1xuICB9O1xuICBWYyhhLCB7bmFtZTpiLCBmcm9tV2lyZVR5cGU6ZiwgdG9XaXJlVHlwZTpjLCBhcmdQYWNrQWR2YW5jZTo4LCByZWFkVmFsdWVGcm9tUG9pbnRlcjp4ZChiLCBlLCAwICE9PSBkKSwgSzpudWxsLH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldzpmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGZ1bmN0aW9uIGQoZikge1xuICAgIGYgPj49IDI7XG4gICAgdmFyIGcgPSBOO1xuICAgIHJldHVybiBuZXcgZShnLmJ1ZmZlciwgZ1tmICsgMV0sIGdbZl0pO1xuICB9XG4gIHZhciBlID0gW0ludDhBcnJheSwgVWludDhBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheSxdW2JdO1xuICBjID0gVyhjKTtcbiAgVmMoYSwge25hbWU6YywgZnJvbVdpcmVUeXBlOmQsIGFyZ1BhY2tBZHZhbmNlOjgsIHJlYWRWYWx1ZUZyb21Qb2ludGVyOmQsfSwgeyRiOiEwLH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nOmZ1bmN0aW9uKGEsIGIpIHtcbiAgYiA9IFcoYik7XG4gIHZhciBjID0gXCJzdGQ6OnN0cmluZ1wiID09PSBiO1xuICBWYyhhLCB7bmFtZTpiLCBmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZCkge1xuICAgIHZhciBlID0gTltkID4+IDJdLCBmID0gZCArIDQ7XG4gICAgaWYgKGMpIHtcbiAgICAgIGZvciAodmFyIGcgPSBmLCBuID0gMDsgbiA8PSBlOyArK24pIHtcbiAgICAgICAgdmFyIHAgPSBmICsgbjtcbiAgICAgICAgaWYgKG4gPT0gZSB8fCAwID09IEVbcF0pIHtcbiAgICAgICAgICBnID0gZyA/IG5iKEUsIGcsIHAgLSBnKSA6IFwiXCI7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gbCkge1xuICAgICAgICAgICAgdmFyIGwgPSBnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIGwgKz0gZztcbiAgICAgICAgICB9XG4gICAgICAgICAgZyA9IHAgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBBcnJheShlKTtcbiAgICAgIGZvciAobiA9IDA7IG4gPCBlOyArK24pIHtcbiAgICAgICAgbFtuXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoRVtmICsgbl0pO1xuICAgICAgfVxuICAgICAgbCA9IGwuam9pbihcIlwiKTtcbiAgICB9XG4gICAgRWMoZCk7XG4gICAgcmV0dXJuIGw7XG4gIH0sIHRvV2lyZVR5cGU6ZnVuY3Rpb24oZCwgZSkge1xuICAgIGUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJiAoZSA9IG5ldyBVaW50OEFycmF5KGUpKTtcbiAgICB2YXIgZiA9IFwic3RyaW5nXCIgPT0gdHlwZW9mIGU7XG4gICAgZiB8fCBlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHwgZSBpbnN0YW5jZW9mIEludDhBcnJheSB8fCBWKFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKTtcbiAgICB2YXIgZyA9IGMgJiYgZiA/IHBiKGUpIDogZS5sZW5ndGg7XG4gICAgdmFyIG4gPSBXZCg0ICsgZyArIDEpLCBwID0gbiArIDQ7XG4gICAgTltuID4+IDJdID0gZztcbiAgICBpZiAoYyAmJiBmKSB7XG4gICAgICBxYihlLCBFLCBwLCBnICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmKSB7XG4gICAgICAgIGZvciAoZiA9IDA7IGYgPCBnOyArK2YpIHtcbiAgICAgICAgICB2YXIgbCA9IGUuY2hhckNvZGVBdChmKTtcbiAgICAgICAgICAyNTUgPCBsICYmIChFYyhwKSwgVihcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKSk7XG4gICAgICAgICAgRVtwICsgZl0gPSBsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGYgPSAwOyBmIDwgZzsgKytmKSB7XG4gICAgICAgICAgRVtwICsgZl0gPSBlW2ZdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG51bGwgIT09IGQgJiYgZC5wdXNoKEVjLCBuKTtcbiAgICByZXR1cm4gbjtcbiAgfSwgYXJnUGFja0FkdmFuY2U6OCwgcmVhZFZhbHVlRnJvbVBvaW50ZXI6U2MsIEs6ZnVuY3Rpb24oZCkge1xuICAgIEVjKGQpO1xuICB9LH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZzpmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGMgPSBXKGMpO1xuICBpZiAoMiA9PT0gYikge1xuICAgIHZhciBkID0gemQ7XG4gICAgdmFyIGUgPSBBZDtcbiAgICB2YXIgZiA9IEJkO1xuICAgIHZhciBnID0gKCkgPT4gRWE7XG4gICAgdmFyIG4gPSAxO1xuICB9IGVsc2Uge1xuICAgIDQgPT09IGIgJiYgKGQgPSBDZCwgZSA9IERkLCBmID0gRWQsIGcgPSAoKSA9PiBOLCBuID0gMik7XG4gIH1cbiAgVmMoYSwge25hbWU6YywgZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKHApIHtcbiAgICBmb3IgKHZhciBsID0gTltwID4+IDJdLCB1ID0gZygpLCB2LCB4ID0gcCArIDQsIGsgPSAwOyBrIDw9IGw7ICsraykge1xuICAgICAgdmFyIHQgPSBwICsgNCArIGsgKiBiO1xuICAgICAgaWYgKGsgPT0gbCB8fCAwID09IHVbdCA+PiBuXSkge1xuICAgICAgICB4ID0gZCh4LCB0IC0geCksIHZvaWQgMCA9PT0gdiA/IHYgPSB4IDogKHYgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKSwgdiArPSB4KSwgeCA9IHQgKyBiO1xuICAgICAgfVxuICAgIH1cbiAgICBFYyhwKTtcbiAgICByZXR1cm4gdjtcbiAgfSwgdG9XaXJlVHlwZTpmdW5jdGlvbihwLCBsKSB7XG4gICAgXCJzdHJpbmdcIiAhPSB0eXBlb2YgbCAmJiBWKGBDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAke2N9YCk7XG4gICAgdmFyIHUgPSBmKGwpLCB2ID0gV2QoNCArIHUgKyBiKTtcbiAgICBOW3YgPj4gMl0gPSB1ID4+IG47XG4gICAgZShsLCB2ICsgNCwgdSArIGIpO1xuICAgIG51bGwgIT09IHAgJiYgcC5wdXNoKEVjLCB2KTtcbiAgICByZXR1cm4gdjtcbiAgfSwgYXJnUGFja0FkdmFuY2U6OCwgcmVhZFZhbHVlRnJvbVBvaW50ZXI6U2MsIEs6ZnVuY3Rpb24ocCkge1xuICAgIEVjKHApO1xuICB9LH0pO1xufSwgX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3Q6ZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICBRY1thXSA9IHtuYW1lOlcoYiksIFBhOlooYywgZCksIFc6WihlLCBmKSwgZWI6W10sfTtcbn0sIF9lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0X2ZpZWxkOmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4sIHAsIGwpIHtcbiAgUWNbYV0uZWIucHVzaCh7U2I6VyhiKSwgWWI6YywgV2I6WihkLCBlKSwgWGI6ZiwgcmM6ZywgcWM6WihuLCBwKSwgc2M6bCx9KTtcbn0sIF9lbWJpbmRfcmVnaXN0ZXJfdm9pZDpmdW5jdGlvbihhLCBiKSB7XG4gIGIgPSBXKGIpO1xuICBWYyhhLCB7ZmM6ITAsIG5hbWU6YiwgYXJnUGFja0FkdmFuY2U6MCwgZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKCkge1xuICB9LCB0b1dpcmVUeXBlOmZ1bmN0aW9uKCkge1xuICB9LH0pO1xufSwgX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWM6KCkgPT4gITAsIF9lbXZhbF9hczpmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGEgPSByYyhhKTtcbiAgYiA9IEZjKGIsIFwiZW12YWw6OmFzXCIpO1xuICB2YXIgZCA9IFtdLCBlID0gc2MoZCk7XG4gIE5bYyA+PiAyXSA9IGU7XG4gIHJldHVybiBiLnRvV2lyZVR5cGUoZCwgYSk7XG59LCBfZW12YWxfY2FsbF9tZXRob2Q6ZnVuY3Rpb24oYSwgYiwgYywgZCwgZSkge1xuICBhID0gSGRbYV07XG4gIGIgPSByYyhiKTtcbiAgYyA9IEdkKGMpO1xuICB2YXIgZiA9IFtdO1xuICBOW2QgPj4gMl0gPSBzYyhmKTtcbiAgcmV0dXJuIGEoYiwgYywgZiwgZSk7XG59LCBfZW12YWxfY2FsbF92b2lkX21ldGhvZDpmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIGEgPSBIZFthXTtcbiAgYiA9IHJjKGIpO1xuICBjID0gR2QoYyk7XG4gIGEoYiwgYywgbnVsbCwgZCk7XG59LCBfZW12YWxfZGVjcmVmOnVkLCBfZW12YWxfZ2V0X21ldGhvZF9jYWxsZXI6ZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYyA9IEpkKGEsIGIpLCBkID0gY1swXTtcbiAgYiA9IGQubmFtZSArIFwiXyRcIiArIGMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uKGcpIHtcbiAgICByZXR1cm4gZy5uYW1lO1xuICB9KS5qb2luKFwiX1wiKSArIFwiJFwiO1xuICB2YXIgZSA9IEtkW2JdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgdmFyIGYgPSBBcnJheShhIC0gMSk7XG4gIGUgPSBJZCgoZywgbiwgcCwgbCkgPT4ge1xuICAgIGZvciAodmFyIHUgPSAwLCB2ID0gMDsgdiA8IGEgLSAxOyArK3YpIHtcbiAgICAgIGZbdl0gPSBjW3YgKyAxXS5yZWFkVmFsdWVGcm9tUG9pbnRlcihsICsgdSksIHUgKz0gY1t2ICsgMV0uYXJnUGFja0FkdmFuY2U7XG4gICAgfVxuICAgIGcgPSBnW25dLmFwcGx5KGcsIGYpO1xuICAgIGZvciAodiA9IDA7IHYgPCBhIC0gMTsgKyt2KSB7XG4gICAgICBjW3YgKyAxXS5OYiAmJiBjW3YgKyAxXS5OYihmW3ZdKTtcbiAgICB9XG4gICAgaWYgKCFkLmZjKSB7XG4gICAgICByZXR1cm4gZC50b1dpcmVUeXBlKHAsIGcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBLZFtiXSA9IGU7XG59LCBfZW12YWxfZ2V0X21vZHVsZV9wcm9wZXJ0eTpmdW5jdGlvbihhKSB7XG4gIGEgPSBHZChhKTtcbiAgcmV0dXJuIHNjKG1bYV0pO1xufSwgX2VtdmFsX2dldF9wcm9wZXJ0eTpmdW5jdGlvbihhLCBiKSB7XG4gIGEgPSByYyhhKTtcbiAgYiA9IHJjKGIpO1xuICByZXR1cm4gc2MoYVtiXSk7XG59LCBfZW12YWxfaW5jcmVmOmZ1bmN0aW9uKGEpIHtcbiAgNCA8IGEgJiYgKFUuZ2V0KGEpLnRiICs9IDEpO1xufSwgX2VtdmFsX25ld19hcnJheTpmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjKFtdKTtcbn0sIF9lbXZhbF9uZXdfY3N0cmluZzpmdW5jdGlvbihhKSB7XG4gIHJldHVybiBzYyhHZChhKSk7XG59LCBfZW12YWxfbmV3X29iamVjdDpmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjKHt9KTtcbn0sIF9lbXZhbF9ydW5fZGVzdHJ1Y3RvcnM6ZnVuY3Rpb24oYSkge1xuICB2YXIgYiA9IHJjKGEpO1xuICBSYyhiKTtcbiAgdWQoYSk7XG59LCBfZW12YWxfc2V0X3Byb3BlcnR5OmZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgYSA9IHJjKGEpO1xuICBiID0gcmMoYik7XG4gIGMgPSByYyhjKTtcbiAgYVtiXSA9IGM7XG59LCBfZW12YWxfdGFrZV92YWx1ZTpmdW5jdGlvbihhLCBiKSB7XG4gIGEgPSBGYyhhLCBcIl9lbXZhbF90YWtlX3ZhbHVlXCIpO1xuICBhID0gYS5yZWFkVmFsdWVGcm9tUG9pbnRlcihiKTtcbiAgcmV0dXJuIHNjKGEpO1xufSwgYWJvcnQ6KCkgPT4ge1xuICBBYShcIlwiKTtcbn0sIGVtc2NyaXB0ZW5fYXNtX2NvbnN0X2ludDooYSwgYiwgYykgPT4ge1xuICBMZC5sZW5ndGggPSAwO1xuICB2YXIgZDtcbiAgZm9yIChjID4+PSAyOyBkID0gRVtiKytdOykge1xuICAgIGMgKz0gMTA1ICE9IGQgJiBjLCBMZC5wdXNoKDEwNSA9PSBkID8gTFtjXSA6IElhW2MrKyA+PiAxXSksICsrYztcbiAgfVxuICByZXR1cm4gZGJbYV0uYXBwbHkobnVsbCwgTGQpO1xufSwgZW1zY3JpcHRlbl9kYXRlX25vdzpmdW5jdGlvbigpIHtcbiAgcmV0dXJuIERhdGUubm93KCk7XG59LCBlbXNjcmlwdGVuX2dldF9ub3c6KCkgPT4gcGVyZm9ybWFuY2Uubm93KCksIGVtc2NyaXB0ZW5fbWVtY3B5X2JpZzooYSwgYiwgYykgPT4gRS5jb3B5V2l0aGluKGEsIGIsIGIgKyBjKSwgZW1zY3JpcHRlbl9yZXNpemVfaGVhcDphID0+IHtcbiAgdmFyIGIgPSBFLmxlbmd0aDtcbiAgYSA+Pj49IDA7XG4gIGlmICgyMTQ3NDgzNjQ4IDwgYSkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBmb3IgKHZhciBjID0gMTsgNCA+PSBjOyBjICo9IDIpIHtcbiAgICB2YXIgZCA9IGIgKiAoMSArIDAuMiAvIGMpO1xuICAgIGQgPSBNYXRoLm1pbihkLCBhICsgMTAwNjYzMjk2KTtcbiAgICB2YXIgZSA9IE1hdGg7XG4gICAgZCA9IE1hdGgubWF4KGEsIGQpO1xuICAgIGE6IHtcbiAgICAgIGUgPSBlLm1pbi5jYWxsKGUsIDIxNDc0ODM2NDgsIGQgKyAoNjU1MzYgLSBkICUgNjU1MzYpICUgNjU1MzYpIC0gQmEuYnVmZmVyLmJ5dGVMZW5ndGggKyA2NTUzNSA+Pj4gMTY7XG4gICAgICB0cnkge1xuICAgICAgICBCYS5ncm93KGUpO1xuICAgICAgICBKYSgpO1xuICAgICAgICB2YXIgZiA9IDE7XG4gICAgICAgIGJyZWFrIGE7XG4gICAgICB9IGNhdGNoIChnKSB7XG4gICAgICB9XG4gICAgICBmID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoZikge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITE7XG59LCBlbnZpcm9uX2dldDooYSwgYikgPT4ge1xuICB2YXIgYyA9IDA7XG4gIE9kKCkuZm9yRWFjaChmdW5jdGlvbihkLCBlKSB7XG4gICAgdmFyIGYgPSBiICsgYztcbiAgICBlID0gTlthICsgNCAqIGUgPj4gMl0gPSBmO1xuICAgIGZvciAoZiA9IDA7IGYgPCBkLmxlbmd0aDsgKytmKSB7XG4gICAgICBDW2UrKyA+PiAwXSA9IGQuY2hhckNvZGVBdChmKTtcbiAgICB9XG4gICAgQ1tlID4+IDBdID0gMDtcbiAgICBjICs9IGQubGVuZ3RoICsgMTtcbiAgfSk7XG4gIHJldHVybiAwO1xufSwgZW52aXJvbl9zaXplc19nZXQ6KGEsIGIpID0+IHtcbiAgdmFyIGMgPSBPZCgpO1xuICBOW2EgPj4gMl0gPSBjLmxlbmd0aDtcbiAgdmFyIGQgPSAwO1xuICBjLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgIGQgKz0gZS5sZW5ndGggKyAxO1xuICB9KTtcbiAgTltiID4+IDJdID0gZDtcbiAgcmV0dXJuIDA7XG59LCBmZF9jbG9zZTpmdW5jdGlvbihhKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBUYihhKTtcbiAgICBpZiAobnVsbCA9PT0gYi5YKSB7XG4gICAgICB0aHJvdyBuZXcgTyg4KTtcbiAgICB9XG4gICAgYi5NYSAmJiAoYi5NYSA9IG51bGwpO1xuICAgIHRyeSB7XG4gICAgICBiLm0uY2xvc2UgJiYgYi5tLmNsb3NlKGIpO1xuICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgIHRocm93IGM7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEdiW2IuWF0gPSBudWxsO1xuICAgIH1cbiAgICBiLlggPSBudWxsO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChjKSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGtjIHx8IFwiRXJybm9FcnJvclwiICE9PSBjLm5hbWUpIHtcbiAgICAgIHRocm93IGM7XG4gICAgfVxuICAgIHJldHVybiBjLmFhO1xuICB9XG59LCBmZF9yZWFkOmZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgdHJ5IHtcbiAgICBhOiB7XG4gICAgICB2YXIgZSA9IFRiKGEpO1xuICAgICAgYSA9IGI7XG4gICAgICBmb3IgKHZhciBmLCBnID0gYiA9IDA7IGcgPCBjOyBnKyspIHtcbiAgICAgICAgdmFyIG4gPSBOW2EgPj4gMl0sIHAgPSBOW2EgKyA0ID4+IDJdO1xuICAgICAgICBhICs9IDg7XG4gICAgICAgIHZhciBsID0gZSwgdSA9IG4sIHYgPSBwLCB4ID0gZiwgayA9IEM7XG4gICAgICAgIGlmICgwID4gdiB8fCAwID4geCkge1xuICAgICAgICAgIHRocm93IG5ldyBPKDI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCA9PT0gbC5YKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE8oOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDEgPT09IChsLmZsYWdzICYgMjA5NzE1NSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTyg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMTYzODQgPT09IChsLm5vZGUubW9kZSAmIDYxNDQwKSkge1xuICAgICAgICAgIHRocm93IG5ldyBPKDMxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWwubS5yZWFkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE8oMjgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgeDtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgeCA9IGwucG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAoIWwuc2Vla2FibGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTyg3MCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSBsLm0ucmVhZChsLCBrLCB1LCB2LCB4KTtcbiAgICAgICAgdCB8fCAobC5wb3NpdGlvbiArPSByKTtcbiAgICAgICAgdmFyIEIgPSByO1xuICAgICAgICBpZiAoMCA+IEIpIHtcbiAgICAgICAgICB2YXIgRCA9IC0xO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgYiArPSBCO1xuICAgICAgICBpZiAoQiA8IHApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZiAmJiAoZiArPSBCKTtcbiAgICAgIH1cbiAgICAgIEQgPSBiO1xuICAgIH1cbiAgICBOW2QgPj4gMl0gPSBEO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoICh3KSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGtjIHx8IFwiRXJybm9FcnJvclwiICE9PSB3Lm5hbWUpIHtcbiAgICAgIHRocm93IHc7XG4gICAgfVxuICAgIHJldHVybiB3LmFhO1xuICB9XG59LCBmZF9zZWVrOmZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUpIHtcbiAgYiA9IGMgKyAyMDk3MTUyID4+PiAwIDwgNDE5NDMwNSAtICEhYiA/IChiID4+PiAwKSArIDQyOTQ5NjcyOTYgKiBjIDogTmFOO1xuICB0cnkge1xuICAgIGlmIChpc05hTihiKSkge1xuICAgICAgcmV0dXJuIDYxO1xuICAgIH1cbiAgICB2YXIgZiA9IFRiKGEpO1xuICAgIGZjKGYsIGIsIGQpO1xuICAgICRhID0gW2YucG9zaXRpb24gPj4+IDAsIChaYSA9IGYucG9zaXRpb24sIDEuMCA8PSArTWF0aC5hYnMoWmEpID8gMC4wIDwgWmEgPyArTWF0aC5mbG9vcihaYSAvIDQyOTQ5NjcyOTYuMCkgPj4+IDAgOiB+fitNYXRoLmNlaWwoKFphIC0gKyh+flphID4+PiAwKSkgLyA0Mjk0OTY3Mjk2LjApID4+PiAwIDogMCldO1xuICAgIExbZSA+PiAyXSA9ICRhWzBdO1xuICAgIExbZSArIDQgPj4gMl0gPSAkYVsxXTtcbiAgICBmLk1hICYmIDAgPT09IGIgJiYgMCA9PT0gZCAmJiAoZi5NYSA9IG51bGwpO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChnKSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGtjIHx8IFwiRXJybm9FcnJvclwiICE9PSBnLm5hbWUpIHtcbiAgICAgIHRocm93IGc7XG4gICAgfVxuICAgIHJldHVybiBnLmFhO1xuICB9XG59LCBmZF93cml0ZTpmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIHRyeSB7XG4gICAgYToge1xuICAgICAgdmFyIGUgPSBUYihhKTtcbiAgICAgIGEgPSBiO1xuICAgICAgZm9yICh2YXIgZiwgZyA9IGIgPSAwOyBnIDwgYzsgZysrKSB7XG4gICAgICAgIHZhciBuID0gTlthID4+IDJdLCBwID0gTlthICsgNCA+PiAyXTtcbiAgICAgICAgYSArPSA4O1xuICAgICAgICB2YXIgbCA9IGUsIHUgPSBuLCB2ID0gcCwgeCA9IGYsIGsgPSBDO1xuICAgICAgICBpZiAoMCA+IHYgfHwgMCA+IHgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTygyOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgPT09IGwuWCkge1xuICAgICAgICAgIHRocm93IG5ldyBPKDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwID09PSAobC5mbGFncyAmIDIwOTcxNTUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE8oOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDE2Mzg0ID09PSAobC5ub2RlLm1vZGUgJiA2MTQ0MCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTygzMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsLm0ud3JpdGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTygyOCk7XG4gICAgICAgIH1cbiAgICAgICAgbC5zZWVrYWJsZSAmJiBsLmZsYWdzICYgMTAyNCAmJiBmYyhsLCAwLCAyKTtcbiAgICAgICAgdmFyIHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB4O1xuICAgICAgICBpZiAoIXQpIHtcbiAgICAgICAgICB4ID0gbC5wb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghbC5zZWVrYWJsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBPKDcwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IGwubS53cml0ZShsLCBrLCB1LCB2LCB4LCB2b2lkIDApO1xuICAgICAgICB0IHx8IChsLnBvc2l0aW9uICs9IHIpO1xuICAgICAgICB2YXIgQiA9IHI7XG4gICAgICAgIGlmICgwID4gQikge1xuICAgICAgICAgIHZhciBEID0gLTE7XG4gICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgfVxuICAgICAgICBiICs9IEI7XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmICYmIChmICs9IEIpO1xuICAgICAgfVxuICAgICAgRCA9IGI7XG4gICAgfVxuICAgIE5bZCA+PiAyXSA9IEQ7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKHcpIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Yga2MgfHwgXCJFcnJub0Vycm9yXCIgIT09IHcubmFtZSkge1xuICAgICAgdGhyb3cgdztcbiAgICB9XG4gICAgcmV0dXJuIHcuYWE7XG4gIH1cbn0sIHN0cmZ0aW1lX2w6KGEsIGIsIGMsIGQpID0+IFNkKGEsIGIsIGMsIGQpfTtcbihmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gYShjKSB7XG4gICAgeiA9IGMgPSBjLmV4cG9ydHM7XG4gICAgQmEgPSB6Lm1lbW9yeTtcbiAgICBKYSgpO1xuICAgIEthID0gei5fX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlO1xuICAgIE1hLnVuc2hpZnQoei5fX3dhc21fY2FsbF9jdG9ycyk7XG4gICAgUGEtLTtcbiAgICBtLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMgJiYgbS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFBhKTtcbiAgICBpZiAoMCA9PSBQYSAmJiAobnVsbCAhPT0gUWEgJiYgKGNsZWFySW50ZXJ2YWwoUWEpLCBRYSA9IG51bGwpLCBSYSkpIHtcbiAgICAgIHZhciBkID0gUmE7XG4gICAgICBSYSA9IG51bGw7XG4gICAgICBkKCk7XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9XG4gIHZhciBiID0ge2VudjpYZCwgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTpYZCx9O1xuICBQYSsrO1xuICBtLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMgJiYgbS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFBhKTtcbiAgaWYgKG0uaW5zdGFudGlhdGVXYXNtKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtLmluc3RhbnRpYXRlV2FzbShiLCBhKTtcbiAgICB9IGNhdGNoIChjKSB7XG4gICAgICB4YShcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiICsgYyksIGJhKGMpO1xuICAgIH1cbiAgfVxuICBZYShiLCBmdW5jdGlvbihjKSB7XG4gICAgYShjLmluc3RhbmNlKTtcbiAgfSkuY2F0Y2goYmEpO1xuICByZXR1cm4ge307XG59KSgpO1xudmFyIEVjID0gYSA9PiAoRWMgPSB6LmZyZWUpKGEpLCBXZCA9IGEgPT4gKFdkID0gei5tYWxsb2MpKGEpLCBhYiA9IG0uX21hX2RldmljZV9fb25fbm90aWZpY2F0aW9uX3VubG9ja2VkID0gYSA9PiAoYWIgPSBtLl9tYV9kZXZpY2VfX29uX25vdGlmaWNhdGlvbl91bmxvY2tlZCA9IHoubWFfZGV2aWNlX19vbl9ub3RpZmljYXRpb25fdW5sb2NrZWQpKGEpO1xubS5fbWFfbWFsbG9jX2Vtc2NyaXB0ZW4gPSAoYSwgYikgPT4gKG0uX21hX21hbGxvY19lbXNjcmlwdGVuID0gei5tYV9tYWxsb2NfZW1zY3JpcHRlbikoYSwgYik7XG5tLl9tYV9mcmVlX2Vtc2NyaXB0ZW4gPSAoYSwgYikgPT4gKG0uX21hX2ZyZWVfZW1zY3JpcHRlbiA9IHoubWFfZnJlZV9lbXNjcmlwdGVuKShhLCBiKTtcbnZhciBiYiA9IG0uX21hX2RldmljZV9wcm9jZXNzX3BjbV9mcmFtZXNfY2FwdHVyZV9fd2ViYXVkaW8gPSAoYSwgYiwgYykgPT4gKGJiID0gbS5fbWFfZGV2aWNlX3Byb2Nlc3NfcGNtX2ZyYW1lc19jYXB0dXJlX193ZWJhdWRpbyA9IHoubWFfZGV2aWNlX3Byb2Nlc3NfcGNtX2ZyYW1lc19jYXB0dXJlX193ZWJhdWRpbykoYSwgYiwgYyksIGNiID0gbS5fbWFfZGV2aWNlX3Byb2Nlc3NfcGNtX2ZyYW1lc19wbGF5YmFja19fd2ViYXVkaW8gPSAoYSwgYiwgYykgPT4gKGNiID0gbS5fbWFfZGV2aWNlX3Byb2Nlc3NfcGNtX2ZyYW1lc19wbGF5YmFja19fd2ViYXVkaW8gPSB6Lm1hX2RldmljZV9wcm9jZXNzX3BjbV9mcmFtZXNfcGxheWJhY2tfX3dlYmF1ZGlvKShhLCBiLCBjKSwgVmQgPSAoKSA9PiAoVmQgPSB6Ll9fZXJybm9fbG9jYXRpb24pKCksIERjID0gYSA9PiAoRGMgPSB6Ll9fZ2V0VHlwZU5hbWUpKGEpO1xubS5fX2VtYmluZF9pbml0aWFsaXplX2JpbmRpbmdzID0gKCkgPT4gKG0uX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncyA9IHouX2VtYmluZF9pbml0aWFsaXplX2JpbmRpbmdzKSgpO1xubS5keW5DYWxsX2lpamkgPSAoYSwgYiwgYywgZCwgZSkgPT4gKG0uZHluQ2FsbF9paWppID0gei5keW5DYWxsX2lpamkpKGEsIGIsIGMsIGQsIGUpO1xubS5keW5DYWxsX2ppamkgPSAoYSwgYiwgYywgZCwgZSkgPT4gKG0uZHluQ2FsbF9qaWppID0gei5keW5DYWxsX2ppamkpKGEsIGIsIGMsIGQsIGUpO1xubS5keW5DYWxsX2lpaWppID0gKGEsIGIsIGMsIGQsIGUsIGYpID0+IChtLmR5bkNhbGxfaWlpamkgPSB6LmR5bkNhbGxfaWlpamkpKGEsIGIsIGMsIGQsIGUsIGYpO1xubS5keW5DYWxsX2lpaiA9IChhLCBiLCBjLCBkKSA9PiAobS5keW5DYWxsX2lpaiA9IHouZHluQ2FsbF9paWopKGEsIGIsIGMsIGQpO1xubS5keW5DYWxsX2ppaSA9IChhLCBiLCBjKSA9PiAobS5keW5DYWxsX2ppaSA9IHouZHluQ2FsbF9qaWkpKGEsIGIsIGMpO1xubS5keW5DYWxsX3ZpaWppaSA9IChhLCBiLCBjLCBkLCBlLCBmLCBnKSA9PiAobS5keW5DYWxsX3ZpaWppaSA9IHouZHluQ2FsbF92aWlqaWkpKGEsIGIsIGMsIGQsIGUsIGYsIGcpO1xubS5keW5DYWxsX2lpaWlpaiA9IChhLCBiLCBjLCBkLCBlLCBmLCBnKSA9PiAobS5keW5DYWxsX2lpaWlpaiA9IHouZHluQ2FsbF9paWlpaWopKGEsIGIsIGMsIGQsIGUsIGYsIGcpO1xubS5keW5DYWxsX2lpaWlpamogPSAoYSwgYiwgYywgZCwgZSwgZiwgZywgbiwgcCkgPT4gKG0uZHluQ2FsbF9paWlpaWpqID0gei5keW5DYWxsX2lpaWlpamopKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4sIHApO1xubS5keW5DYWxsX2lpaWlpaWpqID0gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4sIHAsIGwpID0+IChtLmR5bkNhbGxfaWlpaWlpamogPSB6LmR5bkNhbGxfaWlpaWlpamopKGEsIGIsIGMsIGQsIGUsIGYsIGcsIG4sIHAsIGwpO1xudmFyIFlkO1xuUmEgPSBmdW5jdGlvbiBaZCgpIHtcbiAgWWQgfHwgJGQoKTtcbiAgWWQgfHwgKFJhID0gWmQpO1xufTtcbmZ1bmN0aW9uICRkKCkge1xuICBmdW5jdGlvbiBhKCkge1xuICAgIGlmICghWWQgJiYgKFlkID0gITAsIG0uY2FsbGVkUnVuID0gITAsICFDYSkpIHtcbiAgICAgIG0ubm9GU0luaXQgfHwgaGMgfHwgKGhjID0gITAsIGdjKCksIG0uc3RkaW4gPSBtLnN0ZGluLCBtLnN0ZG91dCA9IG0uc3Rkb3V0LCBtLnN0ZGVyciA9IG0uc3RkZXJyLCBtLnN0ZGluID8gamMoXCJzdGRpblwiLCBtLnN0ZGluKSA6IGNjKFwiL2Rldi90dHlcIiwgXCIvZGV2L3N0ZGluXCIpLCBtLnN0ZG91dCA/IGpjKFwic3Rkb3V0XCIsIG51bGwsIG0uc3Rkb3V0KSA6IGNjKFwiL2Rldi90dHlcIiwgXCIvZGV2L3N0ZG91dFwiKSwgbS5zdGRlcnIgPyBqYyhcInN0ZGVyclwiLCBudWxsLCBtLnN0ZGVycikgOiBjYyhcIi9kZXYvdHR5MVwiLCBcIi9kZXYvc3RkZXJyXCIpLCBlYyhcIi9kZXYvc3RkaW5cIiwgMCksIGVjKFwiL2Rldi9zdGRvdXRcIiwgMSksIGVjKFwiL2Rldi9zdGRlcnJcIiwgMSkpO1xuICAgICAgSmIgPSAhMTtcbiAgICAgIGViKE1hKTtcbiAgICAgIGFhKG0pO1xuICAgICAgaWYgKG0ub25SdW50aW1lSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgbS5vblJ1bnRpbWVJbml0aWFsaXplZCgpO1xuICAgICAgfVxuICAgICAgaWYgKG0ucG9zdFJ1bikge1xuICAgICAgICBmb3IgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbS5wb3N0UnVuICYmIChtLnBvc3RSdW4gPSBbbS5wb3N0UnVuXSk7IG0ucG9zdFJ1bi5sZW5ndGg7KSB7XG4gICAgICAgICAgdmFyIGIgPSBtLnBvc3RSdW4uc2hpZnQoKTtcbiAgICAgICAgICBOYS51bnNoaWZ0KGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlYihOYSk7XG4gICAgfVxuICB9XG4gIGlmICghKDAgPCBQYSkpIHtcbiAgICBpZiAobS5wcmVSdW4pIHtcbiAgICAgIGZvciAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBtLnByZVJ1biAmJiAobS5wcmVSdW4gPSBbbS5wcmVSdW5dKTsgbS5wcmVSdW4ubGVuZ3RoOykge1xuICAgICAgICBPYSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBlYihMYSk7XG4gICAgMCA8IFBhIHx8IChtLnNldFN0YXR1cyA/IChtLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBtLnNldFN0YXR1cyhcIlwiKTtcbiAgICAgIH0sIDEpO1xuICAgICAgYSgpO1xuICAgIH0sIDEpKSA6IGEoKSk7XG4gIH1cbn1cbmlmIChtLnByZUluaXQpIHtcbiAgZm9yIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG0ucHJlSW5pdCAmJiAobS5wcmVJbml0ID0gW20ucHJlSW5pdF0pOyAwIDwgbS5wcmVJbml0Lmxlbmd0aDspIHtcbiAgICBtLnByZUluaXQucG9wKCkoKTtcbiAgfVxufVxuJGQoKTtcblxuXG5cbiAgcmV0dXJuIG1vZHVsZUFyZy5yZWFkeVxufVxuXG4pO1xufSkoKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoUml2ZSk7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovSlNPTi5wYXJzZSgne1wibmFtZVwiOlwiQHJpdmUtYXBwL2NhbnZhc1wiLFwidmVyc2lvblwiOlwiMi4yNi41XCIsXCJkZXNjcmlwdGlvblwiOlwiUml2ZVxcJ3MgY2FudmFzIGJhc2VkIHdlYiBhcGkuXCIsXCJtYWluXCI6XCJyaXZlLmpzXCIsXCJob21lcGFnZVwiOlwiaHR0cHM6Ly9yaXZlLmFwcFwiLFwicmVwb3NpdG9yeVwiOntcInR5cGVcIjpcImdpdFwiLFwidXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vcml2ZS1hcHAvcml2ZS13YXNtL3RyZWUvbWFzdGVyL2pzXCJ9LFwia2V5d29yZHNcIjpbXCJyaXZlXCIsXCJhbmltYXRpb25cIl0sXCJhdXRob3JcIjpcIlJpdmVcIixcImNvbnRyaWJ1dG9yc1wiOltcIkx1aWdpIFJvc3NvIDxsdWlnaUByaXZlLmFwcD4gKGh0dHBzOi8vcml2ZS5hcHApXCIsXCJNYXh3ZWxsIFRhbGJvdCA8bWF4QHJpdmUuYXBwPiAoaHR0cHM6Ly9yaXZlLmFwcClcIixcIkFydGh1ciBWaXZpYW4gPGFydGh1ckByaXZlLmFwcD4gKGh0dHBzOi8vcml2ZS5hcHApXCIsXCJVbWJlcnRvIFNvbm5pbm8gPHVtYmVydG9Acml2ZS5hcHA+IChodHRwczovL3JpdmUuYXBwKVwiLFwiTWF0dGhldyBTdWxsaXZhbiA8bWF0dC5qLnN1bGxpdmFuQGdtYWlsLmNvbT4gKG1haWx0bzptYXR0Lmouc3VsbGl2YW5AZ21haWwuY29tKVwiXSxcImxpY2Vuc2VcIjpcIk1JVFwiLFwiZmlsZXNcIjpbXCJyaXZlLmpzXCIsXCJyaXZlLmpzLm1hcFwiLFwicml2ZS53YXNtXCIsXCJyaXZlX2ZhbGxiYWNrLndhc21cIixcInJpdmUuZC50c1wiLFwicml2ZV9hZHZhbmNlZC5tanMuZC50c1wiXSxcInR5cGluZ3NcIjpcInJpdmUuZC50c1wiLFwiZGVwZW5kZW5jaWVzXCI6e30sXCJicm93c2VyXCI6e1wiZnNcIjpmYWxzZSxcInBhdGhcIjpmYWxzZX19Jyk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbmltYXRpb246ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9BbmltYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5BbmltYXRpb24pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfQW5pbWF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFuaW1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5pbWF0aW9uKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYW5pbWF0aW9uIHRoYXQgY2FuIGJlIHBsYXllZCBvbiBhbiBBcnRib2FyZC5cbiAqIFdyYXBzIGFuaW1hdGlvbnMgYW5kIGluc3RhbmNlcyBmcm9tIHRoZSBydW50aW1lIGFuZCBrZWVwcyB0cmFjayBvZiBwbGF5YmFjayBzdGF0ZS5cbiAqXG4gKiBUaGUgYEFuaW1hdGlvbmAgY2xhc3MgbWFuYWdlcyB0aGUgc3RhdGUgYW5kIGJlaGF2aW9yIG9mIGEgc2luZ2xlIGFuaW1hdGlvbiBpbnN0YW5jZSxcbiAqIGluY2x1ZGluZyBpdHMgY3VycmVudCB0aW1lLCBsb29wIGNvdW50LCBhbmQgYWJpbGl0eSB0byBzY3J1YiB0byBhIHNwZWNpZmljIHRpbWUuXG4gKlxuICogVGhlIGNsYXNzIHByb3ZpZGVzIG1ldGhvZHMgdG8gYWR2YW5jZSB0aGUgYW5pbWF0aW9uLCBhcHBseSBpdHMgaW50ZXJwb2xhdGVkIGtleWZyYW1lXG4gKiB2YWx1ZXMgdG8gdGhlIEFydGJvYXJkLCBhbmQgY2xlYW4gdXAgdGhlIHVuZGVybHlpbmcgYW5pbWF0aW9uIGluc3RhbmNlIHdoZW4gdGhlXG4gKiBhbmltYXRpb24gaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAqL1xudmFyIEFuaW1hdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGFuaW1hdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7YW55fSBhbmltYXRpb246IHJ1bnRpbWUgYW5pbWF0aW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSB7YW55fSBpbnN0YW5jZTogcnVudGltZSBhbmltYXRpb24gaW5zdGFuY2Ugb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKGFuaW1hdGlvbiwgYXJ0Ym9hcmQsIHJ1bnRpbWUsIHBsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICAgIHRoaXMuYXJ0Ym9hcmQgPSBhcnRib2FyZDtcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gcGxheWluZztcbiAgICAgICAgdGhpcy5sb29wQ291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgdG8gd2hpY2ggdGhlIGFuaW1hdGlvbiBzaG91bGQgbW92ZSB0byBvbiB0aGUgbmV4dCByZW5kZXIuXG4gICAgICAgICAqIElmIG5vdCBudWxsLCB0aGUgYW5pbWF0aW9uIHdpbGwgc2NydWIgdG8gdGhpcyB0aW1lIGluc3RlYWQgb2YgYWR2YW5jaW5nIGJ5IHRoZSBnaXZlbiB0aW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3J1YlRvID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBydW50aW1lLkxpbmVhckFuaW1hdGlvbkluc3RhbmNlKGFuaW1hdGlvbiwgYXJ0Ym9hcmQpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFuaW1hdGlvbidzIG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uLnByb3RvdHlwZSwgXCJ0aW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFuaW1hdGlvbidzIG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UudGltZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFuaW1hdGlvbidzIGN1cnJlbnQgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UudGltZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbi5wcm90b3R5cGUsIFwibG9vcFZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGFuaW1hdGlvbidzIGxvb3AgdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24ubG9vcFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbi5wcm90b3R5cGUsIFwibmVlZHNTY3J1YlwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIG5lZWRzIHRvIGJlIHNjcnViYmVkLlxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBuZWVkcyB0byBiZSBzY3J1YmJlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjcnViVG8gIT09IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgYW5pbWF0aW9uIGJ5IHRoZSBnaXZlIHRpbWUuIElmIHRoZSBhbmltYXRpb24gbmVlZHMgc2NydWJiaW5nLFxuICAgICAqIHRpbWUgaXMgaWdub3JlZCBhbmQgdGhlIHN0b3JlZCBzY3J1YiB2YWx1ZSBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB0aW1lIHRoZSB0aW1lIHRvIGFkdmFuY2UgdGhlIGFuaW1hdGlvbiBieSBpZiBubyBzY3J1YmJpbmcgcmVxdWlyZWRcbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICBpZiAodGhpcy5zY3J1YlRvID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmFkdmFuY2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnRpbWUgPSAwO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5hZHZhbmNlKHRoaXMuc2NydWJUbyk7XG4gICAgICAgICAgICB0aGlzLnNjcnViVG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBpbnRlcnBvbGF0ZWQga2V5ZnJhbWUgdmFsdWVzIHRvIHRoZSBhcnRib2FyZC4gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGNhbGxpbmdcbiAgICAgKiAuYWR2YW5jZSgpIG9uIGFuIGFuaW1hdGlvbiBpbnN0YW5jZSBzbyB0aGF0IG5ldyB2YWx1ZXMgYXJlIGFwcGxpZWQgdG8gcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZG9lcyBub3QgYWR2YW5jZSB0aGUgYXJ0Ym9hcmQsIHdoaWNoIHVwZGF0ZXMgYWxsIG9iamVjdHMgb24gdGhlIGFydGJvYXJkXG4gICAgICogQHBhcmFtIG1peCAtIE1peCB2YWx1ZSBmb3IgdGhlIGFuaW1hdGlvbiBmcm9tIDAgdG8gMVxuICAgICAqL1xuICAgIEFuaW1hdGlvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAobWl4KSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuYXBwbHkobWl4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGJhY2tpbmcgV2FzbSBhbmltYXRpb24gaW5zdGFuY2U7IG9uY2UgdGhpcyBpcyBjYWxsZWQsIHRoaXNcbiAgICAgKiBhbmltYXRpb24gaXMgbm8gbW9yZS5cbiAgICAgKi9cbiAgICBBbmltYXRpb24ucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZGVsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uO1xufSgpKTtcblxuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBCTEFOS19VUkw6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9zYW5pdGl6ZVVybF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLkJMQU5LX1VSTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJlZ2lzdGVyVG91Y2hJbnRlcmFjdGlvbnM6ICgpID0+ICgvKiByZWV4cG9ydCBzYWZlICovIF9yZWdpc3RlclRvdWNoSW50ZXJhY3Rpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18ucmVnaXN0ZXJUb3VjaEludGVyYWN0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHNhbml0aXplVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfc2FuaXRpemVVcmxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5zYW5pdGl6ZVVybClcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZWdpc3RlclRvdWNoSW50ZXJhY3Rpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zYW5pdGl6ZVVybF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuXG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJlZ2lzdGVyVG91Y2hJbnRlcmFjdGlvbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlZ2lzdGVyVG91Y2hJbnRlcmFjdGlvbnMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbnZhciBfdGhpcyA9IHVuZGVmaW5lZDtcbi8qKlxuICogUmV0dXJucyB0aGUgY2xpZW50WCBhbmQgY2xpZW50WSBwcm9wZXJ0aWVzIGZyb20gdG91Y2ggb3IgbW91c2UgZXZlbnRzLiBBbHNvXG4gKiBjYWxscyBwcmV2ZW50RGVmYXVsdCgpIG9uIHRoZSBldmVudCBpZiBpdCBpcyBhIHRvdWNoc3RhcnQgb3IgdG91Y2htb3ZlIHRvIHByZXZlbnRcbiAqIHNjcm9sbGluZyB0aGUgcGFnZSBvbiBtb2JpbGUgZGV2aWNlc1xuICogQHBhcmFtIGV2ZW50IC0gRWl0aGVyIGEgVG91Y2hFdmVudCBvciBhIE1vdXNlRXZlbnRcbiAqIEByZXR1cm5zIC0gQ29vcmRpbmF0ZXMgb2YgdGhlIGNsaWVudFggYW5kIGNsaWVudFkgcHJvcGVydGllcyBmcm9tIHRoZSB0b3VjaC9tb3VzZSBldmVudFxuICovXG52YXIgZ2V0Q2xpZW50Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoZXZlbnQsIGlzVG91Y2hTY3JvbGxFbmFibGVkKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoW1widG91Y2hzdGFydFwiLCBcInRvdWNobW92ZVwiXS5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEgJiZcbiAgICAgICAgKChfYSA9IGV2ZW50LnRvdWNoZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgICAgIC8vIFRoaXMgZmxhZywgaWYgZmFsc2UsIHByZXZlbnRzIHRvdWNoIGV2ZW50cyBvbiB0aGUgY2FudmFzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgLy8gd2hpY2ggbWF5IHByZXZlbnQgc2Nyb2xsaW5nIGlmIGEgZHJhZyBtb3Rpb24gb24gdGhlIGNhbnZhcyBpcyBwZXJmb3JtZWRcbiAgICAgICAgaWYgKCFpc1RvdWNoU2Nyb2xsRW5hYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50WDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgY2xpZW50WTogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC50eXBlID09PSBcInRvdWNoZW5kXCIgJiZcbiAgICAgICAgKChfYiA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50WDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgIGNsaWVudFk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIH07XG4gICAgfVxufTtcbi8qKlxuICogUmVnaXN0ZXJzIG1vdXNlIG1vdmUvdXAvZG93biBjYWxsYmFjayBoYW5kbGVycyBvbiB0aGUgY2FudmFzIHRvIHNlbmQgbWVhbmluZ2Z1bCBjb29yZGluYXRlcyB0b1xuICogdGhlIHN0YXRlIG1hY2hpbmUgcG9pbnRlciBtb3ZlL3VwL2Rvd24gZnVuY3Rpb25zIGJhc2VkIG9uIGN1cnNvciBpbnRlcmFjdGlvblxuICovXG52YXIgcmVnaXN0ZXJUb3VjaEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjYW52YXMgPSBfYS5jYW52YXMsIGFydGJvYXJkID0gX2EuYXJ0Ym9hcmQsIF9iID0gX2Euc3RhdGVNYWNoaW5lcywgc3RhdGVNYWNoaW5lcyA9IF9iID09PSB2b2lkIDAgPyBbXSA6IF9iLCByZW5kZXJlciA9IF9hLnJlbmRlcmVyLCByaXZlID0gX2Eucml2ZSwgZml0ID0gX2EuZml0LCBhbGlnbm1lbnQgPSBfYS5hbGlnbm1lbnQsIF9jID0gX2EuaXNUb3VjaFNjcm9sbEVuYWJsZWQsIGlzVG91Y2hTY3JvbGxFbmFibGVkID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EubGF5b3V0U2NhbGVGYWN0b3IsIGxheW91dFNjYWxlRmFjdG9yID0gX2QgPT09IHZvaWQgMCA/IDEuMCA6IF9kO1xuICAgIGlmICghY2FudmFzIHx8XG4gICAgICAgICFzdGF0ZU1hY2hpbmVzLmxlbmd0aCB8fFxuICAgICAgICAhcmVuZGVyZXIgfHxcbiAgICAgICAgIXJpdmUgfHxcbiAgICAgICAgIWFydGJvYXJkIHx8XG4gICAgICAgIHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFmdGVyIGEgdG91Y2hlbmQgZXZlbnQsIHNvbWUgYnJvd3NlcnMgbWF5IGZpcmUgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICAgICAqIChtb3VzZW92ZXIsIG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwKSBpZiB0aGUgdG91Y2ggaW50ZXJhY3Rpb24gZGlkIG5vdCBjYXVzZVxuICAgICAqIGFueSBkZWZhdWx0IGFjdGlvbiAoc3VjaCBhcyBzY3JvbGxpbmcpLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBkb25lIHRvIHNpbXVsYXRlIHRoZSBiZWhhdmlvciBvZiBhIG1vdXNlIGZvciBhcHBsaWNhdGlvbnMgdGhhdCBkbyBub3Qgc3VwcG9ydFxuICAgICAqIHRvdWNoIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIFdlJ3JlIGtlZXBpbmcgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGV2ZW50IHRvIG5vdCBzZW5kIHRoZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzIGlmIHRoZVxuICAgICAqIHRvdWNoIGV2ZW50IHdhcyBhIGNsaWNrICh0b3VjaHN0YXJ0IC0+IHRvdWNoZW5kKS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgb25seSBuZWVkZWQgd2hlbiBgaXNUb3VjaFNjcm9sbEVuYWJsZWRgIGlzIGZhbHNlXG4gICAgICogV2hlbiB0cnVlLCBgcHJldmVudERlZmF1bHQoKWAgaXMgY2FsbGVkIHdoaWNoIHByZXZlbnRzIHRoaXMgYmVoYXZpb3VyLlxuICAgICAqKi9cbiAgICB2YXIgX3ByZXZFdmVudFR5cGUgPSBudWxsO1xuICAgIHZhciBfc3ludGhldGljRXZlbnRzQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIHByb2Nlc3NFdmVudENhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEV4aXQgZWFybHkgb3V0IG9mIGFsbCBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk2NTY5OTAvaG93LXRvLXByZXZlbnQtc2ltdWxhdGVkLW1vdXNlLWV2ZW50cy1pbi1tb2JpbGUtYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU1NzIwNzAvamF2YXNjcmlwdC10b3VjaGVuZC12ZXJzdXMtY2xpY2stZGlsZW1tYVxuICAgICAgICBpZiAoX3N5bnRoZXRpY0V2ZW50c0FjdGl2ZSAmJiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFN5bnRoZXRpYyBldmVudCBmaW5pc2hlZFxuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJtb3VzZXVwXCIpIHtcbiAgICAgICAgICAgICAgICBfc3ludGhldGljRXZlbnRzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBpZiBpdCdzIGEgXCJ0b3VjaCBjbGlja1wiLiBUaGlzIGNvdWxkIGNhdXNlIHRoZSBicm93c2VyIHRvIHNlbmRcbiAgICAgICAgLy8gc3ludGhldGljIG1vdXNlIGV2ZW50cy5cbiAgICAgICAgX3N5bnRoZXRpY0V2ZW50c0FjdGl2ZSA9XG4gICAgICAgICAgICBpc1RvdWNoU2Nyb2xsRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPT09IFwidG91Y2hlbmRcIiAmJlxuICAgICAgICAgICAgICAgIF9wcmV2RXZlbnRUeXBlID09PSBcInRvdWNoc3RhcnRcIjtcbiAgICAgICAgX3ByZXZFdmVudFR5cGUgPSBldmVudC50eXBlO1xuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0Q2xpZW50Q29vcmRpbmF0ZXMoZXZlbnQsIGlzVG91Y2hTY3JvbGxFbmFibGVkKSwgY2xpZW50WCA9IF9hLmNsaWVudFgsIGNsaWVudFkgPSBfYS5jbGllbnRZO1xuICAgICAgICBpZiAoIWNsaWVudFggJiYgIWNsaWVudFkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FudmFzWCA9IGNsaWVudFggLSBib3VuZGluZ1JlY3QubGVmdDtcbiAgICAgICAgdmFyIGNhbnZhc1kgPSBjbGllbnRZIC0gYm91bmRpbmdSZWN0LnRvcDtcbiAgICAgICAgdmFyIGZvcndhcmRNYXRyaXggPSByaXZlLmNvbXB1dGVBbGlnbm1lbnQoZml0LCBhbGlnbm1lbnQsIHtcbiAgICAgICAgICAgIG1pblg6IDAsXG4gICAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgICAgbWF4WDogYm91bmRpbmdSZWN0LndpZHRoLFxuICAgICAgICAgICAgbWF4WTogYm91bmRpbmdSZWN0LmhlaWdodCxcbiAgICAgICAgfSwgYXJ0Ym9hcmQuYm91bmRzLCBsYXlvdXRTY2FsZUZhY3Rvcik7XG4gICAgICAgIHZhciBpbnZlcnRlZE1hdHJpeCA9IG5ldyByaXZlLk1hdDJEKCk7XG4gICAgICAgIGZvcndhcmRNYXRyaXguaW52ZXJ0KGludmVydGVkTWF0cml4KTtcbiAgICAgICAgdmFyIGNhbnZhc0Nvb3JkaW5hdGVzVmVjdG9yID0gbmV3IHJpdmUuVmVjMkQoY2FudmFzWCwgY2FudmFzWSk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZFZlY3RvciA9IHJpdmUubWFwWFkoaW52ZXJ0ZWRNYXRyaXgsIGNhbnZhc0Nvb3JkaW5hdGVzVmVjdG9yKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkVmVjdG9yLngoKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkVmVjdG9yLnkoKTtcbiAgICAgICAgdHJhbnNmb3JtZWRWZWN0b3IuZGVsZXRlKCk7XG4gICAgICAgIGludmVydGVkTWF0cml4LmRlbGV0ZSgpO1xuICAgICAgICBjYW52YXNDb29yZGluYXRlc1ZlY3Rvci5kZWxldGUoKTtcbiAgICAgICAgZm9yd2FyZE1hdHJpeC5kZWxldGUoKTtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZXJlJ3MgYSAycHggYnVmZmVyIGZvciBhIGhpdFJhZGl1cyB3aGVuIHRyYW5zbGF0aW5nIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgKiBkb3duIHRvIHRoZSBzdGF0ZSBtYWNoaW5lLiBJbiBjYXNlcyB3aGVyZSB0aGUgaGl0Ym94IGlzIGFib3V0IHRoYXQgbXVjaCBhd2F5XG4gICAgICAgICAgICAgKiBmcm9tIHRoZSBBcnRib2FyZCBib3JkZXIsIHdlIGRvbid0IGhhdmUgZXhhY3QgcHJlY2lzaW9uIG9uIGRldGVybWluaW5nIHBvaW50ZXJcbiAgICAgICAgICAgICAqIGV4aXQuIFdlJ3JlIHRoZXJlZm9yZSBhZGRpbmcgdG8gdGhlIHRyYW5zbGF0ZWQgY29vcmRpbmF0ZXMgb24gbW91c2VvdXQgb2YgYSBjYW52YXNcbiAgICAgICAgICAgICAqIHRvIGVuc3VyZSB0aGF0IHdlIHJlcG9ydCB0aGUgbW91c2UgaGFzIHRydWx5IGV4aXRlZCB0aGUgaGl0YXJlYS5cbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yaXZlLWFwcC9yaXZlLWNwcC9ibG9iL21hc3Rlci9zcmMvYW5pbWF0aW9uL3N0YXRlX21hY2hpbmVfaW5zdGFuY2UuY3BwI0wzMzZcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBXZSBhZGQvc3VidHJhY3QgMTAwMDAgdG8gYWNjb3VudCBmb3Igd2hlbiB0aGUgZ3JhcGhpYyBnb2VzIGJleW9uZCB0aGUgY2FudmFzIGJvdW5kXG4gICAgICAgICAgICAgKiBkdWUgdG8gZm9yIGV4YW1wbGUsIGEgZml0OiAnY292ZXInLiBOb3QgcGVyZmVjdCwgYnV0IGhlbHBzIHJlbGlhYmx5IChmb3Igbm93KSBlbnN1cmVcbiAgICAgICAgICAgICAqIHdlIHJlcG9ydCBnb2luZyBvdXQgb2YgYm91bmRzIHdoZW4gdGhlIG1vdXNlIGlzIG91dCBvZiB0aGUgY2FudmFzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc3RhdGVNYWNoaW5lc18xID0gc3RhdGVNYWNoaW5lczsgX2kgPCBzdGF0ZU1hY2hpbmVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZU1hY2hpbmUgPSBzdGF0ZU1hY2hpbmVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU1hY2hpbmUucG9pbnRlck1vdmUodHJhbnNmb3JtZWRYLCB0cmFuc2Zvcm1lZFkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFBvaW50ZXIgbW92aW5nL2hvdmVyaW5nIG9uIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZW1vdmVcIjoge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgc3RhdGVNYWNoaW5lc18yID0gc3RhdGVNYWNoaW5lczsgX2IgPCBzdGF0ZU1hY2hpbmVzXzIubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZU1hY2hpbmUgPSBzdGF0ZU1hY2hpbmVzXzJbX2JdO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU1hY2hpbmUucG9pbnRlck1vdmUodHJhbnNmb3JtZWRYLCB0cmFuc2Zvcm1lZFkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvaW50ZXIgY2xpY2sgaW5pdGlhdGVkIGJ1dCBub3QgcmVsZWFzZWQgeWV0IG9uIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgICAgICBjYXNlIFwibW91c2Vkb3duXCI6IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IDAsIHN0YXRlTWFjaGluZXNfMyA9IHN0YXRlTWFjaGluZXM7IF9jIDwgc3RhdGVNYWNoaW5lc18zLmxlbmd0aDsgX2MrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGVNYWNoaW5lID0gc3RhdGVNYWNoaW5lc18zW19jXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNYWNoaW5lLnBvaW50ZXJEb3duKHRyYW5zZm9ybWVkWCwgdHJhbnNmb3JtZWRZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb2ludGVyIGNsaWNrIHJlbGVhc2VkIG9uIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICAgICAgY2FzZSBcIm1vdXNldXBcIjoge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgc3RhdGVNYWNoaW5lc180ID0gc3RhdGVNYWNoaW5lczsgX2QgPCBzdGF0ZU1hY2hpbmVzXzQubGVuZ3RoOyBfZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZU1hY2hpbmUgPSBzdGF0ZU1hY2hpbmVzXzRbX2RdO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZU1hY2hpbmUucG9pbnRlclVwKHRyYW5zZm9ybWVkWCwgdHJhbnNmb3JtZWRZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2FsbGJhY2sgPSBwcm9jZXNzRXZlbnRDYWxsYmFjay5iaW5kKF90aGlzKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBjYWxsYmFjayk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBjYWxsYmFjayk7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgY2FsbGJhY2spO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGNhbGxiYWNrKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgY2FsbGJhY2spO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGNhbGxiYWNrLCB7XG4gICAgICAgIHBhc3NpdmU6IGlzVG91Y2hTY3JvbGxFbmFibGVkLFxuICAgIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBjYWxsYmFjaywge1xuICAgICAgICBwYXNzaXZlOiBpc1RvdWNoU2Nyb2xsRW5hYmxlZCxcbiAgICB9KTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBjYWxsYmFjayk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgY2FsbGJhY2spO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBjYWxsYmFjayk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGNhbGxiYWNrKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgY2FsbGJhY2spO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgY2FsbGJhY2spO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQkxBTktfVVJMOiAoKSA9PiAoLyogYmluZGluZyAqLyBCTEFOS19VUkwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBzYW5pdGl6ZVVybDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gc2FuaXRpemVVcmwpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8vIFJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL2JyYWludHJlZS9zYW5pdGl6ZS11cmwvdHJlZS9tYWluXG52YXIgaW52YWxpZFByb3RvY29sUmVnZXggPSAvXihbXlxcd10qKShqYXZhc2NyaXB0fGRhdGF8dmJzY3JpcHQpL2ltO1xudmFyIGh0bWxFbnRpdGllc1JlZ2V4ID0gLyYjKFxcdyspKF5cXHd8Oyk/L2c7XG52YXIgaHRtbEN0cmxFbnRpdHlSZWdleCA9IC8mKG5ld2xpbmV8dGFiKTsvZ2k7XG52YXIgY3RybENoYXJhY3RlcnNSZWdleCA9IC9bXFx1MDAwMC1cXHUwMDFGXFx1MDA3Ri1cXHUwMDlGXFx1MjAwMC1cXHUyMDBEXFx1RkVGRl0vZ2ltO1xudmFyIHVybFNjaGVtZVJlZ2V4ID0gL14uKyg6fCZjb2xvbjspL2dpbTtcbnZhciByZWxhdGl2ZUZpcnN0Q2hhcmFjdGVycyA9IFtcIi5cIiwgXCIvXCJdO1xudmFyIEJMQU5LX1VSTCA9IFwiYWJvdXQ6YmxhbmtcIjtcbmZ1bmN0aW9uIGlzUmVsYXRpdmVVcmxXaXRob3V0UHJvdG9jb2wodXJsKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlRmlyc3RDaGFyYWN0ZXJzLmluZGV4T2YodXJsWzBdKSA+IC0xO1xufVxuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yOTgyNDU1MC8yNjAxNTUyXG5mdW5jdGlvbiBkZWNvZGVIdG1sQ2hhcmFjdGVycyhzdHIpIHtcbiAgICB2YXIgcmVtb3ZlZE51bGxCeXRlID0gc3RyLnJlcGxhY2UoY3RybENoYXJhY3RlcnNSZWdleCwgXCJcIik7XG4gICAgcmV0dXJuIHJlbW92ZWROdWxsQnl0ZS5yZXBsYWNlKGh0bWxFbnRpdGllc1JlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIGRlYykge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShkZWMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgcmV0dXJuIEJMQU5LX1VSTDtcbiAgICB9XG4gICAgdmFyIHNhbml0aXplZFVybCA9IGRlY29kZUh0bWxDaGFyYWN0ZXJzKHVybClcbiAgICAgICAgLnJlcGxhY2UoaHRtbEN0cmxFbnRpdHlSZWdleCwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoY3RybENoYXJhY3RlcnNSZWdleCwgXCJcIilcbiAgICAgICAgLnRyaW0oKTtcbiAgICBpZiAoIXNhbml0aXplZFVybCkge1xuICAgICAgICByZXR1cm4gQkxBTktfVVJMO1xuICAgIH1cbiAgICBpZiAoaXNSZWxhdGl2ZVVybFdpdGhvdXRQcm90b2NvbChzYW5pdGl6ZWRVcmwpKSB7XG4gICAgICAgIHJldHVybiBzYW5pdGl6ZWRVcmw7XG4gICAgfVxuICAgIHZhciB1cmxTY2hlbWVQYXJzZVJlc3VsdHMgPSBzYW5pdGl6ZWRVcmwubWF0Y2godXJsU2NoZW1lUmVnZXgpO1xuICAgIGlmICghdXJsU2NoZW1lUGFyc2VSZXN1bHRzKSB7XG4gICAgICAgIHJldHVybiBzYW5pdGl6ZWRVcmw7XG4gICAgfVxuICAgIHZhciB1cmxTY2hlbWUgPSB1cmxTY2hlbWVQYXJzZVJlc3VsdHNbMF07XG4gICAgaWYgKGludmFsaWRQcm90b2NvbFJlZ2V4LnRlc3QodXJsU2NoZW1lKSkge1xuICAgICAgICByZXR1cm4gQkxBTktfVVJMO1xuICAgIH1cbiAgICByZXR1cm4gc2FuaXRpemVkVXJsO1xufVxuXG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IHt9O1xuLy8gVGhpcyBlbnRyeSBuZWVkcyB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuKCgpID0+IHtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEFsaWdubWVudDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQWxpZ25tZW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGF0YUVudW06ICgpID0+ICgvKiBiaW5kaW5nICovIERhdGFFbnVtKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRXZlbnRUeXBlOiAoKSA9PiAoLyogYmluZGluZyAqLyBFdmVudFR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBGaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIEZpdCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIExheW91dDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gTGF5b3V0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9vcFR5cGU6ICgpID0+ICgvKiBiaW5kaW5nICovIExvb3BUeXBlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgUml2ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUml2ZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFJpdmVFdmVudFR5cGU6ICgpID0+ICgvKiBiaW5kaW5nICovIFJpdmVFdmVudFR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSaXZlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUml2ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSdW50aW1lTG9hZGVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBSdW50aW1lTG9hZGVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3RhdGVNYWNoaW5lSW5wdXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFN0YXRlTWFjaGluZUlucHV0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3RhdGVNYWNoaW5lSW5wdXRUeXBlOiAoKSA9PiAoLyogYmluZGluZyAqLyBTdGF0ZU1hY2hpbmVJbnB1dFR5cGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXN0aW5nOiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXN0aW5nKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVmlld01vZGVsOiAoKSA9PiAoLyogYmluZGluZyAqLyBWaWV3TW9kZWwpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBWaWV3TW9kZWxJbnN0YW5jZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVmlld01vZGVsSW5zdGFuY2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBWaWV3TW9kZWxJbnN0YW5jZUJvb2xlYW46ICgpID0+ICgvKiBiaW5kaW5nICovIFZpZXdNb2RlbEluc3RhbmNlQm9vbGVhbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZpZXdNb2RlbEluc3RhbmNlQ29sb3I6ICgpID0+ICgvKiBiaW5kaW5nICovIFZpZXdNb2RlbEluc3RhbmNlQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBWaWV3TW9kZWxJbnN0YW5jZUVudW06ICgpID0+ICgvKiBiaW5kaW5nICovIFZpZXdNb2RlbEluc3RhbmNlRW51bSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZpZXdNb2RlbEluc3RhbmNlTnVtYmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBWaWV3TW9kZWxJbnN0YW5jZU51bWJlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZpZXdNb2RlbEluc3RhbmNlU3RyaW5nOiAoKSA9PiAoLyogYmluZGluZyAqLyBWaWV3TW9kZWxJbnN0YW5jZVN0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZpZXdNb2RlbEluc3RhbmNlVHJpZ2dlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVmlld01vZGVsSW5zdGFuY2VUcmlnZ2VyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVmlld01vZGVsSW5zdGFuY2VWYWx1ZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVmlld01vZGVsSW5zdGFuY2VWYWx1ZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGRlY29kZUF1ZGlvOiAoKSA9PiAoLyogYmluZGluZyAqLyBkZWNvZGVBdWRpbyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIGRlY29kZUZvbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIGRlY29kZUZvbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBkZWNvZGVJbWFnZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZGVjb2RlSW1hZ2UpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcml2ZV9hZHZhbmNlZF9tanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGFja2FnZV9qc29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9hbmltYXRpb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIF9fZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICAgIHJldHVybiBnLm5leHQgPSB2ZXJiKDApLCBnW1widGhyb3dcIl0gPSB2ZXJiKDEpLCBnW1wicmV0dXJuXCJdID0gdmVyYigyKSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcblxuXG5cblxudmFyIFJpdmVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUml2ZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJpdmVFcnJvcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzSGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUml2ZUVycm9yO1xufShFcnJvcikpO1xuLy8gI3JlZ2lvbnMgaGVscGVyc1xudmFyIHJlc29sdmVFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IuaXNIYW5kbGVkRXJyb3JcbiAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgIDogXCJQcm9ibGVtIGxvYWRpbmcgZmlsZTsgbWF5IGJlIGNvcnJ1cHQhXCI7XG59O1xuLy8gI3JlZ2lvbiBsYXlvdXRcbi8vIEZpdCBvcHRpb25zIGZvciB0aGUgY2FudmFzXG52YXIgRml0O1xuKGZ1bmN0aW9uIChGaXQpIHtcbiAgICBGaXRbXCJDb3ZlclwiXSA9IFwiY292ZXJcIjtcbiAgICBGaXRbXCJDb250YWluXCJdID0gXCJjb250YWluXCI7XG4gICAgRml0W1wiRmlsbFwiXSA9IFwiZmlsbFwiO1xuICAgIEZpdFtcIkZpdFdpZHRoXCJdID0gXCJmaXRXaWR0aFwiO1xuICAgIEZpdFtcIkZpdEhlaWdodFwiXSA9IFwiZml0SGVpZ2h0XCI7XG4gICAgRml0W1wiTm9uZVwiXSA9IFwibm9uZVwiO1xuICAgIEZpdFtcIlNjYWxlRG93blwiXSA9IFwic2NhbGVEb3duXCI7XG4gICAgRml0W1wiTGF5b3V0XCJdID0gXCJsYXlvdXRcIjtcbn0pKEZpdCB8fCAoRml0ID0ge30pKTtcbi8vIEFsaWdubWVudCBvcHRpb25zIGZvciB0aGUgY2FudmFzXG52YXIgQWxpZ25tZW50O1xuKGZ1bmN0aW9uIChBbGlnbm1lbnQpIHtcbiAgICBBbGlnbm1lbnRbXCJDZW50ZXJcIl0gPSBcImNlbnRlclwiO1xuICAgIEFsaWdubWVudFtcIlRvcExlZnRcIl0gPSBcInRvcExlZnRcIjtcbiAgICBBbGlnbm1lbnRbXCJUb3BDZW50ZXJcIl0gPSBcInRvcENlbnRlclwiO1xuICAgIEFsaWdubWVudFtcIlRvcFJpZ2h0XCJdID0gXCJ0b3BSaWdodFwiO1xuICAgIEFsaWdubWVudFtcIkNlbnRlckxlZnRcIl0gPSBcImNlbnRlckxlZnRcIjtcbiAgICBBbGlnbm1lbnRbXCJDZW50ZXJSaWdodFwiXSA9IFwiY2VudGVyUmlnaHRcIjtcbiAgICBBbGlnbm1lbnRbXCJCb3R0b21MZWZ0XCJdID0gXCJib3R0b21MZWZ0XCI7XG4gICAgQWxpZ25tZW50W1wiQm90dG9tQ2VudGVyXCJdID0gXCJib3R0b21DZW50ZXJcIjtcbiAgICBBbGlnbm1lbnRbXCJCb3R0b21SaWdodFwiXSA9IFwiYm90dG9tUmlnaHRcIjtcbn0pKEFsaWdubWVudCB8fCAoQWxpZ25tZW50ID0ge30pKTtcbi8vIEFsaWdubWVudCBvcHRpb25zIGZvciBSaXZlIGFuaW1hdGlvbnMgaW4gYSBIVE1MIGNhbnZhc1xudmFyIExheW91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXlvdXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdGhpcy5maXQgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuZml0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBGaXQuQ29udGFpbjtcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSAoX2IgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYWxpZ25tZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBBbGlnbm1lbnQuQ2VudGVyO1xuICAgICAgICB0aGlzLmxheW91dFNjYWxlRmFjdG9yID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmxheW91dFNjYWxlRmFjdG9yKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAxO1xuICAgICAgICB0aGlzLm1pblggPSAoX2QgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMubWluWCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcbiAgICAgICAgdGhpcy5taW5ZID0gKF9lID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm1pblkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgIHRoaXMubWF4WCA9IChfZiA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5tYXhYKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwO1xuICAgICAgICB0aGlzLm1heFkgPSAoX2cgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMubWF4WSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMDtcbiAgICB9XG4gICAgLy8gQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgdG8gYnVpbGQgYSBMYXlvdXQgZnJvbSBhbiBpbnRlcmZhY2Uvb2JqZWN0XG4gICAgTGF5b3V0Lm5ldyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZml0ID0gX2EuZml0LCBhbGlnbm1lbnQgPSBfYS5hbGlnbm1lbnQsIG1pblggPSBfYS5taW5YLCBtaW5ZID0gX2EubWluWSwgbWF4WCA9IF9hLm1heFgsIG1heFkgPSBfYS5tYXhZO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ6IHBsZWFzZSB1c2UgYG5ldyBMYXlvdXQoe30pYCBpbnN0ZWFkXCIpO1xuICAgICAgICByZXR1cm4gbmV3IExheW91dCh7IGZpdDogZml0LCBhbGlnbm1lbnQ6IGFsaWdubWVudCwgbWluWDogbWluWCwgbWluWTogbWluWSwgbWF4WDogbWF4WCwgbWF4WTogbWF4WSB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY29weSBvZiB0aGUgbGF5b3V0LCByZXBsYWNpbmcgYW55IHNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgTGF5b3V0LnByb3RvdHlwZS5jb3B5V2l0aCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgZml0ID0gX2EuZml0LCBhbGlnbm1lbnQgPSBfYS5hbGlnbm1lbnQsIGxheW91dFNjYWxlRmFjdG9yID0gX2EubGF5b3V0U2NhbGVGYWN0b3IsIG1pblggPSBfYS5taW5YLCBtaW5ZID0gX2EubWluWSwgbWF4WCA9IF9hLm1heFgsIG1heFkgPSBfYS5tYXhZO1xuICAgICAgICByZXR1cm4gbmV3IExheW91dCh7XG4gICAgICAgICAgICBmaXQ6IGZpdCAhPT0gbnVsbCAmJiBmaXQgIT09IHZvaWQgMCA/IGZpdCA6IHRoaXMuZml0LFxuICAgICAgICAgICAgYWxpZ25tZW50OiBhbGlnbm1lbnQgIT09IG51bGwgJiYgYWxpZ25tZW50ICE9PSB2b2lkIDAgPyBhbGlnbm1lbnQgOiB0aGlzLmFsaWdubWVudCxcbiAgICAgICAgICAgIGxheW91dFNjYWxlRmFjdG9yOiBsYXlvdXRTY2FsZUZhY3RvciAhPT0gbnVsbCAmJiBsYXlvdXRTY2FsZUZhY3RvciAhPT0gdm9pZCAwID8gbGF5b3V0U2NhbGVGYWN0b3IgOiB0aGlzLmxheW91dFNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgbWluWDogbWluWCAhPT0gbnVsbCAmJiBtaW5YICE9PSB2b2lkIDAgPyBtaW5YIDogdGhpcy5taW5YLFxuICAgICAgICAgICAgbWluWTogbWluWSAhPT0gbnVsbCAmJiBtaW5ZICE9PSB2b2lkIDAgPyBtaW5ZIDogdGhpcy5taW5ZLFxuICAgICAgICAgICAgbWF4WDogbWF4WCAhPT0gbnVsbCAmJiBtYXhYICE9PSB2b2lkIDAgPyBtYXhYIDogdGhpcy5tYXhYLFxuICAgICAgICAgICAgbWF4WTogbWF4WSAhPT0gbnVsbCAmJiBtYXhZICE9PSB2b2lkIDAgPyBtYXhZIDogdGhpcy5tYXhZLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgZml0IGZvciB0aGUgV2FzbSBydW50aW1lIGZvcm1hdFxuICAgIExheW91dC5wcm90b3R5cGUucnVudGltZUZpdCA9IGZ1bmN0aW9uIChyaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFJ1bnRpbWVGaXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRSdW50aW1lRml0O1xuICAgICAgICB2YXIgZml0O1xuICAgICAgICBpZiAodGhpcy5maXQgPT09IEZpdC5Db3ZlcilcbiAgICAgICAgICAgIGZpdCA9IHJpdmUuRml0LmNvdmVyO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LkNvbnRhaW4pXG4gICAgICAgICAgICBmaXQgPSByaXZlLkZpdC5jb250YWluO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LkZpbGwpXG4gICAgICAgICAgICBmaXQgPSByaXZlLkZpdC5maWxsO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LkZpdFdpZHRoKVxuICAgICAgICAgICAgZml0ID0gcml2ZS5GaXQuZml0V2lkdGg7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZml0ID09PSBGaXQuRml0SGVpZ2h0KVxuICAgICAgICAgICAgZml0ID0gcml2ZS5GaXQuZml0SGVpZ2h0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZpdCA9PT0gRml0LlNjYWxlRG93bilcbiAgICAgICAgICAgIGZpdCA9IHJpdmUuRml0LnNjYWxlRG93bjtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5maXQgPT09IEZpdC5MYXlvdXQpXG4gICAgICAgICAgICBmaXQgPSByaXZlLkZpdC5sYXlvdXQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpdCA9IHJpdmUuRml0Lm5vbmU7XG4gICAgICAgIHRoaXMuY2FjaGVkUnVudGltZUZpdCA9IGZpdDtcbiAgICAgICAgcmV0dXJuIGZpdDtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgYWxpZ25tZW50IGZvciB0aGUgV2FzbSBydW50aW1lIGZvcm1hdFxuICAgIExheW91dC5wcm90b3R5cGUucnVudGltZUFsaWdubWVudCA9IGZ1bmN0aW9uIChyaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFJ1bnRpbWVBbGlnbm1lbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRSdW50aW1lQWxpZ25tZW50O1xuICAgICAgICB2YXIgYWxpZ25tZW50O1xuICAgICAgICBpZiAodGhpcy5hbGlnbm1lbnQgPT09IEFsaWdubWVudC5Ub3BMZWZ0KVxuICAgICAgICAgICAgYWxpZ25tZW50ID0gcml2ZS5BbGlnbm1lbnQudG9wTGVmdDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbGlnbm1lbnQgPT09IEFsaWdubWVudC5Ub3BDZW50ZXIpXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSByaXZlLkFsaWdubWVudC50b3BDZW50ZXI7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWxpZ25tZW50ID09PSBBbGlnbm1lbnQuVG9wUmlnaHQpXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSByaXZlLkFsaWdubWVudC50b3BSaWdodDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbGlnbm1lbnQgPT09IEFsaWdubWVudC5DZW50ZXJMZWZ0KVxuICAgICAgICAgICAgYWxpZ25tZW50ID0gcml2ZS5BbGlnbm1lbnQuY2VudGVyTGVmdDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbGlnbm1lbnQgPT09IEFsaWdubWVudC5DZW50ZXJSaWdodClcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LmNlbnRlclJpZ2h0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LkJvdHRvbUxlZnQpXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSByaXZlLkFsaWdubWVudC5ib3R0b21MZWZ0O1xuICAgICAgICBlbHNlIGlmICh0aGlzLmFsaWdubWVudCA9PT0gQWxpZ25tZW50LkJvdHRvbUNlbnRlcilcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LmJvdHRvbUNlbnRlcjtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbGlnbm1lbnQgPT09IEFsaWdubWVudC5Cb3R0b21SaWdodClcbiAgICAgICAgICAgIGFsaWdubWVudCA9IHJpdmUuQWxpZ25tZW50LmJvdHRvbVJpZ2h0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSByaXZlLkFsaWdubWVudC5jZW50ZXI7XG4gICAgICAgIHRoaXMuY2FjaGVkUnVudGltZUFsaWdubWVudCA9IGFsaWdubWVudDtcbiAgICAgICAgcmV0dXJuIGFsaWdubWVudDtcbiAgICB9O1xuICAgIHJldHVybiBMYXlvdXQ7XG59KCkpO1xuXG4vLyBSdW50aW1lIHNpbmdsZXRvbjsgdXNlIGdldEluc3RhbmNlIHRvIHByb3ZpZGUgYSBjYWxsYmFjayB0aGF0IHJldHVybnMgdGhlXG4vLyBSaXZlIHJ1bnRpbWVcbnZhciBSdW50aW1lTG9hZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIENsYXNzIGlzIG5ldmVyIGluc3RhbnRpYXRlZFxuICAgIGZ1bmN0aW9uIFJ1bnRpbWVMb2FkZXIoKSB7XG4gICAgfVxuICAgIC8vIExvYWRzIHRoZSBydW50aW1lXG4gICAgUnVudGltZUxvYWRlci5sb2FkUnVudGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3JpdmVfYWR2YW5jZWRfbWpzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICAgIC8vIExvYWRzIFdhc20gYnVuZGxlXG4gICAgICAgICAgICBsb2NhdGVGaWxlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBSdW50aW1lTG9hZGVyLndhc21VUkw7IH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocml2ZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgUnVudGltZUxvYWRlci5ydW50aW1lID0gcml2ZTtcbiAgICAgICAgICAgIC8vIEZpcmUgYWxsIHRoZSBjYWxsYmFja3NcbiAgICAgICAgICAgIHdoaWxlIChSdW50aW1lTG9hZGVyLmNhbGxCYWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIChfYSA9IFJ1bnRpbWVMb2FkZXIuY2FsbEJhY2tRdWV1ZS5zaGlmdCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoUnVudGltZUxvYWRlci5ydW50aW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgc3BlY2lmaWMgZXJyb3IgZGV0YWlsc1xuICAgICAgICAgICAgdmFyIGVycm9yRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UpIHx8IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubmFtZSkgfHwgXCJFcnJvclwiLFxuICAgICAgICAgICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgbWF5IHByb3ZpZGUgYWRkaXRpb25hbCBXZWJBc3NlbWJseS1zcGVjaWZpYyBkZXRhaWxzXG4gICAgICAgICAgICAgICAgd2FzbUVycm9yOiBlcnJvciBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5LkNvbXBpbGVFcnJvciB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcixcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBMb2cgZGV0YWlsZWQgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlJpdmUgV0FTTSBsb2FkIGVycm9yIGRldGFpbHM6XCIsIGVycm9yRGV0YWlscyk7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIHVucGtnIGZhaWxzLCBvciB0aGUgd2FzbSB3YXMgbm90IHN1cHBvcnRlZCwgd2UgdHJ5IHRvIGxvYWQgdGhlIGZhbGxiYWNrIG1vZHVsZSBmcm9tIGpzZGVsaXZyLlxuICAgICAgICAgICAgLy8gVGhpcyBgcml2ZV9mYWxsYmFjay53YXNtYCBpcyBjb21waWxlZCB0byBzdXBwb3J0IG9sZGVyIGFyY2hpdGVjdHVyZS5cbiAgICAgICAgICAgIC8vIFRPRE86IChHb3Jkb24pOiBwcmVlbXB0aXZlbHkgdGVzdCBicm93c2VyIHN1cHBvcnQgYW5kIGxvYWQgdGhlIGNvcnJlY3Qgd2FzbSBmaWxlLiBUaGVuIHVzZSBqc2RlbHZyIG9ubHkgaWYgdW5wa2cgZmFpbHMuXG4gICAgICAgICAgICB2YXIgYmFja3VwSnNkZWxpdnJVcmwgPSBcImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vXCIuY29uY2F0KHBhY2thZ2VfanNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLm5hbWUsIFwiQFwiKS5jb25jYXQocGFja2FnZV9qc29uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18udmVyc2lvbiwgXCIvcml2ZV9mYWxsYmFjay53YXNtXCIpO1xuICAgICAgICAgICAgaWYgKFJ1bnRpbWVMb2FkZXIud2FzbVVSTC50b0xvd2VyQ2FzZSgpICE9PSBiYWNrdXBKc2RlbGl2clVybCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBsb2FkIFdBU00gZnJvbSBcIi5jb25jYXQoUnVudGltZUxvYWRlci53YXNtVVJMLCBcIiAoXCIpLmNvbmNhdChlcnJvckRldGFpbHMubWVzc2FnZSwgXCIpLCB0cnlpbmcganNkZWxpdnIgYXMgYSBiYWNrdXBcIikpO1xuICAgICAgICAgICAgICAgIFJ1bnRpbWVMb2FkZXIuc2V0V2FzbVVybChiYWNrdXBKc2RlbGl2clVybCk7XG4gICAgICAgICAgICAgICAgUnVudGltZUxvYWRlci5sb2FkUnVudGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgXCJDb3VsZCBub3QgbG9hZCBSaXZlIFdBU00gZmlsZSBmcm9tIFwiLmNvbmNhdChSdW50aW1lTG9hZGVyLndhc21VUkwsIFwiIG9yIFwiKS5jb25jYXQoYmFja3VwSnNkZWxpdnJVcmwsIFwiLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgXCJQb3NzaWJsZSByZWFzb25zOlwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0gTmV0d29yayBjb25uZWN0aW9uIGlzIGRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgXCItIFdlYkFzc2VtYmx5IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiLFxuICAgICAgICAgICAgICAgICAgICBcIi0gVGhlIFdBU00gZmlsZSBpcyBjb3JydXB0ZWQgb3IgaW5jb21wYXRpYmxlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuRXJyb3IgZGV0YWlsczpcIixcbiAgICAgICAgICAgICAgICAgICAgXCItIFR5cGU6IFwiLmNvbmNhdChlcnJvckRldGFpbHMudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIFwiLSBNZXNzYWdlOiBcIi5jb25jYXQoZXJyb3JEZXRhaWxzLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICBcIi0gV2ViQXNzZW1ibHktc3BlY2lmaWMgZXJyb3I6IFwiLmNvbmNhdChlcnJvckRldGFpbHMud2FzbUVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgXCJcXG5UbyByZXNvbHZlLCB5b3UgbWF5IG5lZWQgdG86XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiMS4gQ2hlY2sgeW91ciBuZXR3b3JrIGNvbm5lY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgXCIyLiBTZXQgYSBuZXcgV0FTTSBzb3VyY2UgdmlhIFJ1bnRpbWVMb2FkZXIuc2V0V2FzbVVybCgpXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiMy4gQ2FsbCBSdW50aW1lTG9hZGVyLmxvYWRSdW50aW1lKCkgYWdhaW5cIixcbiAgICAgICAgICAgICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFByb3ZpZGVzIGEgcnVudGltZSBpbnN0YW5jZSB2aWEgYSBjYWxsYmFja1xuICAgIFJ1bnRpbWVMb2FkZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gSWYgaXQncyBub3QgbG9hZGluZywgc3RhcnQgbG9hZGluZyBydW50aW1lXG4gICAgICAgIGlmICghUnVudGltZUxvYWRlci5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIFJ1bnRpbWVMb2FkZXIuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFJ1bnRpbWVMb2FkZXIubG9hZFJ1bnRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVJ1bnRpbWVMb2FkZXIucnVudGltZSkge1xuICAgICAgICAgICAgUnVudGltZUxvYWRlci5jYWxsQmFja1F1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soUnVudGltZUxvYWRlci5ydW50aW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gUHJvdmlkZXMgYSBydW50aW1lIGluc3RhbmNlIHZpYSBhIHByb21pc2VcbiAgICBSdW50aW1lTG9hZGVyLmF3YWl0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJ1bnRpbWVMb2FkZXIuZ2V0SW5zdGFuY2UoZnVuY3Rpb24gKHJpdmUpIHsgcmV0dXJuIHJlc29sdmUocml2ZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIE1hbnVhbGx5IHNldHMgdGhlIHdhc20gdXJsXG4gICAgUnVudGltZUxvYWRlci5zZXRXYXNtVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICBSdW50aW1lTG9hZGVyLndhc21VUkwgPSB1cmw7XG4gICAgfTtcbiAgICAvLyBHZXRzIHRoZSBjdXJyZW50IHdhc20gdXJsXG4gICAgUnVudGltZUxvYWRlci5nZXRXYXNtVXJsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUnVudGltZUxvYWRlci53YXNtVVJMO1xuICAgIH07XG4gICAgLy8gRmxhZyB0byBpbmRpY2F0ZSB0aGF0IGxvYWRpbmcgaGFzIHN0YXJ0ZWQvY29tcGxldGVkXG4gICAgUnVudGltZUxvYWRlci5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAvLyBMaXN0IG9mIGNhbGxiYWNrcyBmb3IgdGhlIHJ1bnRpbWUgdGhhdCBjb21lIGluIHdoaWxlIGxvYWRpbmdcbiAgICBSdW50aW1lTG9hZGVyLmNhbGxCYWNrUXVldWUgPSBbXTtcbiAgICAvLyBQYXRoIHRvIHRoZSBXYXNtIGZpbGU7IGRlZmF1bHQgcGF0aCB3b3JrcyBmb3IgdGVzdGluZyBvbmx5O1xuICAgIC8vIGlmIGVtYmVkZGVkIHdhc20gaXMgdXNlZCB0aGVuIHRoaXMgaXMgbmV2ZXIgdXNlZC5cbiAgICBSdW50aW1lTG9hZGVyLndhc21VUkwgPSBcImh0dHBzOi8vdW5wa2cuY29tL1wiLmNvbmNhdChwYWNrYWdlX2pzb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5uYW1lLCBcIkBcIikuY29uY2F0KHBhY2thZ2VfanNvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnZlcnNpb24sIFwiL3JpdmUud2FzbVwiKTtcbiAgICByZXR1cm4gUnVudGltZUxvYWRlcjtcbn0oKSk7XG5cbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gc3RhdGUgbWFjaGluZXNcbnZhciBTdGF0ZU1hY2hpbmVJbnB1dFR5cGU7XG4oZnVuY3Rpb24gKFN0YXRlTWFjaGluZUlucHV0VHlwZSkge1xuICAgIFN0YXRlTWFjaGluZUlucHV0VHlwZVtTdGF0ZU1hY2hpbmVJbnB1dFR5cGVbXCJOdW1iZXJcIl0gPSA1Nl0gPSBcIk51bWJlclwiO1xuICAgIFN0YXRlTWFjaGluZUlucHV0VHlwZVtTdGF0ZU1hY2hpbmVJbnB1dFR5cGVbXCJUcmlnZ2VyXCJdID0gNThdID0gXCJUcmlnZ2VyXCI7XG4gICAgU3RhdGVNYWNoaW5lSW5wdXRUeXBlW1N0YXRlTWFjaGluZUlucHV0VHlwZVtcIkJvb2xlYW5cIl0gPSA1OV0gPSBcIkJvb2xlYW5cIjtcbn0pKFN0YXRlTWFjaGluZUlucHV0VHlwZSB8fCAoU3RhdGVNYWNoaW5lSW5wdXRUeXBlID0ge30pKTtcbi8qKlxuICogQW4gaW5wdXQgZm9yIGEgc3RhdGUgbWFjaGluZVxuICovXG52YXIgU3RhdGVNYWNoaW5lSW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGVNYWNoaW5lSW5wdXQodHlwZSwgcnVudGltZUlucHV0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucnVudGltZUlucHV0ID0gcnVudGltZUlucHV0O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNYWNoaW5lSW5wdXQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVudGltZUlucHV0Lm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNYWNoaW5lSW5wdXQucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWVJbnB1dC52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucnVudGltZUlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGaXJlcyBhIHRyaWdnZXI7IGRvZXMgbm90aGluZyBvbiBOdW1iZXIgb3IgQm9vbGVhbiBpbnB1dCB0eXBlc1xuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZUlucHV0LnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBTdGF0ZU1hY2hpbmVJbnB1dFR5cGUuVHJpZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5ydW50aW1lSW5wdXQuZmlyZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBpbnB1dFxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZUlucHV0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucnVudGltZUlucHV0ID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZU1hY2hpbmVJbnB1dDtcbn0oKSk7XG5cbnZhciBSaXZlRXZlbnRUeXBlO1xuKGZ1bmN0aW9uIChSaXZlRXZlbnRUeXBlKSB7XG4gICAgUml2ZUV2ZW50VHlwZVtSaXZlRXZlbnRUeXBlW1wiR2VuZXJhbFwiXSA9IDEyOF0gPSBcIkdlbmVyYWxcIjtcbiAgICBSaXZlRXZlbnRUeXBlW1JpdmVFdmVudFR5cGVbXCJPcGVuVXJsXCJdID0gMTMxXSA9IFwiT3BlblVybFwiO1xufSkoUml2ZUV2ZW50VHlwZSB8fCAoUml2ZUV2ZW50VHlwZSA9IHt9KSk7XG52YXIgU3RhdGVNYWNoaW5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBzdGF0ZU1hY2hpbmUgcnVudGltZSBzdGF0ZSBtYWNoaW5lIG9iamVjdFxuICAgICAqIEBwYXJhbSBpbnN0YW5jZSBydW50aW1lIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2Ugb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVNYWNoaW5lKHN0YXRlTWFjaGluZSwgcnVudGltZSwgcGxheWluZywgYXJ0Ym9hcmQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmUgPSBzdGF0ZU1hY2hpbmU7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHBsYXlpbmc7XG4gICAgICAgIHRoaXMuYXJ0Ym9hcmQgPSBhcnRib2FyZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlcyB0aGUgaW5wdXRzIGZyb20gdGhlIHJ1bnRpbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgcnVudGltZS5TdGF0ZU1hY2hpbmVJbnN0YW5jZShzdGF0ZU1hY2hpbmUsIGFydGJvYXJkKTtcbiAgICAgICAgdGhpcy5pbml0SW5wdXRzKHJ1bnRpbWUpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVNYWNoaW5lLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU1hY2hpbmUubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZU1hY2hpbmUucHJvdG90eXBlLCBcInN0YXRlc0NoYW5nZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygc3RhdGUgbmFtZXMgdGhhdCBoYXZlIGNoYW5nZWQgb24gdGhpcyBmcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnN0YW5jZS5zdGF0ZUNoYW5nZWRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHRoaXMuaW5zdGFuY2Uuc3RhdGVDaGFuZ2VkTmFtZUJ5SW5kZXgoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdGhlIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2UgYnkgYSBnaXZlbiB0aW1lLlxuICAgICAqIEBwYXJhbSB0aW1lIC0gdGhlIHRpbWUgdG8gYWR2YW5jZSB0aGUgYW5pbWF0aW9uIGJ5IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICBTdGF0ZU1hY2hpbmUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlLmFkdmFuY2UodGltZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgc3RhdGUgbWFjaGluZSBpbnN0YW5jZSBieSBhIGdpdmVuIHRpbWUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gYXJ0Ym9hcmQuXG4gICAgICogQHBhcmFtIHRpbWUgLSB0aGUgdGltZSB0byBhZHZhbmNlIHRoZSBhbmltYXRpb24gYnkgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUuYWR2YW5jZUFuZEFwcGx5ID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5hZHZhbmNlQW5kQXBwbHkodGltZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZXZlbnRzIHJlcG9ydGVkIGZyb20gdGhlIGxhc3QgYWR2YW5jZSBjYWxsXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGV2ZW50cyByZXBvcnRlZFxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUucmVwb3J0ZWRFdmVudENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5yZXBvcnRlZEV2ZW50Q291bnQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBSaXZlRXZlbnQgb2JqZWN0IGVtaXR0ZWQgZnJvbSB0aGUgbGFzdCBhZHZhbmNlIGNhbGwgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgICogb2YgYSBsaXN0IG9mIHBvdGVudGlhbGx5IG11bHRpcGxlIGV2ZW50cy4gSWYgYW4gZXZlbnQgYXQgdGhlIGluZGV4IGlzIG5vdCBmb3VuZCxcbiAgICAgKiB1bmRlZmluZWQgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGkgaW5kZXggb2YgdGhlIGV2ZW50IHJlcG9ydGVkIGluIGEgbGlzdCBvZiBwb3RlbnRpYWxseSBtdWx0aXBsZSBldmVudHNcbiAgICAgKiBAcmV0dXJucyBSaXZlRXZlbnQgb3IgZXh0ZW5kZWQgUml2ZUV2ZW50IG9iamVjdCByZXR1cm5lZCwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5yZXBvcnRlZEV2ZW50QXQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5yZXBvcnRlZEV2ZW50QXQoaSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHJlZmVyZW5jZXMgdG8gdGhlIHN0YXRlIG1hY2hpbmUncyBpbnB1dHMgYW5kIGNhY2hlcyB0aGVtXG4gICAgICogQHBhcmFtIHJ1bnRpbWUgYW4gaW5zdGFuY2Ugb2YgdGhlIHJ1bnRpbWU7IG5lZWRlZCBmb3IgdGhlIFNNSUlucHV0IHR5cGVzXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5pbml0SW5wdXRzID0gZnVuY3Rpb24gKHJ1bnRpbWUpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIGlucHV0cyBmcm9tIHRoZSBydW50aW1lIGlmIHdlIGRvbid0IGhhdmUgdGhlbVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5zdGFuY2UuaW5wdXRDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5zdGFuY2UuaW5wdXQoaSk7XG4gICAgICAgICAgICB0aGlzLmlucHV0cy5wdXNoKHRoaXMubWFwUnVudGltZUlucHV0KGlucHV0LCBydW50aW1lKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcHMgYSBydW50aW1lIGlucHV0IHRvIGl0J3MgYXBwcm9wcmlhdGUgdHlwZVxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqL1xuICAgIFN0YXRlTWFjaGluZS5wcm90b3R5cGUubWFwUnVudGltZUlucHV0ID0gZnVuY3Rpb24gKGlucHV0LCBydW50aW1lKSB7XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSBydW50aW1lLlNNSUlucHV0LmJvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGVNYWNoaW5lSW5wdXQoU3RhdGVNYWNoaW5lSW5wdXRUeXBlLkJvb2xlYW4sIGlucHV0LmFzQm9vbCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC50eXBlID09PSBydW50aW1lLlNNSUlucHV0Lm51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmVJbnB1dChTdGF0ZU1hY2hpbmVJbnB1dFR5cGUuTnVtYmVyLCBpbnB1dC5hc051bWJlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dC50eXBlID09PSBydW50aW1lLlNNSUlucHV0LnRyaWdnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhdGVNYWNoaW5lSW5wdXQoU3RhdGVNYWNoaW5lSW5wdXRUeXBlLlRyaWdnZXIsIGlucHV0LmFzVHJpZ2dlcigpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgYmFja2luZyBXYXNtIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2U7IG9uY2UgdGhpcyBpcyBjYWxsZWQsIHRoaXNcbiAgICAgKiBzdGF0ZSBtYWNoaW5lIGlzIG5vIG1vcmUuXG4gICAgICovXG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaW5wdXQuZGVsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlucHV0cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmluc3RhbmNlLmRlbGV0ZSgpO1xuICAgIH07XG4gICAgU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5iaW5kVmlld01vZGVsSW5zdGFuY2UgPSBmdW5jdGlvbiAodmlld01vZGVsSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHZpZXdNb2RlbEluc3RhbmNlLnJ1bnRpbWVJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmJpbmRWaWV3TW9kZWxJbnN0YW5jZSh2aWV3TW9kZWxJbnN0YW5jZS5ydW50aW1lSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVNYWNoaW5lO1xufSgpKTtcbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gYW5pbWF0b3Jcbi8qKlxuICogTWFuYWdlcyBhbmltYXRpb25cbiAqL1xudmFyIEFuaW1hdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgYW5pbWF0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gcnVudGltZSBSaXZlIHJ1bnRpbWU7IG5lZWRlZCB0byBpbnN0YW5jZSBhbmltYXRpb25zICYgc3RhdGUgbWFjaGluZXNcbiAgICAgKiBAcGFyYW0gYXJ0Ym9hcmQgdGhlIGFydGJvYXJkIHRoYXQgaG9sZHMgYWxsIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbnMgb3B0aW9uYWwgbGlzdCBvZiBhbmltYXRpb25zXG4gICAgICogQHBhcmFtIHN0YXRlTWFjaGluZXMgb3B0aW9uYWwgbGlzdCBvZiBzdGF0ZSBtYWNoaW5lc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFuaW1hdG9yKHJ1bnRpbWUsIGFydGJvYXJkLCBldmVudE1hbmFnZXIsIGFuaW1hdGlvbnMsIHN0YXRlTWFjaGluZXMpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbnMgPT09IHZvaWQgMCkgeyBhbmltYXRpb25zID0gW107IH1cbiAgICAgICAgaWYgKHN0YXRlTWFjaGluZXMgPT09IHZvaWQgMCkgeyBzdGF0ZU1hY2hpbmVzID0gW107IH1cbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgICAgICAgdGhpcy5hcnRib2FyZCA9IGFydGJvYXJkO1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzID0gc3RhdGVNYWNoaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbmltYXRpb25zIGFuZCBzdGF0ZSBtYWNoaW5lcyBieSB0aGVpciBuYW1lcy4gSWYgbmFtZXMgYXJlIHNoYXJlZFxuICAgICAqIGJldHdlZW4gYW5pbWF0aW9ucyAmIHN0YXRlIG1hY2hpbmVzLCB0aGVuIHRoZSBmaXJzdCBvbmUgZm91bmQgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQuIEJlc3Qgbm90IHRvIHVzZSB0aGUgc2FtZSBuYW1lcyBmb3IgdGhlc2UgaW4geW91ciBSaXZlIGZpbGUuXG4gICAgICogQHBhcmFtIGFuaW1hdGFibGUgdGhlIG5hbWUocykgb2YgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgdG8gYWRkXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIHRoZSBwbGF5aW5nIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhbmltYXRhYmxlcywgcGxheWluZywgZmlyZUV2ZW50KSB7XG4gICAgICAgIGlmIChmaXJlRXZlbnQgPT09IHZvaWQgMCkgeyBmaXJlRXZlbnQgPSB0cnVlOyB9XG4gICAgICAgIGFuaW1hdGFibGVzID0gbWFwVG9TdHJpbmdBcnJheShhbmltYXRhYmxlcyk7XG4gICAgICAgIC8vIElmIGFuaW1hdGFibGVzIGlzIGVtcHR5LCBwbGF5IG9yIHBhdXNlIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFuaW1hdGFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChhLnBsYXlpbmcgPSBwbGF5aW5nKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTWFjaGluZXMuZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXR1cm4gKG0ucGxheWluZyA9IHBsYXlpbmcpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBsYXkvcGF1c2UgYWxyZWFkeSBpbnN0YW5jZWQgaXRlbXMsIG9yIGNyZWF0ZSBuZXcgaW5zdGFuY2VzXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VkQW5pbWF0aW9uTmFtZXMgPSB0aGlzLmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlZE1hY2hpbmVOYW1lcyA9IHRoaXMuc3RhdGVNYWNoaW5lcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubmFtZTsgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFJbmRleCA9IGluc3RhbmNlZEFuaW1hdGlvbk5hbWVzLmluZGV4T2YoYW5pbWF0YWJsZXNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBtSW5kZXggPSBpbnN0YW5jZWRNYWNoaW5lTmFtZXMuaW5kZXhPZihhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFJbmRleCA+PSAwIHx8IG1JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW5pbWF0aW9uIGlzIGluc3RhbmNlZCwgcGxheS9wYXVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW2FJbmRleF0ucGxheWluZyA9IHBsYXlpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGF0ZSBtYWNoaW5lIGlzIGluc3RhbmNlZCwgcGxheS9wYXVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzW21JbmRleF0ucGxheWluZyA9IHBsYXlpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgYW5pbWF0aW9uIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltID0gdGhpcy5hcnRib2FyZC5hbmltYXRpb25CeU5hbWUoYW5pbWF0YWJsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FuaW1hdGlvbiA9IG5ldyBfYW5pbWF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uQW5pbWF0aW9uKGFuaW0sIHRoaXMuYXJ0Ym9hcmQsIHRoaXMucnVudGltZSwgcGxheWluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5pbWF0aW9uLmFkdmFuY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBbmltYXRpb24uYXBwbHkoMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKG5ld0FuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgbmV3IHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbSA9IHRoaXMuYXJ0Ym9hcmQuc3RhdGVNYWNoaW5lQnlOYW1lKGFuaW1hdGFibGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKHNtLCB0aGlzLnJ1bnRpbWUsIHBsYXlpbmcsIHRoaXMuYXJ0Ym9hcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lcy5wdXNoKG5ld1N0YXRlTWFjaGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyZSBwbGF5L3BhdXNlZCBldmVudHMgZm9yIGFuaW1hdGlvbnNcbiAgICAgICAgaWYgKGZpcmVFdmVudCkge1xuICAgICAgICAgICAgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlBsYXksXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMucGxheWluZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuUGF1c2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMucGF1c2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5aW5nID8gdGhpcy5wbGF5aW5nIDogdGhpcy5wYXVzZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGxpbmVhciBhbmltYXRpb25zIGJ5IHRoZWlyIG5hbWVzLlxuICAgICAqIEBwYXJhbSBhbmltYXRhYmxlcyB0aGUgbmFtZShzKSBvZiBhbmltYXRpb25zIHRvIGFkZFxuICAgICAqIEBwYXJhbSBwbGF5aW5nIHdoZXRoZXIgYW5pbWF0aW9ucyBzaG91bGQgcGxheSBvbiBpbnN0YW50aWF0aW9uXG4gICAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmluaXRMaW5lYXJBbmltYXRpb25zID0gZnVuY3Rpb24gKGFuaW1hdGFibGVzLCBwbGF5aW5nKSB7XG4gICAgICAgIC8vIFBsYXkvcGF1c2UgYWxyZWFkeSBpbnN0YW5jZWQgaXRlbXMsIG9yIGNyZWF0ZSBuZXcgaW5zdGFuY2VzXG4gICAgICAgIC8vIFRoaXMgdmFsaWRhdGlvbiBpcyBrZXB0IHRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBjdXJyZW50IGJlaGF2aW9yLlxuICAgICAgICAvLyBCdXQgZ2l2ZW4gdGhhdCBpdCB0aGlzIGlzIGNhbGxlZCBkdXJpbmcgYXJ0Ym9hcmQgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgLy8gaXQgc2hvdWxkIHByb2JhYmx5IGJlIHNhZmUgdG8gcmVtb3ZlLlxuICAgICAgICB2YXIgaW5zdGFuY2VkQW5pbWF0aW9uTmFtZXMgPSB0aGlzLmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYUluZGV4ID0gaW5zdGFuY2VkQW5pbWF0aW9uTmFtZXMuaW5kZXhPZihhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICBpZiAoYUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYUluZGV4XS5wbGF5aW5nID0gcGxheWluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgYW5pbWF0aW9uIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgdmFyIGFuaW0gPSB0aGlzLmFydGJvYXJkLmFuaW1hdGlvbkJ5TmFtZShhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0FuaW1hdGlvbiA9IG5ldyBfYW5pbWF0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uQW5pbWF0aW9uKGFuaW0sIHRoaXMuYXJ0Ym9hcmQsIHRoaXMucnVudGltZSwgcGxheWluZyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbi5hZHZhbmNlKDApO1xuICAgICAgICAgICAgICAgICAgICBuZXdBbmltYXRpb24uYXBwbHkoMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnB1c2gobmV3QW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgc3RhdGUgbWFjaGluZXMgYnkgdGhlaXIgbmFtZXMuXG4gICAgICogQHBhcmFtIGFuaW1hdGFibGVzIHRoZSBuYW1lKHMpIG9mIHN0YXRlIG1hY2hpbmVzIHRvIGFkZFxuICAgICAqIEBwYXJhbSBwbGF5aW5nIHdoZXRoZXIgc3RhdGUgbWFjaGluZXMgc2hvdWxkIHBsYXkgb24gaW5zdGFudGlhdGlvblxuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5pbml0U3RhdGVNYWNoaW5lcyA9IGZ1bmN0aW9uIChhbmltYXRhYmxlcywgcGxheWluZykge1xuICAgICAgICAvLyBQbGF5L3BhdXNlIGFscmVhZHkgaW5zdGFuY2VkIGl0ZW1zLCBvciBjcmVhdGUgbmV3IGluc3RhbmNlc1xuICAgICAgICAvLyBUaGlzIHZhbGlkYXRpb24gaXMga2VwdCB0byBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggY3VycmVudCBiZWhhdmlvci5cbiAgICAgICAgLy8gQnV0IGdpdmVuIHRoYXQgaXQgdGhpcyBpcyBjYWxsZWQgZHVyaW5nIGFydGJvYXJkIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vIGl0IHNob3VsZCBwcm9iYWJseSBiZSBzYWZlIHRvIHJlbW92ZS5cbiAgICAgICAgdmFyIGluc3RhbmNlZFN0YXRlTWFjaGluZU5hbWVzID0gdGhpcy5zdGF0ZU1hY2hpbmVzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5uYW1lOyB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFJbmRleCA9IGluc3RhbmNlZFN0YXRlTWFjaGluZU5hbWVzLmluZGV4T2YoYW5pbWF0YWJsZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGFJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZU1hY2hpbmVzW2FJbmRleF0ucGxheWluZyA9IHBsYXlpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgbmV3IHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICB2YXIgc20gPSB0aGlzLmFydGJvYXJkLnN0YXRlTWFjaGluZUJ5TmFtZShhbmltYXRhYmxlc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKHNtLCB0aGlzLnJ1bnRpbWUsIHBsYXlpbmcsIHRoaXMuYXJ0Ym9hcmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlTWFjaGluZXMucHVzaChuZXdTdGF0ZU1hY2hpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlTWFjaGluZS5hZHZhbmNlQW5kQXBwbHkoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBjdXJyZW50IGJlaGF2aW9yLCBpZiBhIHN0YXRlIG1hY2hpbmUgaXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGxvb2sgZm9yIGFuIGFuaW1hdGlvbiB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0TGluZWFyQW5pbWF0aW9ucyhbYW5pbWF0YWJsZXNbaV1dLCBwbGF5aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBsYXkgdGhlIG5hbWVkIGFuaW1hdGlvbnMvc3RhdGUgbWFjaGluZXNcbiAgICAgKiBAcGFyYW0gYW5pbWF0YWJsZXMgdGhlIG5hbWVzIG9mIHRoZSBhbmltYXRpb25zL21hY2hpbmVzIHRvIHBsYXk7IHBsYXlzIGFsbCBpZiBlbXB0eVxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiB0aGUgcGxheWluZyBpdGVtc1xuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKGFuaW1hdGFibGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhbmltYXRhYmxlcywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXVzZXMgbmFtZWQgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMsIG9yIGV2ZXJ5dGhpbmcgaWYgbm90aGluZyBpc1xuICAgICAqIHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSBhbmltYXRhYmxlcyBuYW1lcyBvZiB0aGUgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgdG8gcGF1c2VcbiAgICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgbmFtZXMgb2YgdGhlIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzIHBhdXNlZFxuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChhbmltYXRhYmxlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYW5pbWF0YWJsZXMsIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aW1lIG9mIG5hbWVkIGFuaW1hdGlvbnNcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9ucyBuYW1lcyBvZiB0aGUgYW5pbWF0aW9ucyB0byBzY3J1YlxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aW1lIHNjcnViIHZhbHVlLCBhIGZsb2F0aW5nIHBvaW50IG51bWJlciB0byB3aGljaCB0aGUgcGxheWhlYWQgaXMganVtcGVkXG4gICAgICogQHJldHVybnMgYSBsaXN0IG9mIG5hbWVzIG9mIHRoZSBhbmltYXRpb25zIHRoYXQgd2VyZSBzY3J1YmJlZFxuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uIChhbmltYXRhYmxlcywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZvclNjcnViYmluZyA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRhYmxlcy5pbmNsdWRlcyhhLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yU2NydWJiaW5nLmZvckVhY2goZnVuY3Rpb24gKGEpIHsgcmV0dXJuIChhLnNjcnViVG8gPSB2YWx1ZSk7IH0pO1xuICAgICAgICByZXR1cm4gZm9yU2NydWJiaW5nLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5uYW1lOyB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRvci5wcm90b3R5cGUsIFwicGxheWluZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBuYW1lcyBvZiBhbGwgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgY3VycmVudGx5XG4gICAgICAgICAqIHBsYXlpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLnN0YXRlTWFjaGluZXMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnBsYXlpbmc7IH0pLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0b3IucHJvdG90eXBlLCBcInBhdXNlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBuYW1lcyBvZiBhbGwgYW5pbWF0aW9ucyBhbmQgc3RhdGUgbWFjaGluZXMgY3VycmVudGx5XG4gICAgICAgICAqIHBhdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWEucGxheWluZzsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLnN0YXRlTWFjaGluZXMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiAhbS5wbGF5aW5nOyB9KS5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubmFtZTsgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU3RvcHMgYW5kIHJlbW92ZXMgYWxsIG5hbWVkIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICogQHBhcmFtIGFuaW1hdGFibGVzIGFuaW1hdGlvbnMgYW5kIHN0YXRlIG1hY2hpbmVzIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBuYW1lcyBvZiByZW1vdmVkIGl0ZW1zXG4gICAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoYW5pbWF0YWJsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYW5pbWF0YWJsZXMgPSBtYXBUb1N0cmluZ0FycmF5KGFuaW1hdGFibGVzKTtcbiAgICAgICAgLy8gSWYgbm90aGluZydzIHNwZWNpZmllZCwgd2lwZSB0aGVtIG91dCwgYWxsIG9mIHRoZW1cbiAgICAgICAgdmFyIHJlbW92ZWROYW1lcyA9IFtdO1xuICAgICAgICAvLyBTdG9wIGV2ZXJ5dGhpbmdcbiAgICAgICAgaWYgKGFuaW1hdGFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVtb3ZlZE5hbWVzID0gdGhpcy5hbmltYXRpb25zXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5uYW1lOyB9KVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5zdGF0ZU1hY2hpbmVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KSk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBiZWZvcmUgZW1wdHlpbmcgdGhlIGFycmF5c1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuY2xlYW51cCgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmNsZWFudXAoKTsgfSk7XG4gICAgICAgICAgICAvLyBFbXB0eSBvdXQgdGhlIGFycmF5c1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zLnNwbGljZSgwLCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lcy5zcGxpY2UoMCwgdGhpcy5zdGF0ZU1hY2hpbmVzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgb25seSB0aGUgbmFtZWQgYW5pbWF0aW9ucy9zdGF0ZSBtYWNoaW5lc1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnNUb1JlbW92ZSA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0YWJsZXMuaW5jbHVkZXMoYS5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9uc1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBhLmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpb25zLnNwbGljZShfdGhpcy5hbmltYXRpb25zLmluZGV4T2YoYSksIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWFjaGluZXNUb1JlbW92ZSA9IHRoaXMuc3RhdGVNYWNoaW5lcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0YWJsZXMuaW5jbHVkZXMobS5uYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFjaGluZXNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgbS5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVNYWNoaW5lcy5zcGxpY2UoX3RoaXMuc3RhdGVNYWNoaW5lcy5pbmRleE9mKG0pLCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVtb3ZlZE5hbWVzID0gYW5pbWF0aW9uc1RvUmVtb3ZlXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5uYW1lOyB9KVxuICAgICAgICAgICAgICAgIC5jb25jYXQobWFjaGluZXNUb1JlbW92ZS5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubmFtZTsgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLlN0b3AsXG4gICAgICAgICAgICBkYXRhOiByZW1vdmVkTmFtZXMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGxpc3Qgb2YgYW5pbWF0aW9ucyByZW1vdmVkXG4gICAgICAgIHJldHVybiByZW1vdmVkTmFtZXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0b3IucHJvdG90eXBlLCBcImlzUGxheWluZ1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgYXQgbGVhc3Qgb25lIGFuaW1hdGlvbiBpcyBhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFuaW1hdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnIpIHsgcmV0dXJuIGFjYyB8fCBjdXJyLnBsYXlpbmc7IH0sIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVNYWNoaW5lcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VycikgeyByZXR1cm4gYWNjIHx8IGN1cnIucGxheWluZzsgfSwgZmFsc2UpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRvci5wcm90b3R5cGUsIFwiaXNQYXVzZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBhbmltYXRpb25zIGFyZSBwYXVzZWQgYW5kIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCF0aGlzLmlzUGxheWluZyAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmFuaW1hdGlvbnMubGVuZ3RoID4gMCB8fCB0aGlzLnN0YXRlTWFjaGluZXMubGVuZ3RoID4gMCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdG9yLnByb3RvdHlwZSwgXCJpc1N0b3BwZWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyBwbGF5aW5nIG9yIHBhdXNlZCBhbmltYXRpb25zL3N0YXRlIG1hY2hpbmVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoID09PSAwICYmIHRoaXMuc3RhdGVNYWNoaW5lcy5sZW5ndGggPT09IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyBvciBzdGF0ZSBtYWNoaW5lcywgYWRkIHRoZSBmaXJzdCBvbmUgZm91bmRcbiAgICAgKiBAcmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIG9yIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VkXG4gICAgICovXG4gICAgQW5pbWF0b3IucHJvdG90eXBlLmF0TGVhc3RPbmUgPSBmdW5jdGlvbiAocGxheWluZywgZmlyZUV2ZW50KSB7XG4gICAgICAgIGlmIChmaXJlRXZlbnQgPT09IHZvaWQgMCkgeyBmaXJlRXZlbnQgPSB0cnVlOyB9XG4gICAgICAgIHZhciBpbnN0YW5jZWROYW1lO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnN0YXRlTWFjaGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcnRib2FyZC5hbmltYXRpb25Db3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZmlyc3QgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoWyhpbnN0YW5jZWROYW1lID0gdGhpcy5hcnRib2FyZC5hbmltYXRpb25CeUluZGV4KDApLm5hbWUpXSwgcGxheWluZywgZmlyZUV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXJ0Ym9hcmQuc3RhdGVNYWNoaW5lQ291bnQoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGZpcnN0IHN0YXRlIG1hY2hpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChbKGluc3RhbmNlZE5hbWUgPSB0aGlzLmFydGJvYXJkLnN0YXRlTWFjaGluZUJ5SW5kZXgoMCkubmFtZSldLCBwbGF5aW5nLCBmaXJlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZWROYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGFueSBhbmltYXRpb25zIGhhdmUgbG9vcGVkIGFuZCBpZiBzbywgZmlyZSB0aGUgYXBwcm9wcmlhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBBbmltYXRvci5wcm90b3R5cGUuaGFuZGxlTG9vcGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX2FbX2ldO1xuICAgICAgICAgICAgLy8gRW1pdCBpZiB0aGUgYW5pbWF0aW9uIGxvb3BlZFxuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5sb29wVmFsdWUgPT09IDAgJiYgYW5pbWF0aW9uLmxvb3BDb3VudCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5sb29wQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBvbmUtc2hvdDsgaWYgaXQgaGFzIGVuZGVkLCBkZWxldGUgdGhlIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKGFuaW1hdGlvbi5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFuaW1hdGlvbi5sb29wVmFsdWUgPT09IDEgJiYgYW5pbWF0aW9uLmxvb3BDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTG9vcCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBhbmltYXRpb246IGFuaW1hdGlvbi5uYW1lLCB0eXBlOiBMb29wVHlwZS5Mb29wIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmxvb3BDb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXYXNtIGluZGljYXRlcyBhIGxvb3AgYXQgZWFjaCB0aW1lIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIGNoYW5nZXMgZGlyZWN0aW9uLCBzbyBhIGZ1bGwgbG9vcC9sYXAgb2NjdXJzIGV2ZXJ5XG4gICAgICAgICAgICAvLyB0d28gbG9vcCBjb3VudHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGFuaW1hdGlvbi5sb29wVmFsdWUgPT09IDIgJiYgYW5pbWF0aW9uLmxvb3BDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvb3AsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgYW5pbWF0aW9uOiBhbmltYXRpb24ubmFtZSwgdHlwZTogTG9vcFR5cGUuUGluZ1BvbmcgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ubG9vcENvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHN0YXRlcyBoYXZlIGNoYW5nZWQgaW4gc3RhdGUgbWFjaGluZXMgYW5kIGZpcmVzIGEgc3RhdGVjaGFuZ2VcbiAgICAgKiBldmVudFxuICAgICAqL1xuICAgIEFuaW1hdG9yLnByb3RvdHlwZS5oYW5kbGVTdGF0ZUNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZXNDaGFuZ2VkID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLnN0YXRlTWFjaGluZXMuZmlsdGVyKGZ1bmN0aW9uIChzbSkgeyByZXR1cm4gc20ucGxheWluZzsgfSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVNYWNoaW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgc3RhdGVzQ2hhbmdlZC5wdXNoLmFwcGx5KHN0YXRlc0NoYW5nZWQsIHN0YXRlTWFjaGluZS5zdGF0ZXNDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGVzQ2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuU3RhdGVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgZGF0YTogc3RhdGVzQ2hhbmdlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbmltYXRvci5wcm90b3R5cGUuaGFuZGxlQWR2YW5jaW5nID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuQWR2YW5jZSxcbiAgICAgICAgICAgIGRhdGE6IHRpbWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFuaW1hdG9yO1xufSgpKTtcbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gZXZlbnRzXG4vKipcbiAqIFN1cHBvcnRlZCBldmVudCB0eXBlcyB0cmlnZ2VyZWQgaW4gUml2ZVxuICovXG52YXIgRXZlbnRUeXBlO1xuKGZ1bmN0aW9uIChFdmVudFR5cGUpIHtcbiAgICBFdmVudFR5cGVbXCJMb2FkXCJdID0gXCJsb2FkXCI7XG4gICAgRXZlbnRUeXBlW1wiTG9hZEVycm9yXCJdID0gXCJsb2FkZXJyb3JcIjtcbiAgICBFdmVudFR5cGVbXCJQbGF5XCJdID0gXCJwbGF5XCI7XG4gICAgRXZlbnRUeXBlW1wiUGF1c2VcIl0gPSBcInBhdXNlXCI7XG4gICAgRXZlbnRUeXBlW1wiU3RvcFwiXSA9IFwic3RvcFwiO1xuICAgIEV2ZW50VHlwZVtcIkxvb3BcIl0gPSBcImxvb3BcIjtcbiAgICBFdmVudFR5cGVbXCJEcmF3XCJdID0gXCJkcmF3XCI7XG4gICAgRXZlbnRUeXBlW1wiQWR2YW5jZVwiXSA9IFwiYWR2YW5jZVwiO1xuICAgIEV2ZW50VHlwZVtcIlN0YXRlQ2hhbmdlXCJdID0gXCJzdGF0ZWNoYW5nZVwiO1xuICAgIEV2ZW50VHlwZVtcIlJpdmVFdmVudFwiXSA9IFwicml2ZWV2ZW50XCI7XG4gICAgRXZlbnRUeXBlW1wiQXVkaW9TdGF0dXNDaGFuZ2VcIl0gPSBcImF1ZGlvc3RhdHVzY2hhbmdlXCI7XG59KShFdmVudFR5cGUgfHwgKEV2ZW50VHlwZSA9IHt9KSk7XG4vKipcbiAqIExvb3BpbmcgdHlwZXM6IG9uZS1zaG90LCBsb29wLCBhbmQgcGluZy1wb25nXG4gKi9cbnZhciBMb29wVHlwZTtcbihmdW5jdGlvbiAoTG9vcFR5cGUpIHtcbiAgICBMb29wVHlwZVtcIk9uZVNob3RcIl0gPSBcIm9uZXNob3RcIjtcbiAgICBMb29wVHlwZVtcIkxvb3BcIl0gPSBcImxvb3BcIjtcbiAgICBMb29wVHlwZVtcIlBpbmdQb25nXCJdID0gXCJwaW5ncG9uZ1wiO1xufSkoTG9vcFR5cGUgfHwgKExvb3BUeXBlID0ge30pKTtcbi8vIE1hbmFnZXMgUml2ZSBldmVudHMgYW5kIGxpc3RlbmVyc1xudmFyIEV2ZW50TWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXIobGlzdGVuZXJzKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHZvaWQgMCkgeyBsaXN0ZW5lcnMgPSBbXTsgfVxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB9XG4gICAgLy8gR2V0cyBsaXN0ZW5lcnMgb2Ygc3BlY2lmaWVkIHR5cGVcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldExpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudHlwZSA9PT0gdHlwZTsgfSk7XG4gICAgfTtcbiAgICAvLyBBZGRzIGEgbGlzdGVuZXJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMubGlzdGVuZXJzLmluY2x1ZGVzKGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgd2l0aCB0aGUgY2FsbGJhY2sgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHNpbXBseSBsb29rIGZvciB0aGUgbGlzdGVuZXIgYXMgaXQnbGwgYmUgYSBkaWZmZXJlbnQgaW5zdGFuY2UgdG9cbiAgICAgICAgLy8gb25lIG9yaWdpbmFsbHkgc3Vic2NyaWJlZC4gRmluZCBhbGwgdGhlIGxpc3RlbmVycyBvZiB0aGUgcmlnaHQgdHlwZSBhbmRcbiAgICAgICAgLy8gdGhlbiBjaGVjayB0aGVpciBjYWxsYmFja3Mgd2hpY2ggc2hvdWxkIG1hdGNoLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudExpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbaV07XG4gICAgICAgICAgICBpZiAoY3VycmVudExpc3RlbmVyLnR5cGUgPT09IGxpc3RlbmVyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpc3RlbmVyLmNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBsaXN0ZW5lcnMgb2Ygc3BlY2lmaWVkIHR5cGUsIG9yIGV2ZXJ5IGxpc3RlbmVyIGlmIG5vIHR5cGUgaXNcbiAgICAgKiBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiBsaXN0ZW5lcnMgdG8gY2xlYXIsIG9yIGFsbCBsaXN0ZW5lcnMgaWYgbm90XG4gICAgICogc3BlY2lmaWVkXG4gICAgICovXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZSgwLCB0aGlzLmxpc3RlbmVycy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnR5cGUgPT09IHR5cGU7IH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGwpIHsgcmV0dXJuIF90aGlzLnJlbW92ZShsKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEZpcmVzIGFuIGV2ZW50XG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudExpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzKGV2ZW50LnR5cGUpO1xuICAgICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuY2FsbGJhY2soZXZlbnQpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCkpO1xuLy8gTWFuYWdlcyBhIHF1ZXVlIG9mIHRhc2tzXG52YXIgVGFza1F1ZXVlTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYXNrUXVldWVNYW5hZ2VyKGV2ZW50TWFuYWdlcikge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICAvLyBBZGRzIGEgdGFzayB0b3AgdGhlIHF1ZXVlXG4gICAgVGFza1F1ZXVlTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xuICAgIH07XG4gICAgLy8gUHJvY2Vzc2VzIGFsbCB0YXNrcyBpbiB0aGUgcXVldWVcbiAgICBUYXNrUXVldWVNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0YXNrID09PSBudWxsIHx8IHRhc2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhc2suYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGFzay5hY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXNrID09PSBudWxsIHx8IHRhc2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhc2suZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHRhc2suZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFza1F1ZXVlTWFuYWdlcjtcbn0oKSk7XG4vLyAjZW5kcmVnaW9uXG4vLyAjcmVnaW9uIEF1ZGlvXG52YXIgU3lzdGVtQXVkaW9TdGF0dXM7XG4oZnVuY3Rpb24gKFN5c3RlbUF1ZGlvU3RhdHVzKSB7XG4gICAgU3lzdGVtQXVkaW9TdGF0dXNbU3lzdGVtQXVkaW9TdGF0dXNbXCJBVkFJTEFCTEVcIl0gPSAwXSA9IFwiQVZBSUxBQkxFXCI7XG4gICAgU3lzdGVtQXVkaW9TdGF0dXNbU3lzdGVtQXVkaW9TdGF0dXNbXCJVTkFWQUlMQUJMRVwiXSA9IDFdID0gXCJVTkFWQUlMQUJMRVwiO1xufSkoU3lzdGVtQXVkaW9TdGF0dXMgfHwgKFN5c3RlbUF1ZGlvU3RhdHVzID0ge30pKTtcbi8vIENsYXNzIHRvIGhhbmRsZSBhdWRpbyBjb250ZXh0IGF2YWlsYWJpbGl0eSBhbmQgc3RhdHVzIGNoYW5nZXNcbnZhciBBdWRpb01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF1ZGlvTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBdWRpb01hbmFnZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fc3RhdHVzID0gU3lzdGVtQXVkaW9TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXVkaW9NYW5hZ2VyLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZSk7IH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7IHJldHVybiBzZXRUaW1lb3V0KHJlamVjdCwgNTApOyB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBbGVydHMgYW5pbWF0aW9ucyBvbiBzdGF0dXMgY2hhbmdlcyBhbmQgcmVtb3ZlcyB0aGUgbGlzdGVuZXJzIHRvIGF2b2lkIGFsZXJ0aW5nIHR3aWNlLlxuICAgIEF1ZGlvTWFuYWdlci5wcm90b3R5cGUucmVwb3J0VG9MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZmlyZSh7IHR5cGU6IEV2ZW50VHlwZS5BdWRpb1N0YXR1c0NoYW5nZSB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhdWRpbyBjb250ZXh0IGhhcyBiZWVuIHJlc29sdmVkLlxuICAgICAqIEFsZXJ0IGFueSBsaXN0ZW5lcnMgdGhhdCB3ZSBjYW4gbm93IHBsYXkgYXVkaW8uXG4gICAgICogUml2ZSB3aWxsIG5vdyBwbGF5IGF1ZGlvIGF0IHRoZSBjb25maWd1cmVkIHZvbHVtZS5cbiAgICAgKi9cbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLmVuYWJsZUF1ZGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBTeXN0ZW1BdWRpb1N0YXR1cy5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0VG9MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgYXJlIGFibGUgdG8gcGxheSBhdWRpby5cbiAgICAgKlxuICAgICAqIFdlIGN1cnJlbnRseSBjaGVjayB0aGUgYXVkaW8gY29udGV4dCwgd2hlbiByZXN1bWUoKSByZXR1cm5zIGJlZm9yZSBhIHRpbWVvdXQgd2Uga25vdyB0aGF0IHRoZVxuICAgICAqIGF1ZGlvIGNvbnRleHQgaXMgcnVubmluZyBhbmQgd2UgY2FuIGVuYWJsZSBhdWRpby5cbiAgICAgKi9cbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLnRlc3RBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fc3RhdHVzID09PSBTeXN0ZW1BdWRpb1N0YXR1cy5VTkFWQUlMQUJMRSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCAhPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yYWNlKFt0aGlzLl9hdWRpb0NvbnRleHQucmVzdW1lKCksIHRoaXMudGltZW91dCgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoIGF1ZGlvIGZvciB1c2Ugd2l0aCByaXZlLlxuICAgICAqIFdlIGJvdGggdGVzdCBpZiB3ZSBjYW4gdXNlIGF1ZGlvIGludGVybWl0dGVudGx5IGFuZCBsaXN0ZW4gZm9yIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICogVGhlIGFpbSBpcyB0byBlbmFibGUgYXVkaW8gcGxheWJhY2sgYXMgc29vbiBhcyB0aGUgYnJvd3NlciBhbGxvd3MgdGhpcy5cbiAgICAgKi9cbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLl9lc3RhYmxpc2hBdWRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhdGhpcy5fc3RhcnRlZCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiB3aW5kb3cgPT0gXCJ1bmRlZmluZWRcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVBdWRpbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuRm9yVXNlckFjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9zdGF0dXMgPT09IFN5c3RlbUF1ZGlvU3RhdHVzLlVOQVZBSUxBQkxFKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRlc3RBdWRpbygpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWxheSgxMDAwKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLmxpc3RlbkZvclVzZXJBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5PVEU6IEF1ZGlvQ29udGV4dHMgYXJlIHJlYWR5IGltbWVkaWF0ZWx5IGlmIHJlcXVlc3RlZCBpbiBhIHVpIGNhbGxiYWNrXG4gICAgICAgIC8vIHdlICpjb3VsZCogcmUgcmVxdWVzdCBvbmUgaW4gdGhpcyBsaXN0ZW5lci5cbiAgICAgICAgdmFyIF9jbGlja0xpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhpcyBoYXMgXCJiZXR0ZXJcIiByZXN1bHRzIHRoYW4gY2FsbGluZyBgYXdhaXQgdGhpcy50ZXN0QXVkaW8oKWBcbiAgICAgICAgICAgICAgICAvLyBhcyB3ZSBmb3JjZSBhdWRpbyB0byBiZSBlbmFibGVkIGluIHRoZSBjdXJyZW50IHRocmVhZCwgcmF0aGVyIHRoYW4gY2hhbmNpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgdGhyZWFkIHRvIGJlIHBhc3NlZCBvdmVyIGZvciBzb21lIG90aGVyIGFzeW5jIGNvbnRleHRcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUF1ZGlvKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICAvLyBOT1RFOiB3ZSBzaG91bGQgdGVzdCB0aGlzIG9uIG1vYmlsZS9wYWRzXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBfY2xpY2tMaXN0ZW5lciwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2ggdGhlIGF1ZGlvIGNvbnRleHQgZm9yIHJpdmUsIHRoaXMgbGV0cyByaXZlIGtub3cgdGhhdCB3ZSBjYW4gcGxheSBhdWRpby5cbiAgICAgKi9cbiAgICBBdWRpb01hbmFnZXIucHJvdG90eXBlLmVzdGFibGlzaEF1ZGlvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXN0YWJsaXNoQXVkaW8oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXVkaW9NYW5hZ2VyLnByb3RvdHlwZSwgXCJzeXN0ZW1Wb2x1bWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IFN5c3RlbUF1ZGlvU3RhdHVzLlVOQVZBSUxBQkxFKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gYW4gaW1tZWRpYXRlIHRlc3QgdG8gYXZvaWQgZGVwZW5kaW5nIG9uIHRoZSBkZWxheSBvZiB0aGUgcnVubmluZyB0ZXN0XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0QXVkaW8oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1ZGlvTWFuYWdlci5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEF1ZGlvTWFuYWdlcjtcbn0oRXZlbnRNYW5hZ2VyKSk7XG52YXIgYXVkaW9NYW5hZ2VyID0gbmV3IEF1ZGlvTWFuYWdlcigpO1xudmFyIEZha2VSZXNpemVPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYWtlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgfVxuICAgIEZha2VSZXNpemVPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBGYWtlUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlLnVub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBGYWtlUmVzaXplT2JzZXJ2ZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIEZha2VSZXNpemVPYnNlcnZlcjtcbn0oKSk7XG52YXIgTXlSZXNpemVPYnNlcnZlciA9IGdsb2JhbFRoaXMuUmVzaXplT2JzZXJ2ZXIgfHwgRmFrZVJlc2l6ZU9ic2VydmVyO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHRha2VzIGNhcmUgb2YgYW55IG9ic2VydmVycyB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gYW4gYW5pbWF0aW9uLlxuICogSXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBzaW5nbGV0b24gYmVjYXVzZSBvYnNlcnZlcnMgYXJlIG11Y2ggbW9yZSBwZXJmb3JtYW50XG4gKiB3aGVuIHVzZWQgZm9yIG9ic2VydmluZyBtdWx0aXBsZSBlbGVtZW50cyBieSBhIHNpbmdsZSBpbnN0YW5jZS5cbiAqL1xudmFyIE9iamVjdE9ic2VydmVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPYmplY3RPYnNlcnZlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzaXplIG9ic2VydmVycyB0cmlnZ2VyIGJvdGggd2hlbiB0aGUgZWxlbWVudCBjaGFuZ2VzIGl0cyBzaXplIGFuZCBhbHNvIHdoZW4gdGhlXG4gICAgICAgICAqIGVsZW1lbnQgaXMgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uT2JzZXJ2ZWRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVkID0gX3RoaXMuX2VsZW1lbnRzTWFwLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZWQub25SZXNpemUoZW50cnkudGFyZ2V0LmNsaWVudFdpZHRoID09IDAgfHwgZW50cnkudGFyZ2V0LmNsaWVudEhlaWdodCA9PSAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNpemVPYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25PYnNlcnZlZCA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goX3RoaXMuX29uT2JzZXJ2ZWRFbnRyeSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IE15UmVzaXplT2JzZXJ2ZXIodGhpcy5fb25PYnNlcnZlZCk7XG4gICAgfVxuICAgIC8vIEFkZHMgYW4gb2JzZXJ2YWJsZSBlbGVtZW50XG4gICAgT2JqZWN0T2JzZXJ2ZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWxlbWVudCwgb25SZXNpemUpIHtcbiAgICAgICAgdmFyIG9ic2VydmVkID0ge1xuICAgICAgICAgICAgb25SZXNpemU6IG9uUmVzaXplLFxuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHNNYXAuc2V0KGVsZW1lbnQsIG9ic2VydmVkKTtcbiAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVkO1xuICAgIH07XG4gICAgLy8gUmVtb3ZlcyBhbiBvYnNlcnZhYmxlIGVsZW1lbnRcbiAgICBPYmplY3RPYnNlcnZlcnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYnNlcnZlZCkge1xuICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci51bm9ic2VydmUob2JzZXJ2ZWQuZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzTWFwLmRlbGV0ZShvYnNlcnZlZC5lbGVtZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3RPYnNlcnZlcnM7XG59KCkpO1xudmFyIG9ic2VydmVycyA9IG5ldyBPYmplY3RPYnNlcnZlcnMoKTtcbnZhciBSaXZlRmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSaXZlRmlsZShwYXJhbXMpIHtcbiAgICAgICAgLy8gQWxsb3cgdGhlIHJ1bnRpbWUgdG8gYXV0b21hdGljYWxseSBsb2FkIGFzc2V0cyBob3N0ZWQgaW4gUml2ZSdzIHJ1bnRpbWUuXG4gICAgICAgIHRoaXMuZW5hYmxlUml2ZUFzc2V0Q0ROID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3JjID0gcGFyYW1zLnNyYztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBwYXJhbXMuYnVmZmVyO1xuICAgICAgICBpZiAocGFyYW1zLmFzc2V0TG9hZGVyKVxuICAgICAgICAgICAgdGhpcy5hc3NldExvYWRlciA9IHBhcmFtcy5hc3NldExvYWRlcjtcbiAgICAgICAgdGhpcy5lbmFibGVSaXZlQXNzZXRDRE4gPVxuICAgICAgICAgICAgdHlwZW9mIHBhcmFtcy5lbmFibGVSaXZlQXNzZXRDRE4gPT0gXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgICA/IHBhcmFtcy5lbmFibGVSaXZlQXNzZXRDRE5cbiAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgIC8vIE5ldyBldmVudCBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoKTtcbiAgICAgICAgaWYgKHBhcmFtcy5vbkxvYWQpXG4gICAgICAgICAgICB0aGlzLm9uKEV2ZW50VHlwZS5Mb2FkLCBwYXJhbXMub25Mb2FkKTtcbiAgICAgICAgaWYgKHBhcmFtcy5vbkxvYWRFcnJvcilcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLkxvYWRFcnJvciwgcGFyYW1zLm9uTG9hZEVycm9yKTtcbiAgICB9XG4gICAgUml2ZUZpbGUucHJvdG90eXBlLmluaXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGxvYWRlciwgX2I7XG4gICAgICAgICAgICB2YXIgX2M7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3JjKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxvYWRSaXZlRmlsZSh0aGlzLnNyYyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5idWZmZXIgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzc2V0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVyID0gbmV3IHRoaXMucnVudGltZS5DdXN0b21GaWxlQXNzZXRMb2FkZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29udGVudHM6IHRoaXMuYXNzZXRMb2FkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBSaXZlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucnVudGltZS5sb2FkKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKSwgbG9hZGVyLCB0aGlzLmVuYWJsZVJpdmVBc3NldENETildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBSaXZlIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmZpbGUgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmZpbGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kZWxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkxvYWRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoUml2ZUZpbGUuZmlsZUxvYWRFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJpdmVGaWxlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBzb3VyY2UgZmlsZSB1cmwgc3BlY2lmaWVkLCBpdCdzIGEgYnVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNyYyAmJiAhdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoUml2ZUZpbGUubWlzc2luZ0Vycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBSdW50aW1lTG9hZGVyLmF3YWl0SW5zdGFuY2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnJ1bnRpbWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmluaXREYXRhKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIFJpdmUtZ2VuZXJhdGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayBjYWxsYmFjayB0byBmaXJlIHdoZW4gdGhlIGV2ZW50IG9jY3Vyc1xuICAgICAqL1xuICAgIFJpdmVGaWxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGQoe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIFJpdmUtZ2VuZXJhdGVkIGV2ZW50XG4gICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgZXZlbnQgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gdW5zdWJzY3JpYmVcbiAgICAgKi9cbiAgICBSaXZlRmlsZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZSh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJpdmVGaWxlLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlQ291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSaXZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuZmlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5maWxlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFsbCBSaXZlIGxpc3RlbmVycyBmcm9tIGFuIGV2ZW50IHR5cGUsIG9yIGV2ZXJ5dGhpbmcgaWYgbm8gdHlwZSBpc1xuICAgICAqIGdpdmVuXG4gICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgZXZlbnQgdG8gdW5zdWJzY3JpYmUgZnJvbSwgb3IgYWxsIHR5cGVzIGlmXG4gICAgICogdW5kZWZpbmVkXG4gICAgICovXG4gICAgUml2ZUZpbGUucHJvdG90eXBlLnJlbW92ZUFsbFJpdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZUFsbCh0eXBlKTtcbiAgICB9O1xuICAgIFJpdmVGaWxlLnByb3RvdHlwZS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VDb3VudCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgbWlzc2luZyBzb3VyY2Ugb3IgYnVmZmVyXG4gICAgUml2ZUZpbGUubWlzc2luZ0Vycm9yTWVzc2FnZSA9IFwiUml2ZSBzb3VyY2UgZmlsZSBvciBkYXRhIGJ1ZmZlciByZXF1aXJlZFwiO1xuICAgIC8vIEVycm9yIG1lc3NhZ2UgZm9yIGZpbGUgbG9hZCBlcnJvclxuICAgIFJpdmVGaWxlLmZpbGVMb2FkRXJyb3JNZXNzYWdlID0gXCJUaGUgZmlsZSBmYWlsZWQgdG8gbG9hZFwiO1xuICAgIHJldHVybiBSaXZlRmlsZTtcbn0oKSk7XG5cbnZhciBSaXZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJpdmUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVHJhY2tzIGlmIGEgUml2ZSBmaWxlIGlzIGxvYWRlZFxuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBUcmFja3MgaWYgYSBSaXZlIGZpbGUgaXMgZGVzdHJveWVkXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8vIFJlZmVyZW5jZSBvZiBhbiBvYmplY3QgdGhhdCBoYW5kbGVzIGFueSBvYnNlcnZlcnMgZm9yIHRoZSBhbmltYXRpb25cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIGlmIGEgUml2ZSBmaWxlIGlzIGxvYWRlZDsgd2UgbmVlZCB0aGlzIGluIGFkZGl0aW9uIHRvIGxvYWRlZCBhcyBzb21lXG4gICAgICAgICAqIGNvbW1hbmRzIChlLmcuIGNvbnRlbnRzKSBjYW4gYmUgY2FsbGVkIGFzIHNvb24gYXMgdGhlIGZpbGUgaXMgbG9hZGVkLlxuICAgICAgICAgKiBIb3dldmVyLCBwbGF5YmFjayBjb21tYW5kcyBuZWVkIHRvIGJlIHF1ZXVlZCBhbmQgcnVuIGluIG9yZGVyIG9uY2UgaW5pdGlhbFxuICAgICAgICAgKiBhbmltYXRpb25zIGFuZCBhdXRvcGxheSBoYXMgYmVlbiBzb3J0ZWQgb3V0LiBUaGlzIGFwcGxpZXMgdG8gcGxheSwgcGF1c2UsXG4gICAgICAgICAqIGFuZCBzdGFydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZHlGb3JQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFJ1bnRpbWUgYXJ0Ym9hcmRcbiAgICAgICAgdGhpcy5hcnRib2FyZCA9IG51bGw7XG4gICAgICAgIC8vIHBsYWNlIHRvIGNsZWFyIHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmV2ZW50Q2xlYW51cCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvdWxkRGlzYWJsZVJpdmVMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvbWF0aWNhbGx5SGFuZGxlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIC8vIEFsbG93IHRoZSBydW50aW1lIHRvIGF1dG9tYXRpY2FsbHkgbG9hZCBhc3NldHMgaG9zdGVkIGluIFJpdmUncyBydW50aW1lLlxuICAgICAgICB0aGlzLmVuYWJsZVJpdmVBc3NldENETiA9IHRydWU7XG4gICAgICAgIC8vIEtlZXAgYSBsb2NhbCB2YWx1ZSBvZiB0aGUgc2V0IHZvbHVtZSB0byB1cGRhdGUgaXQgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gMTtcbiAgICAgICAgLy8gS2VlcCBhIGxvY2FsIHZhbHVlIG9mIHRoZSBzZXQgd2lkdGggdG8gdXBkYXRlIGl0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgIHRoaXMuX2FydGJvYXJkV2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEtlZXAgYSBsb2NhbCB2YWx1ZSBvZiB0aGUgc2V0IGhlaWdodCB0byB1cGRhdGUgaXQgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgdGhpcy5fYXJ0Ym9hcmRIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEtlZXAgYSBsb2NhbCB2YWx1ZSBvZiB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIHVzZWQgaW4gcmVuZGVyaW5nIGFuZCBjYW52YXMvYXJ0Ym9hcmQgcmVzaXppbmdcbiAgICAgICAgdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb1VzZWQgPSAxO1xuICAgICAgICAvLyBXaGV0aGVyIHRoZSBjYW52YXMgZWxlbWVudCdzIHNpemUgaXMgMFxuICAgICAgICB0aGlzLl9oYXNaZXJvU2l6ZSA9IGZhbHNlO1xuICAgICAgICAvLyBBdWRpbyBldmVudCBsaXN0ZW5lclxuICAgICAgICB0aGlzLl9hdWRpb0V2ZW50TGlzdGVuZXIgPSBudWxsO1xuICAgICAgICAvLyBkcmF3IG1ldGhvZCBib3VuZCB0byB0aGUgY2xhc3NcbiAgICAgICAgdGhpcy5fYm91bmREcmF3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmlld01vZGVsSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9kYXRhRW51bXMgPSBudWxsO1xuICAgICAgICAvLyBEdXJhdGlvbnMgdG8gZ2VuZXJhdGUgYSBmcmFtZSBmb3IgdGhlIGxhc3Qgc2Vjb25kLiBVc2VkIGZvciBwZXJmb3JtYW5jZSBwcm9maWxpbmcuXG4gICAgICAgIHRoaXMuZHVyYXRpb25zID0gW107XG4gICAgICAgIHRoaXMuZnJhbWVUaW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmlzVG91Y2hTY3JvbGxFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DYW52YXNSZXNpemUgPSBmdW5jdGlvbiAoaGFzWmVyb1NpemUpIHtcbiAgICAgICAgICAgIHZhciB0b2dnbGVkRGlzcGxheSA9IF90aGlzLl9oYXNaZXJvU2l6ZSAhPT0gaGFzWmVyb1NpemU7XG4gICAgICAgICAgICBfdGhpcy5faGFzWmVyb1NpemUgPSBoYXNaZXJvU2l6ZTtcbiAgICAgICAgICAgIGlmICghaGFzWmVyb1NpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9nZ2xlZERpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzaXplRHJhd2luZ1N1cmZhY2VUb0NhbnZhcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfdGhpcy5fbGF5b3V0Lm1heFggfHwgIV90aGlzLl9sYXlvdXQubWF4WSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZVRvQ2FudmFzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIGJlIGRyYXcgdG8gdHJhY2sgd2hlbiBhIHNlY29uZCBvZiBhY3RpdmUgcmVuZGVyaW5nIHRpbWUgaGFzIHBhc3NlZC5cbiAgICAgICAgICogVXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclNlY29uZFRpbWVyID0gMDtcbiAgICAgICAgdGhpcy5fYm91bmREcmF3ID0gdGhpcy5kcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2FudmFzID0gcGFyYW1zLmNhbnZhcztcbiAgICAgICAgaWYgKHBhcmFtcy5jYW52YXMuY29uc3RydWN0b3IgPT09IEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlZCA9IG9ic2VydmVycy5hZGQodGhpcy5jYW52YXMsIHRoaXMub25DYW52YXNSZXNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3JjID0gcGFyYW1zLnNyYztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBwYXJhbXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJpdmVGaWxlID0gcGFyYW1zLnJpdmVGaWxlO1xuICAgICAgICB0aGlzLmxheW91dCA9IChfYSA9IHBhcmFtcy5sYXlvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5zaG91bGREaXNhYmxlUml2ZUxpc3RlbmVycyA9ICEhcGFyYW1zLnNob3VsZERpc2FibGVSaXZlTGlzdGVuZXJzO1xuICAgICAgICB0aGlzLmlzVG91Y2hTY3JvbGxFbmFibGVkID0gISFwYXJhbXMuaXNUb3VjaFNjcm9sbEVuYWJsZWQ7XG4gICAgICAgIHRoaXMuYXV0b21hdGljYWxseUhhbmRsZUV2ZW50cyA9ICEhcGFyYW1zLmF1dG9tYXRpY2FsbHlIYW5kbGVFdmVudHM7XG4gICAgICAgIHRoaXMuZW5hYmxlUml2ZUFzc2V0Q0ROID1cbiAgICAgICAgICAgIHBhcmFtcy5lbmFibGVSaXZlQXNzZXRDRE4gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogcGFyYW1zLmVuYWJsZVJpdmVBc3NldENETjtcbiAgICAgICAgLy8gTmV3IGV2ZW50IG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcigpO1xuICAgICAgICBpZiAocGFyYW1zLm9uTG9hZClcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLkxvYWQsIHBhcmFtcy5vbkxvYWQpO1xuICAgICAgICBpZiAocGFyYW1zLm9uTG9hZEVycm9yKVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuTG9hZEVycm9yLCBwYXJhbXMub25Mb2FkRXJyb3IpO1xuICAgICAgICBpZiAocGFyYW1zLm9uUGxheSlcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLlBsYXksIHBhcmFtcy5vblBsYXkpO1xuICAgICAgICBpZiAocGFyYW1zLm9uUGF1c2UpXG4gICAgICAgICAgICB0aGlzLm9uKEV2ZW50VHlwZS5QYXVzZSwgcGFyYW1zLm9uUGF1c2UpO1xuICAgICAgICBpZiAocGFyYW1zLm9uU3RvcClcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLlN0b3AsIHBhcmFtcy5vblN0b3ApO1xuICAgICAgICBpZiAocGFyYW1zLm9uTG9vcClcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLkxvb3AsIHBhcmFtcy5vbkxvb3ApO1xuICAgICAgICBpZiAocGFyYW1zLm9uU3RhdGVDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLm9uKEV2ZW50VHlwZS5TdGF0ZUNoYW5nZSwgcGFyYW1zLm9uU3RhdGVDaGFuZ2UpO1xuICAgICAgICBpZiAocGFyYW1zLm9uQWR2YW5jZSlcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLkFkdmFuY2UsIHBhcmFtcy5vbkFkdmFuY2UpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGNhbWVsQ2FzZSdkIHZlcnNpb25zIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocGFyYW1zLm9ubG9hZCAmJiAhcGFyYW1zLm9uTG9hZClcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLkxvYWQsIHBhcmFtcy5vbmxvYWQpO1xuICAgICAgICBpZiAocGFyYW1zLm9ubG9hZGVycm9yICYmICFwYXJhbXMub25Mb2FkRXJyb3IpXG4gICAgICAgICAgICB0aGlzLm9uKEV2ZW50VHlwZS5Mb2FkRXJyb3IsIHBhcmFtcy5vbmxvYWRlcnJvcik7XG4gICAgICAgIGlmIChwYXJhbXMub25wbGF5ICYmICFwYXJhbXMub25QbGF5KVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuUGxheSwgcGFyYW1zLm9ucGxheSk7XG4gICAgICAgIGlmIChwYXJhbXMub25wYXVzZSAmJiAhcGFyYW1zLm9uUGF1c2UpXG4gICAgICAgICAgICB0aGlzLm9uKEV2ZW50VHlwZS5QYXVzZSwgcGFyYW1zLm9ucGF1c2UpO1xuICAgICAgICBpZiAocGFyYW1zLm9uc3RvcCAmJiAhcGFyYW1zLm9uU3RvcClcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLlN0b3AsIHBhcmFtcy5vbnN0b3ApO1xuICAgICAgICBpZiAocGFyYW1zLm9ubG9vcCAmJiAhcGFyYW1zLm9uTG9vcClcbiAgICAgICAgICAgIHRoaXMub24oRXZlbnRUeXBlLkxvb3AsIHBhcmFtcy5vbmxvb3ApO1xuICAgICAgICBpZiAocGFyYW1zLm9uc3RhdGVjaGFuZ2UgJiYgIXBhcmFtcy5vblN0YXRlQ2hhbmdlKVxuICAgICAgICAgICAgdGhpcy5vbihFdmVudFR5cGUuU3RhdGVDaGFuZ2UsIHBhcmFtcy5vbnN0YXRlY2hhbmdlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFzc2V0IGxvYWRpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmIChwYXJhbXMuYXNzZXRMb2FkZXIpXG4gICAgICAgICAgICB0aGlzLmFzc2V0TG9hZGVyID0gcGFyYW1zLmFzc2V0TG9hZGVyO1xuICAgICAgICAvLyBIb29rIHVwIHRoZSB0YXNrIHF1ZXVlXG4gICAgICAgIHRoaXMudGFza1F1ZXVlID0gbmV3IFRhc2tRdWV1ZU1hbmFnZXIodGhpcy5ldmVudE1hbmFnZXIpO1xuICAgICAgICB0aGlzLmluaXQoe1xuICAgICAgICAgICAgc3JjOiB0aGlzLnNyYyxcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5idWZmZXIsXG4gICAgICAgICAgICByaXZlRmlsZTogdGhpcy5yaXZlRmlsZSxcbiAgICAgICAgICAgIGF1dG9wbGF5OiBwYXJhbXMuYXV0b3BsYXksXG4gICAgICAgICAgICBhdXRvQmluZDogcGFyYW1zLmF1dG9CaW5kLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogcGFyYW1zLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICBzdGF0ZU1hY2hpbmVzOiBwYXJhbXMuc3RhdGVNYWNoaW5lcyxcbiAgICAgICAgICAgIGFydGJvYXJkOiBwYXJhbXMuYXJ0Ym9hcmQsXG4gICAgICAgICAgICB1c2VPZmZzY3JlZW5SZW5kZXJlcjogcGFyYW1zLnVzZU9mZnNjcmVlblJlbmRlcmVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgdG8gYnVpbGQgYSBSaXZlIGluc3RhbmNlIGZyb20gYW4gaW50ZXJmYWNlL29iamVjdFxuICAgIFJpdmUubmV3ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaGlzIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQ6IHBsZWFzZSB1c2UgYG5ldyBSaXZlKHt9KWAgaW5zdGVhZFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXZlKHBhcmFtcyk7XG4gICAgfTtcbiAgICAvLyBFdmVudCBoYW5kbGVyIGZvciB3aGVuIGF1ZGlvIGNvbnRleHQgYmVjb21lcyBhdmFpbGFibGVcbiAgICBSaXZlLnByb3RvdHlwZS5vblN5c3RlbUF1ZGlvQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl92b2x1bWU7XG4gICAgfTtcbiAgICAvLyBJbml0aWFsaXplcyB0aGUgUml2ZSBvYmplY3QgZWl0aGVyIGZyb20gY29uc3RydWN0b3Igb3IgbG9hZCgpXG4gICAgUml2ZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3JjID0gX2Euc3JjLCBidWZmZXIgPSBfYS5idWZmZXIsIHJpdmVGaWxlID0gX2Eucml2ZUZpbGUsIGFuaW1hdGlvbnMgPSBfYS5hbmltYXRpb25zLCBzdGF0ZU1hY2hpbmVzID0gX2Euc3RhdGVNYWNoaW5lcywgYXJ0Ym9hcmQgPSBfYS5hcnRib2FyZCwgX2IgPSBfYS5hdXRvcGxheSwgYXV0b3BsYXkgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBfYS51c2VPZmZzY3JlZW5SZW5kZXJlciwgdXNlT2Zmc2NyZWVuUmVuZGVyZXIgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBfYS5hdXRvQmluZCwgYXV0b0JpbmQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLnJpdmVGaWxlID0gcml2ZUZpbGU7XG4gICAgICAgIC8vIElmIG5vIHNvdXJjZSBmaWxlIHVybCBzcGVjaWZpZWQsIGl0J3MgYSBidXN0XG4gICAgICAgIGlmICghdGhpcy5zcmMgJiYgIXRoaXMuYnVmZmVyICYmICF0aGlzLnJpdmVGaWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUml2ZUVycm9yKFJpdmUubWlzc2luZ0Vycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGlzdCBvZiBhbmltYXRpb25zIHRoYXQgc2hvdWxkIGJlIGluaXRpYWxpemVkLlxuICAgICAgICB2YXIgc3RhcnRpbmdBbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0aW9ucyk7XG4gICAgICAgIC8vIExpc3Qgb2Ygc3RhdGUgbWFjaGluZXMgdGhhdCBzaG91bGQgYmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgdmFyIHN0YXJ0aW5nU3RhdGVNYWNoaW5lTmFtZXMgPSBtYXBUb1N0cmluZ0FycmF5KHN0YXRlTWFjaGluZXMpO1xuICAgICAgICAvLyBFbnN1cmUgbG9hZGVkIGlzIG1hcmtlZCBhcyBmYWxzZSBpZiBsb2FkaW5nIG5ldyBmaWxlXG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVhZHlGb3JQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcnVudGltZSBpcyBsb2FkZWRcbiAgICAgICAgUnVudGltZUxvYWRlci5hd2FpdEluc3RhbmNlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChydW50aW1lKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVSaXZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBfdGhpcy5kZWxldGVSaXZlUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY2FudmFzIHdoZXJlIHlvdSB3YW50IHRvIHJlbmRlciB0aGUgYW5pbWF0aW9uIGFuZCBjcmVhdGUgYSByZW5kZXJlclxuICAgICAgICAgICAgX3RoaXMucmVuZGVyZXIgPSBfdGhpcy5ydW50aW1lLm1ha2VSZW5kZXJlcihfdGhpcy5jYW52YXMsIHVzZU9mZnNjcmVlblJlbmRlcmVyKTtcbiAgICAgICAgICAgIC8vIEluaXRpYWwgc2l6ZSBhZGp1c3RtZW50IGJhc2VkIG9uIGRldmljZVBpeGVsUmF0aW8gaWYgbm8gd2lkdGgvaGVpZ2h0IGFyZVxuICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGlmICghKF90aGlzLmNhbnZhcy53aWR0aCB8fCBfdGhpcy5jYW52YXMuaGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZURyYXdpbmdTdXJmYWNlVG9DYW52YXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvYWQgUml2ZSBkYXRhIGZyb20gYSBzb3VyY2UgdXJpIG9yIGEgZGF0YSBidWZmZXJcbiAgICAgICAgICAgIF90aGlzLmluaXREYXRhKGFydGJvYXJkLCBzdGFydGluZ0FuaW1hdGlvbk5hbWVzLCBzdGFydGluZ1N0YXRlTWFjaGluZU5hbWVzLCBhdXRvcGxheSwgYXV0b0JpbmQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc2V0dXBSaXZlTGlzdGVuZXJzKCk7IH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHVwIFJpdmUgTGlzdGVuZXJzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gcml2ZUxpc3RlbmVyT3B0aW9ucyAtIEVuYWJsZXMgVG91Y2hFdmVudCBldmVudHMgb24gdGhlIGNhbnZhcy4gU2V0IHRvIHRydWUgdG8gYWxsb3dcbiAgICAgKiB0b3VjaCBzY3JvbGxpbmcgb24gdGhlIGNhbnZhcyBlbGVtZW50IG9uIHRvdWNoLWVuYWJsZWQgZGV2aWNlc1xuICAgICAqIGkuZS4geyBpc1RvdWNoU2Nyb2xsRW5hYmxlZDogdHJ1ZSB9XG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuc2V0dXBSaXZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKHJpdmVMaXN0ZW5lck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDbGVhbnVwKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zaG91bGREaXNhYmxlUml2ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVN0YXRlTWFjaGluZXMgPSAodGhpcy5hbmltYXRvci5zdGF0ZU1hY2hpbmVzIHx8IFtdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHNtKSB7IHJldHVybiBzbS5wbGF5aW5nICYmIF90aGlzLnJ1bnRpbWUuaGFzTGlzdGVuZXJzKHNtLmluc3RhbmNlKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzbSkgeyByZXR1cm4gc20uaW5zdGFuY2U7IH0pO1xuICAgICAgICAgICAgdmFyIHRvdWNoU2Nyb2xsRW5hYmxlZE9wdGlvbiA9IHRoaXMuaXNUb3VjaFNjcm9sbEVuYWJsZWQ7XG4gICAgICAgICAgICBpZiAocml2ZUxpc3RlbmVyT3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgIFwiaXNUb3VjaFNjcm9sbEVuYWJsZWRcIiBpbiByaXZlTGlzdGVuZXJPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdG91Y2hTY3JvbGxFbmFibGVkT3B0aW9uID0gcml2ZUxpc3RlbmVyT3B0aW9ucy5pc1RvdWNoU2Nyb2xsRW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXZlbnRDbGVhbnVwID0gKDAsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18ucmVnaXN0ZXJUb3VjaEludGVyYWN0aW9ucykoe1xuICAgICAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXG4gICAgICAgICAgICAgICAgYXJ0Ym9hcmQ6IHRoaXMuYXJ0Ym9hcmQsXG4gICAgICAgICAgICAgICAgc3RhdGVNYWNoaW5lczogYWN0aXZlU3RhdGVNYWNoaW5lcyxcbiAgICAgICAgICAgICAgICByZW5kZXJlcjogdGhpcy5yZW5kZXJlcixcbiAgICAgICAgICAgICAgICByaXZlOiB0aGlzLnJ1bnRpbWUsXG4gICAgICAgICAgICAgICAgZml0OiB0aGlzLl9sYXlvdXQucnVudGltZUZpdCh0aGlzLnJ1bnRpbWUpLFxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogdGhpcy5fbGF5b3V0LnJ1bnRpbWVBbGlnbm1lbnQodGhpcy5ydW50aW1lKSxcbiAgICAgICAgICAgICAgICBpc1RvdWNoU2Nyb2xsRW5hYmxlZDogdG91Y2hTY3JvbGxFbmFibGVkT3B0aW9uLFxuICAgICAgICAgICAgICAgIGxheW91dFNjYWxlRmFjdG9yOiB0aGlzLl9sYXlvdXQubGF5b3V0U2NhbGVGYWN0b3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIFJpdmUgTGlzdGVuZXJzIHNldHVwIG9uIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5yZW1vdmVSaXZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudENsZWFudXApIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRDbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2xlYW51cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBpbnN0YW5jZSBoYXMgYXVkaW8gYW5kIHRoZSBzeXN0ZW0gYXVkaW8gaXMgbm90IHJlYWR5XG4gICAgICogd2UgaG9vayB0aGUgaW5zdGFuY2UgdG8gdGhlIGF1ZGlvIG1hbmFnZXJcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5pbml0aWFsaXplQXVkaW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdWRpbyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKGF1ZGlvTWFuYWdlci5zdGF0dXMgPT0gU3lzdGVtQXVkaW9TdGF0dXMuVU5BVkFJTEFCTEUpIHtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5hcnRib2FyZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhc0F1ZGlvKSAmJiB0aGlzLl9hdWRpb0V2ZW50TGlzdGVuZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb0V2ZW50TGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5BdWRpb1N0YXR1c0NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uU3lzdGVtQXVkaW9DaGFuZ2VkKCk7IH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhdWRpb01hbmFnZXIuYWRkKHRoaXMuX2F1ZGlvRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgYXVkaW9NYW5hZ2VyLmVzdGFibGlzaEF1ZGlvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJpdmUucHJvdG90eXBlLmluaXRBcnRib2FyZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5hcnRib2FyZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gVXNlIHByZXNldCB2YWx1ZXMgaWYgdGhleSBhcmUgbm90IHVuZGVmaW5lZFxuICAgICAgICB0aGlzLl9hcnRib2FyZFdpZHRoID0gdGhpcy5hcnRib2FyZC53aWR0aCA9XG4gICAgICAgICAgICB0aGlzLl9hcnRib2FyZFdpZHRoIHx8IHRoaXMuYXJ0Ym9hcmQud2lkdGg7XG4gICAgICAgIHRoaXMuX2FydGJvYXJkSGVpZ2h0ID0gdGhpcy5hcnRib2FyZC5oZWlnaHQgPVxuICAgICAgICAgICAgdGhpcy5fYXJ0Ym9hcmRIZWlnaHQgfHwgdGhpcy5hcnRib2FyZC5oZWlnaHQ7XG4gICAgfTtcbiAgICAvLyBJbml0aWFsaXplcyBydW50aW1lIHdpdGggUml2ZSBkYXRhIGFuZCBwcmVwcyBmb3IgcGxheWluZ1xuICAgIFJpdmUucHJvdG90eXBlLmluaXREYXRhID0gZnVuY3Rpb24gKGFydGJvYXJkTmFtZSwgYW5pbWF0aW9uTmFtZXMsIHN0YXRlTWFjaGluZU5hbWVzLCBhdXRvcGxheSwgYXV0b0JpbmQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVycm9yXzEsIG1zZztcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMCwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnJpdmVGaWxlID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucml2ZUZpbGUgPSBuZXcgUml2ZUZpbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogdGhpcy5zcmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVSaXZlQXNzZXRDRE46IHRoaXMuZW5hYmxlUml2ZUFzc2V0Q0ROLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0TG9hZGVyOiB0aGlzLmFzc2V0TG9hZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJpdmVGaWxlLmluaXQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHJpdmVGaWxlIGluIGNhc2UgaXQgaGFzIGJlZW4gY2xlYW5lZCB1cCB3aGlsZSBpbml0aWFsaXppbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucml2ZUZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUml2ZUVycm9yKFJpdmUuY2xlYW51cEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSB0aGlzLnJpdmVGaWxlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBkcmF3IGZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRBcnRib2FyZChhcnRib2FyZE5hbWUsIGFuaW1hdGlvbk5hbWVzLCBzdGF0ZU1hY2hpbmVOYW1lcywgYXV0b3BsYXksIGF1dG9CaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGFydGJvYXJkIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEFydGJvYXJkU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGF1ZGlvXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBdWRpbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlcnl0aGluZydzIHNldCB1cCwgZW1pdCBhIGxvYWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5Mb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYSA9IHRoaXMuc3JjKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcImJ1ZmZlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIHJlYWR5IGZvciBwbGF5YmFjayBjb21tYW5kcyBhbmQgY2xlYXIgdGhlIHRhc2sgcXVldWU7IHRoaXMgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGltcG9ydGFudCBvciBpdCBtYXkgaW5maW5pdGVseSByZWN1cnNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5Rm9yUGxheWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhc2tRdWV1ZS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFByb21pc2UucmVzb2x2ZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZyA9IHJlc29sdmVFcnJvck1lc3NhZ2UoZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmZpcmUoeyB0eXBlOiBFdmVudFR5cGUuTG9hZEVycm9yLCBkYXRhOiBtc2cgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZWplY3QobXNnKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEluaXRpYWxpemUgZm9yIHBsYXliYWNrXG4gICAgUml2ZS5wcm90b3R5cGUuaW5pdEFydGJvYXJkID0gZnVuY3Rpb24gKGFydGJvYXJkTmFtZSwgYW5pbWF0aW9uTmFtZXMsIHN0YXRlTWFjaGluZU5hbWVzLCBhdXRvcGxheSwgYXV0b0JpbmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGZXRjaCB0aGUgYXJ0Ym9hcmRcbiAgICAgICAgdmFyIHJvb3RBcnRib2FyZCA9IGFydGJvYXJkTmFtZVxuICAgICAgICAgICAgPyB0aGlzLmZpbGUuYXJ0Ym9hcmRCeU5hbWUoYXJ0Ym9hcmROYW1lKVxuICAgICAgICAgICAgOiB0aGlzLmZpbGUuZGVmYXVsdEFydGJvYXJkKCk7XG4gICAgICAgIC8vIENoZWNrIHdlIGhhdmUgYSB3b3JraW5nIGFydGJvYXJkXG4gICAgICAgIGlmICghcm9vdEFydGJvYXJkKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJJbnZhbGlkIGFydGJvYXJkIG5hbWUgb3Igbm8gZGVmYXVsdCBhcnRib2FyZFwiO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHsgdHlwZTogRXZlbnRUeXBlLkxvYWRFcnJvciwgZGF0YTogbXNnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXJ0Ym9hcmQgPSByb290QXJ0Ym9hcmQ7XG4gICAgICAgIHJvb3RBcnRib2FyZC52b2x1bWUgPSB0aGlzLl92b2x1bWUgKiBhdWRpb01hbmFnZXIuc3lzdGVtVm9sdW1lO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBhcnRib2FyZCBoYXMgYXQgbGVhc3QgMSBhbmltYXRpb25cbiAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQuYW5pbWF0aW9uQ291bnQoKSA8IDEpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBcIkFydGJvYXJkIGhhcyBubyBhbmltYXRpb25zXCI7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5maXJlKHsgdHlwZTogRXZlbnRUeXBlLkxvYWRFcnJvciwgZGF0YTogbXNnIH0pO1xuICAgICAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGFuaW1hdG9yXG4gICAgICAgIHRoaXMuYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGhpcy5ydW50aW1lLCB0aGlzLmFydGJvYXJkLCB0aGlzLmV2ZW50TWFuYWdlcik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGFuaW1hdGlvbnM7IGFzIGxvYWRlZCBoYXNuJ3QgaGFwcGVuZWQgeWV0LCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHN1cHByZXNzIGZpcmluZyB0aGUgcGxheS9wYXVzZSBldmVudHMgdW50aWwgdGhlIGxvYWQgZXZlbnQgaGFzIGZpcmVkLiBUb1xuICAgICAgICAvLyBkbyB0aGlzIHdlIHRlbGwgdGhlIGFuaW1hdG9yIHRvIHN1cHByZXNzIGZpcmluZyBldmVudHMsIGFuZCBhZGQgZXZlbnRcbiAgICAgICAgLy8gZmlyaW5nIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgICB2YXIgaW5zdGFuY2VOYW1lcztcbiAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWVzLmxlbmd0aCA+IDAgfHwgc3RhdGVNYWNoaW5lTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5zdGFuY2VOYW1lcyA9IGFuaW1hdGlvbk5hbWVzLmNvbmNhdChzdGF0ZU1hY2hpbmVOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdG9yLmluaXRMaW5lYXJBbmltYXRpb25zKGFuaW1hdGlvbk5hbWVzLCBhdXRvcGxheSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdG9yLmluaXRTdGF0ZU1hY2hpbmVzKHN0YXRlTWFjaGluZU5hbWVzLCBhdXRvcGxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZU5hbWVzID0gW3RoaXMuYW5pbWF0b3IuYXRMZWFzdE9uZShhdXRvcGxheSwgZmFsc2UpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBRdWV1ZSB1cCBmaXJpbmcgdGhlIHBsYXliYWNrIGV2ZW50c1xuICAgICAgICB0aGlzLnRhc2tRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBhdXRvcGxheSA/IEV2ZW50VHlwZS5QbGF5IDogRXZlbnRUeXBlLlBhdXNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGluc3RhbmNlTmFtZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGF1dG9CaW5kKSB7XG4gICAgICAgICAgICB2YXIgdmlld01vZGVsID0gdGhpcy5maWxlLmRlZmF1bHRBcnRib2FyZFZpZXdNb2RlbChyb290QXJ0Ym9hcmQpO1xuICAgICAgICAgICAgaWYgKHZpZXdNb2RlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBydW50aW1lSW5zdGFuY2UgPSB2aWV3TW9kZWwuZGVmYXVsdEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnRpbWVJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld01vZGVsSW5zdGFuY2UgPSBuZXcgVmlld01vZGVsSW5zdGFuY2UocnVudGltZUluc3RhbmNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kVmlld01vZGVsSW5zdGFuY2Uodmlld01vZGVsSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRHJhd3MgdGhlIGN1cnJlbnQgYXJ0Ym9hcmQgZnJhbWVcbiAgICBSaXZlLnByb3RvdHlwZS5kcmF3RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSBkb2N1bWVudCA9PT0gbnVsbCB8fCBkb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jdW1lbnQudGltZWxpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50VGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkICYmIHRoaXMuYXJ0Ym9hcmQgJiYgIXRoaXMuZnJhbWVSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZERyYXcoZG9jdW1lbnQudGltZWxpbmUuY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucnVudGltZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlc29sdmVBbmltYXRpb25GcmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydFJlbmRlcmluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEcmF3IHJlbmRlcmluZyBsb29wOyByZW5kZXJzIGFuaW1hdGlvbiBmcmFtZXMgYXQgdGhlIGNvcnJlY3QgdGltZSBpbnRlcnZhbC5cbiAgICAgKiBAcGFyYW0gdGltZSB0aGUgdGltZSBhdCB3aGljaCB0byByZW5kZXIgYSBmcmFtZVxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAodGltZSwgb25TZWNvbmQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBDbGVhciB0aGUgZnJhbWVSZXF1ZXN0SWQsIGFzIHdlJ3JlIG5vdyByZW5kZXJpbmcgYSBmcmVzaCBmcmFtZVxuICAgICAgICB0aGlzLmZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAvLyBPbiB0aGUgZmlyc3QgcGFzcywgbWFrZSBzdXJlIGxhc3RUaW1lIGhhcyBhIHZhbGlkIHZhbHVlXG4gICAgICAgIGlmICghdGhpcy5sYXN0UmVuZGVyVGltZSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBvblNlY29uZCBjYWxsYmFja1xuICAgICAgICB0aGlzLnJlbmRlclNlY29uZFRpbWVyICs9IHRpbWUgLSB0aGlzLmxhc3RSZW5kZXJUaW1lO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJTZWNvbmRUaW1lciA+IDUwMDApIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2Vjb25kVGltZXIgPSAwO1xuICAgICAgICAgICAgb25TZWNvbmQgPT09IG51bGwgfHwgb25TZWNvbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU2Vjb25kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiBmcmFtZXMgaW4gc2Vjb25kc1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSAodGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWUpIC8gMTAwMDtcbiAgICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIC0gQWR2YW5jZSBub24tcGF1c2VkIGFuaW1hdGlvbnMgYnkgdGhlIGVsYXBzZWQgbnVtYmVyIG9mIHNlY29uZHNcbiAgICAgICAgLy8gLSBBZHZhbmNlIGFueSBhbmltYXRpb25zIHRoYXQgcmVxdWlyZSBzY3J1YmJpbmdcbiAgICAgICAgLy8gLSBBZHZhbmNlIHRvIHRoZSBmaXJzdCBmcmFtZSBldmVuIHdoZW4gYXV0b3BsYXkgaXMgZmFsc2VcbiAgICAgICAgdmFyIGFjdGl2ZUFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdG9yLmFuaW1hdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZyB8fCBhLm5lZWRzU2NydWI7IH0pXG4gICAgICAgICAgICAvLyBUaGUgc2NydWJiZWQgYW5pbWF0aW9ucyBtdXN0IGJlIGFwcGxpZWQgZmlyc3QgdG8gcHJldmVudCB3ZWlyZCBhcnRpZmFjdHNcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwbGF5aW5nIGFuaW1hdGlvbnMgY29uZmxpY3Qgd2l0aCB0aGUgc2NydWJiZWQgYW5pbWF0aW5nIGF0dHJpYnVhdGVzLlxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGZpcnN0KSB7IHJldHVybiAoZmlyc3QubmVlZHNTY3J1YiA/IC0xIDogMSk7IH0pO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGFjdGl2ZUFuaW1hdGlvbnNfMSA9IGFjdGl2ZUFuaW1hdGlvbnM7IF9pIDwgYWN0aXZlQW5pbWF0aW9uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFjdGl2ZUFuaW1hdGlvbnNfMVtfaV07XG4gICAgICAgICAgICBhbmltYXRpb24uYWR2YW5jZShlbGFwc2VkVGltZSk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uLmluc3RhbmNlLmRpZExvb3ApIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ubG9vcENvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRpb24uYXBwbHkoMS4wKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtIEFkdmFuY2Ugbm9uLXBhdXNlZCBzdGF0ZSBtYWNoaW5lcyBieSB0aGUgZWxhcHNlZCBudW1iZXIgb2Ygc2Vjb25kc1xuICAgICAgICAvLyAtIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGZyYW1lIGV2ZW4gd2hlbiBhdXRvcGxheSBpcyBmYWxzZVxuICAgICAgICB2YXIgYWN0aXZlU3RhdGVNYWNoaW5lcyA9IHRoaXMuYW5pbWF0b3Iuc3RhdGVNYWNoaW5lcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSk7XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgYWN0aXZlU3RhdGVNYWNoaW5lc18xID0gYWN0aXZlU3RhdGVNYWNoaW5lczsgX2IgPCBhY3RpdmVTdGF0ZU1hY2hpbmVzXzEubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVNYWNoaW5lID0gYWN0aXZlU3RhdGVNYWNoaW5lc18xW19iXTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBldmVudHMgYmVmb3JlIHRoZSBjdXJyZW50IGZyYW1lJ3Mgc3RhdGUgbWFjaGluZSBhZHZhbmNlXG4gICAgICAgICAgICB2YXIgbnVtRXZlbnRzUmVwb3J0ZWQgPSBzdGF0ZU1hY2hpbmUucmVwb3J0ZWRFdmVudENvdW50KCk7XG4gICAgICAgICAgICBpZiAobnVtRXZlbnRzUmVwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUV2ZW50c1JlcG9ydGVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50XzEgPSBzdGF0ZU1hY2hpbmUucmVwb3J0ZWRFdmVudEF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50XzEudHlwZSA9PT0gUml2ZUV2ZW50VHlwZS5PcGVuVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5SaXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGV2ZW50XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSBldmVudCBzaWRlIGVmZmVjdCBpZiBleHBsaWNpdGx5IGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvbWF0aWNhbGx5SGFuZGxlRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdBbmNob3JUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gZXZlbnRfMSwgdXJsID0gX2MudXJsLCB0YXJnZXQgPSBfYy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRVcmwgPSAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5zYW5pdGl6ZVVybCkodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICYmIG5ld0FuY2hvclRhZy5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHNhbml0aXplZFVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCAmJiBuZXdBbmNob3JUYWcuc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW5pdGl6ZWRVcmwgJiYgc2FuaXRpemVkVXJsICE9PSBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5CTEFOS19VUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FuY2hvclRhZy5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZmlyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5SaXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGV2ZW50XzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZU1hY2hpbmUuYWR2YW5jZUFuZEFwcGx5KGVsYXBzZWRUaW1lKTtcbiAgICAgICAgICAgIC8vIHN0YXRlTWFjaGluZS5pbnN0YW5jZS5hcHBseSh0aGlzLmFydGJvYXJkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmNlIHRoZSBhbmltYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkIHRvIHRoZSBhcnRib2FyZCwgYWR2YW5jZSBpdFxuICAgICAgICAvLyBieSB0aGUgZWxhcHNlZCB0aW1lLlxuICAgICAgICBpZiAodGhpcy5hbmltYXRvci5zdGF0ZU1hY2hpbmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFydGJvYXJkLmFkdmFuY2UoZWxhcHNlZFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIC8vIENhbnZhcyBtdXN0IGJlIHdpcGVkIHRvIHByZXZlbnQgYXJ0aWZhY3RzXG4gICAgICAgIHJlbmRlcmVyLmNsZWFyKCk7XG4gICAgICAgIHJlbmRlcmVyLnNhdmUoKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW5kZXJlciBhbGlnbm1lbnQgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuYWxpZ25SZW5kZXJlcigpO1xuICAgICAgICAvLyBEbyBub3QgZHJhdyBvbiAwIGNhbnZhcyBzaXplXG4gICAgICAgIGlmICghdGhpcy5faGFzWmVyb1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYXJ0Ym9hcmQuZHJhdyhyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgICByZW5kZXJlci5mbHVzaCgpO1xuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGFuaW1hdGlvbnMgdGhhdCBsb29wZWRcbiAgICAgICAgdGhpcy5hbmltYXRvci5oYW5kbGVMb29waW5nKCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbnkgc3RhdGUgbWFjaGluZXMgdGhhdCBoYWQgYSBzdGF0ZSBjaGFuZ2VcbiAgICAgICAgdGhpcy5hbmltYXRvci5oYW5kbGVTdGF0ZUNoYW5nZXMoKTtcbiAgICAgICAgLy8gUmVwb3J0IGFkdmFuY2VkIHRpbWVcbiAgICAgICAgdGhpcy5hbmltYXRvci5oYW5kbGVBZHZhbmNpbmcoZWxhcHNlZFRpbWUpO1xuICAgICAgICAvLyBBZGQgZHVyYXRpb24gdG8gY3JlYXRlIGZyYW1lIHRvIGR1cmF0aW9ucyBhcnJheVxuICAgICAgICB0aGlzLmZyYW1lQ291bnQrKztcbiAgICAgICAgdmFyIGFmdGVyID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuZnJhbWVUaW1lcy5wdXNoKGFmdGVyKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbnMucHVzaChhZnRlciAtIGJlZm9yZSk7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYW1lVGltZXNbMF0gPD0gYWZ0ZXIgLSAxMDAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lVGltZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fdmlld01vZGVsSW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVDYWxsYmFja3MoKTtcbiAgICAgICAgLy8gQ2FsbGluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2lsbCByZXJ1biBkcmF3KCkgYXQgdGhlIGNvcnJlY3QgcmF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc19BUEkvVHV0b3JpYWwvQmFzaWNfYW5pbWF0aW9uc1xuICAgICAgICBpZiAodGhpcy5hbmltYXRvci5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgYSBuZXcgcmVuZGVyaW5nIGZyYW1lXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbmltYXRvci5pc1BhdXNlZCkge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVuZCB0aW1lIHNvIG9uIHBsYXliYWNrIGl0IHN0YXJ0cyBhdCB0aGUgY29ycmVjdCBmcmFtZVxuICAgICAgICAgICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hbmltYXRvci5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IGFuaW1hdGlvbiBpbnN0YW5jZXMsIGFydGJvYXJkIGFuZCB0aW1lXG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJseSB3aGVuIHdlIGhhdmUgaW5zdGFuY2luZ1xuICAgICAgICAgICAgLy8gdGhpcy5pbml0QXJ0Ym9hcmQoKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZHJhd0ZyYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZW5kZXJUaW1lID0gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWxpZ24gdGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuYWxpZ25SZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVuZGVyZXIgPSBfYS5yZW5kZXJlciwgcnVudGltZSA9IF9hLnJ1bnRpbWUsIF9sYXlvdXQgPSBfYS5fbGF5b3V0LCBhcnRib2FyZCA9IF9hLmFydGJvYXJkO1xuICAgICAgICAvLyBBbGlnbiB0aGluZ3MgdXAgc2FmZSBpbiB0aGUga25vd2xlZGdlIHdlIGNhbiByZXN0b3JlIGlmIGNoYW5nZWRcbiAgICAgICAgcmVuZGVyZXIuYWxpZ24oX2xheW91dC5ydW50aW1lRml0KHJ1bnRpbWUpLCBfbGF5b3V0LnJ1bnRpbWVBbGlnbm1lbnQocnVudGltZSksIHtcbiAgICAgICAgICAgIG1pblg6IF9sYXlvdXQubWluWCxcbiAgICAgICAgICAgIG1pblk6IF9sYXlvdXQubWluWSxcbiAgICAgICAgICAgIG1heFg6IF9sYXlvdXQubWF4WCxcbiAgICAgICAgICAgIG1heFk6IF9sYXlvdXQubWF4WSxcbiAgICAgICAgfSwgYXJ0Ym9hcmQuYm91bmRzLCB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvVXNlZCAqIF9sYXlvdXQubGF5b3V0U2NhbGVGYWN0b3IpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcImZwc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb25zLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJmcmFtZVRpbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1cmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5kdXJhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSwgMCkgLyB0aGlzLmR1cmF0aW9ucy5sZW5ndGgpLnRvRml4ZWQoNCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYWxsIFdhc20tZ2VuZXJhdGVkIG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlc3Ryb3llZDpcbiAgICAgKiBhcnRib2FyZCBpbnN0YW5jZXMsIGFuaW1hdGlvbiBpbnN0YW5jZXMsIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VzLFxuICAgICAqIHJlbmRlcmVyIGluc3RhbmNlLCBmaWxlIGFuZCBydW50aW1lLlxuICAgICAqXG4gICAgICogT25jZSB0aGlzIGlzIGNhbGxlZCwgeW91IHdpbGwgbmVlZCB0byBpbml0aWFsaXNlIGEgbmV3IGluc3RhbmNlIG9mIHRoZVxuICAgICAqIFJpdmUgY2xhc3NcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIC8vIFN0b3AgdGhlIHJlbmRlcmVyIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc3RvcHBlZC5cbiAgICAgICAgdGhpcy5zdG9wUmVuZGVyaW5nKCk7XG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBhcnRib2FyZCwgYW5pbWF0aW9uIG9yIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VzLlxuICAgICAgICB0aGlzLmNsZWFudXBJbnN0YW5jZXMoKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gb2JzZXJ2ZXJcbiAgICAgICAgaWYgKHRoaXMuX29ic2VydmVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMucmVtb3ZlKHRoaXMuX29ic2VydmVkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZVJpdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsZSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5yaXZlRmlsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaXZlRmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVsZXRlUml2ZVJlbmRlcmVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9hdWRpb0V2ZW50TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGF1ZGlvTWFuYWdlci5yZW1vdmUodGhpcy5fYXVkaW9FdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy5fdmlld01vZGVsSW5zdGFuY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGVhbnVwKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGF0YUVudW1zID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCB0aGUgUmVuZGVyZXIgb2JqZWN0LiBPbmx5IGNhbGwgdGhpcyBBUEkgaWYgeW91IG5vIGxvbmdlclxuICAgICAqIG5lZWQgdG8gcmVuZGVyIFJpdmUgY29udGVudCBpbiB5b3VyIHNlc3Npb24uXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuZGVsZXRlUml2ZVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMucmVuZGVyZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWxldGUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYW55IFdhc20tZ2VuZXJhdGVkIG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIG1hbnVhbGx5IGRlc3Ryb3llZDpcbiAgICAgKiBhcnRib2FyZCBpbnN0YW5jZXMsIGFuaW1hdGlvbiBpbnN0YW5jZXMsIHN0YXRlIG1hY2hpbmUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogT25jZSB0aGlzIGlzIGNhbGxlZCwgdGhpbmdzIHdpbGwgbmVlZCB0byBiZSByZWluaXRpYWxpemVkIG9yIGJhZCB0aGluZ3NcbiAgICAgKiBtaWdodCBoYXBwZW4uXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuY2xlYW51cEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDbGVhbnVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZSBhbGwgYW5pbWF0aW9uIGFuZCBzdGF0ZSBtYWNoaW5lIGluc3RhbmNlc1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgIHRoaXMuYXJ0Ym9hcmQuZGVsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLmFydGJvYXJkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gcXVlcnkgdGhlIHNldHVwIEFydGJvYXJkIGZvciBhIHRleHQgcnVuIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0UnVuTmFtZSAtIE5hbWUgb2YgdGhlIHRleHQgcnVuIG5vZGUgYXNzb2NpYXRlZCB3aXRoIGEgdGV4dCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyAtIFRleHRWYWx1ZVJ1biBub2RlIG9yIHVuZGVmaW5lZCBpZiB0aGUgdGV4dCBydW4gY2Fubm90IGJlIHF1ZXJpZWRcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5yZXRyaWV2ZVRleHRSdW4gPSBmdW5jdGlvbiAodGV4dFJ1bk5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRleHRSdW5OYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyB0ZXh0IHJ1biBuYW1lIHByb3ZpZGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hcnRib2FyZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gYWNjZXNzIHRleHQgcnVuLCBidXQgdGhlIEFydGJvYXJkIGlzIG51bGxcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHRSdW4gPSB0aGlzLmFydGJvYXJkLnRleHRSdW4odGV4dFJ1bk5hbWUpO1xuICAgICAgICBpZiAoIXRleHRSdW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgYSB0ZXh0IHJ1biB3aXRoIG5hbWUgJ1wiLmNvbmNhdCh0ZXh0UnVuTmFtZSwgXCInIGluIHRoZSAnXCIpLmNvbmNhdCgoX2EgPSB0aGlzLmFydGJvYXJkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSwgXCInIEFydGJvYXJkLiBOb3RlIHRoYXQgeW91IG11c3QgcmVuYW1lIGEgdGV4dCBydW4gbm9kZSBpbiB0aGUgUml2ZSBlZGl0b3IgdG8gbWFrZSBpdCBxdWVyeWFibGUgYXQgcnVudGltZS5cIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0UnVuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBmcm9tIGEgZ2l2ZW4gdGV4dCBydW4gbm9kZSBuYW1lLCBvciB1bmRlZmluZWQgaWYgdGhlIHRleHQgcnVuXG4gICAgICogY2Fubm90IGJlIHF1ZXJpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dFJ1bk5hbWUgLSBOYW1lIG9mIHRoZSB0ZXh0IHJ1biBub2RlIGFzc29jaWF0ZWQgd2l0aCBhIHRleHQgb2JqZWN0XG4gICAgICogQHJldHVybnMgLSBTdHJpbmcgdmFsdWUgb2YgdGhlIHRleHQgcnVuIG5vZGUgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuZ2V0VGV4dFJ1blZhbHVlID0gZnVuY3Rpb24gKHRleHRSdW5OYW1lKSB7XG4gICAgICAgIHZhciB0ZXh0UnVuID0gdGhpcy5yZXRyaWV2ZVRleHRSdW4odGV4dFJ1bk5hbWUpO1xuICAgICAgICByZXR1cm4gdGV4dFJ1biA/IHRleHRSdW4udGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSB0ZXh0IHZhbHVlIGZvciBhIGdpdmVuIHRleHQgcnVuIG5vZGUgbmFtZSBpZiBwb3NzaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHRSdW5OYW1lIC0gTmFtZSBvZiB0aGUgdGV4dCBydW4gbm9kZSBhc3NvY2lhdGVkIHdpdGggYSB0ZXh0IG9iamVjdFxuICAgICAqIEBwYXJhbSB0ZXh0UnVuVmFsdWUgLSBTdHJpbmcgdmFsdWUgdG8gc2V0IG9uIHRoZSB0ZXh0IHJ1biBub2RlXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuc2V0VGV4dFJ1blZhbHVlID0gZnVuY3Rpb24gKHRleHRSdW5OYW1lLCB0ZXh0UnVuVmFsdWUpIHtcbiAgICAgICAgdmFyIHRleHRSdW4gPSB0aGlzLnJldHJpZXZlVGV4dFJ1bih0ZXh0UnVuTmFtZSk7XG4gICAgICAgIGlmICh0ZXh0UnVuKSB7XG4gICAgICAgICAgICB0ZXh0UnVuLnRleHQgPSB0ZXh0UnVuVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFBsYXlzIHNwZWNpZmllZCBhbmltYXRpb25zOyBpZiBub25lIHNwZWNpZmllZCwgaXQgdW5wYXVzZXMgZXZlcnl0aGluZy5cbiAgICBSaXZlLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWVzLCBhdXRvcGxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIHF1ZXVlIHVwIHRoZSBwbGF5XG4gICAgICAgIGlmICghdGhpcy5yZWFkeUZvclBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wbGF5KGFuaW1hdGlvbk5hbWVzLCBhdXRvcGxheSk7IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdG9yLnBsYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICBpZiAodGhpcy5ldmVudENsZWFudXApIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRDbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR1cFJpdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5zdGFydFJlbmRlcmluZygpO1xuICAgIH07XG4gICAgLy8gUGF1c2VzIHNwZWNpZmllZCBhbmltYXRpb25zOyBpZiBub25lIHNwZWNpZmllZCwgcGF1c2VzIGFsbC5cbiAgICBSaXZlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChhbmltYXRpb25OYW1lcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIGVhcmx5IG91dCwgbm90aGluZyB0byBwYXVzZVxuICAgICAgICBpZiAoIXRoaXMucmVhZHlGb3JQbGF5aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2tRdWV1ZS5hZGQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucGF1c2UoYW5pbWF0aW9uTmFtZXMpOyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDbGVhbnVwKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50Q2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0b3IucGF1c2UoYW5pbWF0aW9uTmFtZXMpO1xuICAgIH07XG4gICAgUml2ZS5wcm90b3R5cGUuc2NydWIgPSBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZXMsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFuaW1hdGlvbk5hbWVzID0gbWFwVG9TdHJpbmdBcnJheShhbmltYXRpb25OYW1lcyk7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgZWFybHkgb3V0LCBub3RoaW5nIHRvIHBhdXNlXG4gICAgICAgIGlmICghdGhpcy5yZWFkeUZvclBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zY3J1YihhbmltYXRpb25OYW1lcywgdmFsdWUpOyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2NydWIgdGhlIGFuaW1hdGlvbiB0aW1lOyB3ZSBkcmF3IGEgc2luZ2xlIGZyYW1lIGhlcmUgc28gdGhhdCBpZlxuICAgICAgICAvLyBub3RoaW5nJ3MgY3VycmVudGx5IHBsYXlpbmcsIHRoZSBzY3J1YmJlZCBhbmltYXRpb24gaXMgc3RpbGwgcmVuZGVyZWQvXG4gICAgICAgIHRoaXMuYW5pbWF0b3Iuc2NydWIoYW5pbWF0aW9uTmFtZXMsIHZhbHVlIHx8IDApO1xuICAgICAgICB0aGlzLmRyYXdGcmFtZSgpO1xuICAgIH07XG4gICAgLy8gU3RvcHMgc3BlY2lmaWVkIGFuaW1hdGlvbnM7IGlmIG5vbmUgc3BlY2lmaWVzLCBzdG9wcyB0aGVtIGFsbC5cbiAgICBSaXZlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGFuaW1hdGlvbk5hbWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFuaW1hdGlvbk5hbWVzID0gbWFwVG9TdHJpbmdBcnJheShhbmltYXRpb25OYW1lcyk7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgZWFybHkgb3V0LCBub3RoaW5nIHRvIHBhdXNlXG4gICAgICAgIGlmICghdGhpcy5yZWFkeUZvclBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudGFza1F1ZXVlLmFkZCh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdG9wKGFuaW1hdGlvbk5hbWVzKTsgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGFydGJvYXJkLCB0aGlzLmFuaW1hdG9yIHdpbGwgYmUgdW5kZWZpbmVkXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdG9yLnN0b3AoYW5pbWF0aW9uTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV2ZW50Q2xlYW51cCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudENsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0gYXJ0Ym9hcmQgdGhlIG5hbWUgb2YgdGhlIGFydGJvYXJkLCBvciBkZWZhdWx0IGlmIG5vbmUgZ2l2ZW5cbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9ucyB0aGUgbmFtZXMgb2YgYW5pbWF0aW9ucyBmb3IgcGxheWJhY2tcbiAgICAgKiBAcGFyYW0gc3RhdGVNYWNoaW5lcyB0aGUgbmFtZXMgb2Ygc3RhdGUgbWFjaGluZXMgZm9yIHBsYXliYWNrXG4gICAgICogQHBhcmFtIGF1dG9wbGF5IHdoZXRoZXIgdG8gYXV0b3BsYXkgd2hlbiByZXNldCwgZGVmYXVsdHMgdG8gZmFsc2VcbiAgICAgKlxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYXJ0Ym9hcmQsIGFuaW1hdGlvbnMsIHN0YXRlIG1hY2hpbmVzLCBhbmQgcGxheWJhY2sgc3RhdGVzXG4gICAgICAgIHZhciBhcnRCb2FyZE5hbWUgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXJ0Ym9hcmQ7XG4gICAgICAgIHZhciBhbmltYXRpb25OYW1lcyA9IG1hcFRvU3RyaW5nQXJyYXkocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmFuaW1hdGlvbnMpO1xuICAgICAgICB2YXIgc3RhdGVNYWNoaW5lTmFtZXMgPSBtYXBUb1N0cmluZ0FycmF5KHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5zdGF0ZU1hY2hpbmVzKTtcbiAgICAgICAgdmFyIGF1dG9wbGF5ID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmF1dG9wbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgdmFyIGF1dG9CaW5kID0gKF9iID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmF1dG9CaW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgLy8gU3RvcCBldmVyeXRoaW5nIGFuZCBjbGVhbiB1cFxuICAgICAgICB0aGlzLmNsZWFudXBJbnN0YW5jZXMoKTtcbiAgICAgICAgLy8gUmVpbml0aWFsaXplIGFuIGFydGJvYXJkIGluc3RhbmNlIHdpdGggdGhlIHN0YXRlXG4gICAgICAgIHRoaXMuaW5pdEFydGJvYXJkKGFydEJvYXJkTmFtZSwgYW5pbWF0aW9uTmFtZXMsIHN0YXRlTWFjaGluZU5hbWVzLCBhdXRvcGxheSwgYXV0b0JpbmQpO1xuICAgICAgICB0aGlzLnRhc2tRdWV1ZS5wcm9jZXNzKCk7XG4gICAgfTtcbiAgICAvLyBMb2FkcyBhIG5ldyBSaXZlIGZpbGUsIGtlZXBpbmcgbGlzdGVuZXJzIGluIHBsYWNlXG4gICAgUml2ZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5maWxlID0gbnVsbDtcbiAgICAgICAgLy8gU3RvcCBhbGwgYW5pbWF0aW9uc1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgLy8gUmVpbml0aWFsaXplXG4gICAgICAgIHRoaXMuaW5pdChwYXJhbXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcImxheW91dFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxheW91dC4gTm90ZSB0aGF0IGxheW91dCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICAgICAgICAgKiBpbW11dGFibGUuIElmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgbGF5b3V0LCBjcmVhdGUgYSBuZXcgb25lIHVzZSB0aGVcbiAgICAgICAgICogbGF5b3V0IHNldHRlclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0O1xuICAgICAgICB9LFxuICAgICAgICAvLyBTZXRzIGEgbmV3IGxheW91dFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgICAgIC8vIElmIHRoZSBtYXhYIG9yIG1heFkgYXJlIDAsIHRoZW4gc2V0IHRoZW0gdG8gdGhlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICBpZiAoIWxheW91dC5tYXhYIHx8ICFsYXlvdXQubWF4WSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVG9DYW52YXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlZCAmJiAhdGhpcy5hbmltYXRvci5pc1BsYXlpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdGcmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGF5b3V0IGJvdW5kcyB0byB0aGUgY3VycmVudCBjYW52YXMgc2l6ZTsgdGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkXG4gICAgICogd2hlbiB0aGUgY2FudmFzIGlzIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5yZXNpemVUb0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gdGhpcy5sYXlvdXQuY29weVdpdGgoe1xuICAgICAgICAgICAgbWluWDogMCxcbiAgICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgICBtYXhYOiB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIG1heFk6IHRoaXMuY2FudmFzLmhlaWdodCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY2NvdW50cyBmb3IgZGV2aWNlUGl4ZWxSYXRpbyBhcyBhIG11bHRpcGxpZXIgdG8gcmVuZGVyIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgZHJhd2luZyBzdXJmYWNlLlxuICAgICAqIFVzZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgY2FudmFzIHRvIHNldCBuZXcgd2lkdGgvaGVpZ2h0IGF0dHJpYnV0ZXMuIE5lZWQgdG8gcmUtcmVuZGVyXG4gICAgICogYW5kIHJlc2l6ZSB0aGUgbGF5b3V0IHRvIG1hdGNoIHRoZSBuZXcgZHJhd2luZyBzdXJmYWNlIGFmdGVyd2FyZHMuXG4gICAgICogVXNlZnVsIGZ1bmN0aW9uIGZvciBjb25zdW1lcnMgdG8gaW5jbHVkZSBpbiBhIHdpbmRvdyByZXNpemUgbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB0aGUge0BsaW5rIGRldmljZVBpeGVsUmF0aW9Vc2VkfSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIE9wdGlvbmFsbHksIHlvdSBjYW4gcHJvdmlkZSBhIHtAbGluayBjdXN0b21EZXZpY2VQaXhlbFJhdGlvfSB0byBwcm92aWRlIGFcbiAgICAgKiBjdXN0b20gdmFsdWUuXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUucmVzaXplRHJhd2luZ1N1cmZhY2VUb0NhbnZhcyA9IGZ1bmN0aW9uIChjdXN0b21EZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmICEhd2luZG93KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGRwciA9IGN1c3RvbURldmljZVBpeGVsUmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpb1VzZWQgPSBkcHI7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGRwciAqIHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gZHByICogaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5yZXNpemVUb0NhbnZhcygpO1xuICAgICAgICAgICAgdGhpcy5kcmF3RnJhbWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5maXQgPT09IEZpdC5MYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSB0aGlzLl9sYXlvdXQubGF5b3V0U2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnRib2FyZC53aWR0aCA9IHdpZHRoIC8gc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnRib2FyZC5oZWlnaHQgPSBoZWlnaHQgLyBzY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGFuaW1hdGlvbiBzb3VyY2UsIHdoaWNoIG1heSBiZSB1bmRlZmluZWRcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcmM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwiYWN0aXZlQXJ0Ym9hcmRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYWN0aXZlIGFydGJvYXJkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFydGJvYXJkID8gdGhpcy5hcnRib2FyZC5uYW1lIDogXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJhbmltYXRpb25OYW1lc1wiLCB7XG4gICAgICAgIC8vIFJldHVybnMgYSBsaXN0IG9mIGFuaW1hdGlvbiBuYW1lcyBvbiB0aGUgY2hvc2VuIGFydGJvYXJkXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGUncyBub3QgbG9hZGVkLCB3ZSBnb3Qgbm90aGluZyB0byByZXR1cm5cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQgfHwgIXRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnRib2FyZC5hbmltYXRpb25Db3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25OYW1lcy5wdXNoKHRoaXMuYXJ0Ym9hcmQuYW5pbWF0aW9uQnlJbmRleChpKS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25OYW1lcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJzdGF0ZU1hY2hpbmVOYW1lc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBzdGF0ZSBtYWNoaW5lIG5hbWVzIGZyb20gdGhlIGN1cnJlbnQgYXJ0Ym9hcmRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGUncyBub3QgbG9hZGVkLCB3ZSBnb3Qgbm90aGluZyB0byByZXR1cm5cbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQgfHwgIXRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhdGVNYWNoaW5lTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcnRib2FyZC5zdGF0ZU1hY2hpbmVDb3VudCgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdGF0ZU1hY2hpbmVOYW1lcy5wdXNoKHRoaXMuYXJ0Ym9hcmQuc3RhdGVNYWNoaW5lQnlJbmRleChpKS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZU1hY2hpbmVOYW1lcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlucHV0cyBmb3IgdGhlIHNwZWNpZmllZCBpbnN0YW5jZWQgc3RhdGUgbWFjaGluZSwgb3IgYW4gZW1wdHlcbiAgICAgKiBsaXN0IGlmIHRoZSBuYW1lIGlzIGludmFsaWQgb3IgdGhlIHN0YXRlIG1hY2hpbmUgaXMgbm90IGluc3RhbmNlZFxuICAgICAqIEBwYXJhbSBuYW1lIHRoZSBzdGF0ZSBtYWNoaW5lIG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgaW5wdXRzIGZvciB0aGUgbmFtZWQgc3RhdGUgbWFjaGluZVxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnN0YXRlTWFjaGluZUlucHV0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgZWFybHkgb3V0LCBub3RoaW5nIHRvIHBhdXNlXG4gICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGVNYWNoaW5lID0gdGhpcy5hbmltYXRvci5zdGF0ZU1hY2hpbmVzLmZpbmQoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubmFtZSA9PT0gbmFtZTsgfSk7XG4gICAgICAgIHJldHVybiBzdGF0ZU1hY2hpbmUgPT09IG51bGwgfHwgc3RhdGVNYWNoaW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0ZU1hY2hpbmUuaW5wdXRzO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyB0aGUgaW5wdXQgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBhdCB0aGUgZ2l2ZW4gcGF0aFxuICAgIFJpdmUucHJvdG90eXBlLnJldHJpZXZlSW5wdXRBdFBhdGggPSBmdW5jdGlvbiAobmFtZSwgcGF0aCkge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGlucHV0IG5hbWUgcHJvdmlkZWQgZm9yIHBhdGggJ1wiLmNvbmNhdChwYXRoLCBcIidcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hcnRib2FyZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gYWNjZXNzIGlucHV0OiAnXCIuY29uY2F0KG5hbWUsIFwiJywgYXQgcGF0aDogJ1wiKS5jb25jYXQocGF0aCwgXCInLCBidXQgdGhlIEFydGJvYXJkIGlzIG51bGxcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuYXJ0Ym9hcmQuaW5wdXRCeVBhdGgobmFtZSwgcGF0aCk7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgYW4gaW5wdXQgd2l0aCBuYW1lOiAnXCIuY29uY2F0KG5hbWUsIFwiJywgYXQgcGF0aDonXCIpLmNvbmNhdChwYXRoLCBcIidcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYm9vbGVhbiBpbnB1dCB3aXRoIHRoZSBwcm92aWRlZCBuYW1lIGF0IHRoZSBnaXZlbiBwYXRoIHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIHN0YXRlIG1hY2hpbmUgaW5wdXQgbmFtZVxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0IHRoZSBpbnB1dCB0b1xuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIHRoZSBpbnB1dCBpcyBsb2NhdGVkIGF0IGFuIGFydGJvYXJkIGxldmVsXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuc2V0Qm9vbGVhblN0YXRlQXRQYXRoID0gZnVuY3Rpb24gKGlucHV0TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5yZXRyaWV2ZUlucHV0QXRQYXRoKGlucHV0TmFtZSwgcGF0aCk7XG4gICAgICAgIGlmICghaW5wdXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSBTdGF0ZU1hY2hpbmVJbnB1dFR5cGUuQm9vbGVhbikge1xuICAgICAgICAgICAgaW5wdXQuYXNCb29sKCkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIklucHV0IHdpdGggbmFtZTogJ1wiLmNvbmNhdChpbnB1dE5hbWUsIFwiJywgYXQgcGF0aDonXCIpLmNvbmNhdChwYXRoLCBcIicgaXMgbm90IGEgYm9vbGVhblwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbnVtYmVyIGlucHV0IHdpdGggdGhlIHByb3ZpZGVkIG5hbWUgYXQgdGhlIGdpdmVuIHBhdGggd2l0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSBpbnB1dCB0aGUgc3RhdGUgbWFjaGluZSBpbnB1dCBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBzZXQgdGhlIGlucHV0IHRvXG4gICAgICogQHBhcmFtIHBhdGggdGhlIHBhdGggdGhlIGlucHV0IGlzIGxvY2F0ZWQgYXQgYW4gYXJ0Ym9hcmQgbGV2ZWxcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5zZXROdW1iZXJTdGF0ZUF0UGF0aCA9IGZ1bmN0aW9uIChpbnB1dE5hbWUsIHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMucmV0cmlldmVJbnB1dEF0UGF0aChpbnB1dE5hbWUsIHBhdGgpO1xuICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gU3RhdGVNYWNoaW5lSW5wdXRUeXBlLk51bWJlcikge1xuICAgICAgICAgICAgaW5wdXQuYXNOdW1iZXIoKS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiSW5wdXQgd2l0aCBuYW1lOiAnXCIuY29uY2F0KGlucHV0TmFtZSwgXCInLCBhdCBwYXRoOidcIikuY29uY2F0KHBhdGgsIFwiJyBpcyBub3QgYSBudW1iZXJcIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaXJlIHRoZSB0cmlnZ2VyIHdpdGggdGhlIHByb3ZpZGVkIG5hbWUgYXQgdGhlIGdpdmVuIHBhdGhcbiAgICAgKiBAcGFyYW0gaW5wdXQgdGhlIHN0YXRlIG1hY2hpbmUgaW5wdXQgbmFtZVxuICAgICAqIEBwYXJhbSBwYXRoIHRoZSBwYXRoIHRoZSBpbnB1dCBpcyBsb2NhdGVkIGF0IGFuIGFydGJvYXJkIGxldmVsXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuZmlyZVN0YXRlQXRQYXRoID0gZnVuY3Rpb24gKGlucHV0TmFtZSwgcGF0aCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnJldHJpZXZlSW5wdXRBdFBhdGgoaW5wdXROYW1lLCBwYXRoKTtcbiAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFN0YXRlTWFjaGluZUlucHV0VHlwZS5UcmlnZ2VyKSB7XG4gICAgICAgICAgICBpbnB1dC5hc1RyaWdnZXIoKS5maXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnB1dCB3aXRoIG5hbWU6ICdcIi5jb25jYXQoaW5wdXROYW1lLCBcIicsIGF0IHBhdGg6J1wiKS5jb25jYXQocGF0aCwgXCInIGlzIG5vdCBhIHRyaWdnZXJcIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIHRoZSBUZXh0VmFsdWVSdW4gb2JqZWN0IGZvciB0aGUgcHJvdmlkZWQgbmFtZSBhdCB0aGUgZ2l2ZW4gcGF0aFxuICAgIFJpdmUucHJvdG90eXBlLnJldHJpZXZlVGV4dEF0UGF0aCA9IGZ1bmN0aW9uIChuYW1lLCBwYXRoKSB7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gdGV4dCBuYW1lIHByb3ZpZGVkIGZvciBwYXRoICdcIi5jb25jYXQocGF0aCwgXCInXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIHBhdGggcHJvdmlkZWQgZm9yIHRleHQgJ1wiLmNvbmNhdChuYW1lLCBcIidcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hcnRib2FyZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gYWNjZXNzIHRleHQ6ICdcIi5jb25jYXQobmFtZSwgXCInLCBhdCBwYXRoOiAnXCIpLmNvbmNhdChwYXRoLCBcIicsIGJ1dCB0aGUgQXJ0Ym9hcmQgaXMgbnVsbFwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmFydGJvYXJkLnRleHRCeVBhdGgobmFtZSwgcGF0aCk7XG4gICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFjY2VzcyB0ZXh0IHdpdGggbmFtZTogJ1wiLmNvbmNhdChuYW1lLCBcIicsIGF0IHBhdGg6J1wiKS5jb25jYXQocGF0aCwgXCInXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdGV4dCB2YWx1ZSBmb3IgYSBzcGVjaWZpZWQgdGV4dCBydW4gYXQgYSBnaXZlbiBwYXRoXG4gICAgICogQHBhcmFtIHRleHROYW1lIFRoZSBuYW1lIG9mIHRoZSB0ZXh0IHJ1blxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB0ZXh0IHJ1biB3aXRoaW4gdGhlIGFydGJvYXJkXG4gICAgICogQHJldHVybnMgVGhlIHRleHQgdmFsdWUgb2YgdGhlIHRleHQgcnVuLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIEdldCB0aGUgdGV4dCB2YWx1ZSBmb3IgYSB0ZXh0IHJ1biBuYW1lZCBcInRpdGxlXCIgYXQgb25lIG5lc3RlZCBhcnRib2FyZCBkZWVwXG4gICAgICogY29uc3QgdGl0bGVUZXh0ID0gcml2ZUluc3RhbmNlLmdldFRleHRSdW5WYWx1ZUF0UGF0aChcInRpdGxlXCIsIFwiYXJ0Ym9hcmQxXCIpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBHZXQgdGhlIHRleHQgdmFsdWUgZm9yIGEgdGV4dCBydW4gbmFtZWQgXCJzdWJ0aXRsZVwiIHdpdGhpbiBhIG5lc3RlZCBncm91cCB0d28gYXJ0Ym9hcmRzIGRlZXBcbiAgICAgKiBjb25zdCBzdWJ0aXRsZVRleHQgPSByaXZlSW5zdGFuY2UuZ2V0VGV4dFJ1blZhbHVlQXRQYXRoKFwic3VidGl0bGVcIiwgXCJncm91cC9uZXN0ZWRHcm91cFwiKTtcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlIHRleHQgcnVuIGNhbm5vdCBiZSBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5nZXRUZXh0UnVuVmFsdWVBdFBhdGggPSBmdW5jdGlvbiAodGV4dE5hbWUsIHBhdGgpIHtcbiAgICAgICAgdmFyIHJ1biA9IHRoaXMucmV0cmlldmVUZXh0QXRQYXRoKHRleHROYW1lLCBwYXRoKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBnZXQgdGV4dCB3aXRoIG5hbWU6ICdcIi5jb25jYXQodGV4dE5hbWUsIFwiJywgYXQgcGF0aDonXCIpLmNvbmNhdChwYXRoLCBcIidcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW4udGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHQgdmFsdWUgZm9yIGEgc3BlY2lmaWVkIHRleHQgcnVuIGF0IGEgZ2l2ZW4gcGF0aFxuICAgICAqIEBwYXJhbSB0ZXh0TmFtZSBUaGUgbmFtZSBvZiB0aGUgdGV4dCBydW5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB0ZXh0IHZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB0ZXh0IHJ1biB3aXRoaW4gdGhlIGFydGJvYXJkXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTZXQgdGhlIHRleHQgdmFsdWUgZm9yIGEgdGV4dCBydW4gbmFtZWQgXCJ0aXRsZVwiIGF0IG9uZSBuZXN0ZWQgYXJ0Ym9hcmQgZGVlcFxuICAgICAqIHJpdmVJbnN0YW5jZS5zZXRUZXh0UnVuVmFsdWVBdFBhdGgoXCJ0aXRsZVwiLCBcIk5ldyBUaXRsZVwiLCBcImFydGJvYXJkMVwiKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gU2V0IHRoZSB0ZXh0IHZhbHVlIGZvciBhIHRleHQgcnVuIG5hbWVkIFwic3VidGl0bGVcIiB3aXRoaW4gYSBuZXN0ZWQgZ3JvdXAgdHdvIGFydGJvYXJkcyBkZWVwXG4gICAgICogcml2ZUluc3RhbmNlLnNldFRleHRSdW5WYWx1ZUF0UGF0aChcInN1YnRpdGxlXCIsIFwiTmV3IFN1YnRpdGxlXCIsIFwiZ3JvdXAvbmVzdGVkR3JvdXBcIik7XG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZSB0ZXh0IHJ1biBjYW5ub3QgYmUgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLCBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuc2V0VGV4dFJ1blZhbHVlQXRQYXRoID0gZnVuY3Rpb24gKHRleHROYW1lLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgcnVuID0gdGhpcy5yZXRyaWV2ZVRleHRBdFBhdGgodGV4dE5hbWUsIHBhdGgpO1xuICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHNldCB0ZXh0IHdpdGggbmFtZTogJ1wiLmNvbmNhdCh0ZXh0TmFtZSwgXCInLCBhdCBwYXRoOidcIikuY29uY2F0KHBhdGgsIFwiJ1wiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcnVuLnRleHQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJwbGF5aW5nU3RhdGVNYWNoaW5lTmFtZXNcIiwge1xuICAgICAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBwbGF5aW5nIG1hY2hpbmUgbmFtZXNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlsZSdzIG5vdCBsb2FkZWQsIHdlIGdvdCBub3RoaW5nIHRvIHJldHVyblxuICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdG9yLnN0YXRlTWFjaGluZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnBsYXlpbmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJwbGF5aW5nQW5pbWF0aW9uTmFtZXNcIiwge1xuICAgICAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBwbGF5aW5nIGFuaW1hdGlvbiBuYW1lc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEucGxheWluZzsgfSkubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5hbWU7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcInBhdXNlZEFuaW1hdGlvbk5hbWVzXCIsIHtcbiAgICAgICAgLy8gUmV0dXJucyBhIGxpc3Qgb2YgcGF1c2VkIGFuaW1hdGlvbiBuYW1lc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICFhLnBsYXlpbmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5uYW1lOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJwYXVzZWRTdGF0ZU1hY2hpbmVOYW1lc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUmV0dXJucyBhIGxpc3Qgb2YgcGF1c2VkIG1hY2hpbmUgbmFtZXNcbiAgICAgICAgICogQHJldHVybnMgYSBsaXN0IG9mIHN0YXRlIG1hY2hpbmUgbmFtZXMgdGhhdCBhcmUgcGF1c2VkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaWxlJ3Mgbm90IGxvYWRlZCwgd2UgZ290IG5vdGhpbmcgdG8gcmV0dXJuXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3Iuc3RhdGVNYWNoaW5lc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG0pIHsgcmV0dXJuICFtLnBsYXlpbmc7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5uYW1lOyB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJpc1BsYXlpbmdcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgYW5pbWF0aW9uIGlzIHBsYXlpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuaXNQbGF5aW5nO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcImlzUGF1c2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgYWxsIGluc3RhbmNlZCBhbmltYXRpb25zIGFyZSBwYXVzZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuaXNQYXVzZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwiaXNTdG9wcGVkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHRydWUgaWYgbm8gYW5pbWF0aW9ucyBhcmUgcGxheWluZyBvciBwYXVzZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0b3IuaXNTdG9wcGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcImJvdW5kc1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGFydGJvYXJkLCBvciB1bmRlZmluZWQgaWYgdGhlIGFydGJvYXJkXG4gICAgICAgICAqIGlzbid0IGxvYWRlZCB5ZXQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFydGJvYXJkID8gdGhpcy5hcnRib2FyZC5ib3VuZHMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gUml2ZS1nZW5lcmF0ZWQgZXZlbnRzXG4gICAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgZXZlbnQgdG8gc3Vic2NyaWJlIHRvXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkKHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gYSBSaXZlLWdlbmVyYXRlZCBldmVudFxuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIG9mIGV2ZW50IHRvIHVuc3Vic2NyaWJlIGZyb21cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRvIHVuc3Vic2NyaWJlXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZSh7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGEgUml2ZS1nZW5lcmF0ZWQgZXZlbnRcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDogcGxlYXNlIHVzZSBgb2ZmKClgIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLm9mZih0eXBlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYWxsIFJpdmUgbGlzdGVuZXJzIGZyb20gYW4gZXZlbnQgdHlwZSwgb3IgZXZlcnl0aGluZyBpZiBubyB0eXBlIGlzXG4gICAgICogZ2l2ZW5cbiAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiBldmVudCB0byB1bnN1YnNjcmliZSBmcm9tLCBvciBhbGwgdHlwZXMgaWZcbiAgICAgKiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5yZW1vdmVBbGxSaXZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5yZW1vdmVBbGwodHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYWxsIGxpc3RlbmVycyBmcm9tIGFuIGV2ZW50IHR5cGUsIG9yIGV2ZXJ5dGhpbmcgaWYgbm8gdHlwZSBpc1xuICAgICAqIGdpdmVuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiBldmVudCB0byB1bnN1YnNjcmliZSBmcm9tLCBvciBhbGwgdHlwZXMgaWZcbiAgICAgKiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS51bnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZDogcGxlYXNlIHVzZSBgcmVtb3ZlQWxsUml2ZUV2ZW50TGlzdGVuZXJzKClgIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbFJpdmVFdmVudExpc3RlbmVycyh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSByZW5kZXJpbmcgbG9vcDsgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBwYXVzaW5nIGluIHRoYXQgaXQgZG9lc24ndFxuICAgICAqIGNoYW5nZSB0aGUgc3RhdGUgb2YgYW55IGFuaW1hdGlvbi4gSXQgc3RvcHMgcmVuZGVyaW5nIGZyb20gb2NjdXJyaW5nLiBUaGlzXG4gICAgICogaXMgZGVzaWduZWQgZm9yIHNpdHVhdGlvbnMgc3VjaCBhcyB3aGVuIFJpdmUgaXNuJ3QgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIFRoZSBvbmx5IHdheSB0byBzdGFydCByZW5kZXJpbmcgYWdhaW4gaXMgdG8gY2FsbCBgc3RhcnRSZW5kZXJpbmdgLlxuICAgICAqIEFuaW1hdGlvbnMgdGhhdCBhcmUgbWFya2VkIGFzIHBsYXlpbmcgd2lsbCBzdGFydCBmcm9tIHRoZSBwb3NpdGlvbiB0aGF0XG4gICAgICogdGhleSB3b3VsZCBoYXZlIGJlZW4gYXQgaWYgcmVuZGVyaW5nIGhhZCBub3QgYmVlbiBzdG9wcGVkLlxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnN0b3BSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCAmJiB0aGlzLmZyYW1lUmVxdWVzdElkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ydW50aW1lLmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW50aW1lLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVSZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZVJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSByZW5kZXJpbmcgbG9vcCBpZiBpdCBoYXMgYmVlbiBwcmV2aW91c2x5IHN0b3BwZWQuIElmIHRoZVxuICAgICAqIHJlbmRlcmVyIGlzIGFscmVhZHkgYWN0aXZlLCB0aGVuIHRoaXMgd2lsbCBoYXZlIHplcm8gZWZmZWN0LlxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLnN0YXJ0UmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sb2FkZWQgJiYgdGhpcy5hcnRib2FyZCAmJiAhdGhpcy5mcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVudGltZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUmVxdWVzdElkID0gdGhpcy5ydW50aW1lLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZERyYXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZVJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZERyYXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGZyYW1lcy1wZXItc2Vjb25kIChGUFMpIHJlcG9ydGluZyBmb3IgdGhlIHJ1bnRpbWVcbiAgICAgKiBJZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCwgUml2ZSB3aWxsIGFwcGVuZCBhIGZpeGVkLXBvc2l0aW9uIGRpdiBhdCB0aGUgdG9wLXJpZ2h0IGNvcm5lciBvZlxuICAgICAqIHRoZSBwYWdlIHdpdGggdGhlIEZQUyByZWFkaW5nXG4gICAgICogQHBhcmFtIGZwc0NhbGxiYWNrIC0gQ2FsbGJhY2sgZnJvbSB0aGUgcnVudGltZSBkdXJpbmcgdGhlIFJBRiBsb29wIHRoYXQgc3VwcGxpZXMgdGhlIEZQUyB2YWx1ZVxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLmVuYWJsZUZQU0NvdW50ZXIgPSBmdW5jdGlvbiAoZnBzQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5ydW50aW1lLmVuYWJsZUZQU0NvdW50ZXIoZnBzQ2FsbGJhY2spO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgZnJhbWVzLXBlci1zZWNvbmQgKEZQUykgcmVwb3J0aW5nIGZvciB0aGUgcnVudGltZVxuICAgICAqL1xuICAgIFJpdmUucHJvdG90eXBlLmRpc2FibGVGUFNDb3VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJ1bnRpbWUuZGlzYWJsZUZQU0NvdW50ZXIoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJjb250ZW50c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50cyBvZiBhIFJpdmUgZmlsZTogdGhlIGFydGJvYXJkcywgYW5pbWF0aW9ucywgYW5kIHN0YXRlIG1hY2hpbmVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJpdmVDb250ZW50cyA9IHtcbiAgICAgICAgICAgICAgICBhcnRib2FyZHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWxlLmFydGJvYXJkQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFydGJvYXJkID0gdGhpcy5maWxlLmFydGJvYXJkQnlJbmRleChpKTtcbiAgICAgICAgICAgICAgICB2YXIgYXJ0Ym9hcmRDb250ZW50cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYXJ0Ym9hcmQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTWFjaGluZXM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnRib2FyZC5hbmltYXRpb25Db3VudCgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFydGJvYXJkLmFuaW1hdGlvbkJ5SW5kZXgoaik7XG4gICAgICAgICAgICAgICAgICAgIGFydGJvYXJkQ29udGVudHMuYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnRib2FyZC5zdGF0ZU1hY2hpbmVDb3VudCgpOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlTWFjaGluZSA9IGFydGJvYXJkLnN0YXRlTWFjaGluZUJ5SW5kZXgoayk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBzdGF0ZU1hY2hpbmUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IHRoaXMucnVudGltZS5TdGF0ZU1hY2hpbmVJbnN0YW5jZShzdGF0ZU1hY2hpbmUsIGFydGJvYXJkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0Q29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBpbnN0YW5jZS5pbnB1dENvdW50KCk7IGwrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5zdGFuY2UuaW5wdXQobCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dENvbnRlbnRzLnB1c2goeyBuYW1lOiBpbnB1dC5uYW1lLCB0eXBlOiBpbnB1dC50eXBlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFydGJvYXJkQ29udGVudHMuc3RhdGVNYWNoaW5lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVfMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRDb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJpdmVDb250ZW50cy5hcnRib2FyZHMucHVzaChhcnRib2FyZENvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByaXZlQ29udGVudHM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUml2ZS5wcm90b3R5cGUsIFwidm9sdW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHRlciAvIFNldHRlciBmb3IgdGhlIHZvbHVtZSBvZiB0aGUgYXJ0Ym9hcmRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQgJiYgdGhpcy5hcnRib2FyZC52b2x1bWUgIT09IHRoaXMuX3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMuYXJ0Ym9hcmQudm9sdW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFydGJvYXJkLnZvbHVtZSA9IHZhbHVlICogYXVkaW9NYW5hZ2VyLnN5c3RlbVZvbHVtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJhcnRib2FyZFdpZHRoXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgYXJ0Ym9hcmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCByZXR1cm4gMCBpZiB0aGUgYXJ0Ym9hcmQgaXMgbm90IGxvYWRlZCB5ZXQgYW5kIGEgY3VzdG9tXG4gICAgICAgICAqIHdpZHRoIGhhcyBub3QgYmVlbiBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERvIG5vdCBzZXQgdGhpcyB2YWx1ZSBtYW51YWxseSB3aGVuIHVzaW5nIHtAbGluayByZXNpemVEcmF3aW5nU3VyZmFjZVRvQ2FudmFzfVxuICAgICAgICAgKiB3aXRoIGEge0BsaW5rIExheW91dC5maXR9IG9mIHtAbGluayBGaXQuTGF5b3V0fSwgYXMgdGhlIGFydGJvYXJkIHdpZHRoIGlzXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5hcnRib2FyZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFydGJvYXJkLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2FydGJvYXJkV2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcnRib2FyZFdpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hcnRib2FyZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJ0Ym9hcmQud2lkdGggPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJhcnRib2FyZEhlaWdodFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBhcnRib2FyZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIHJldHVybiAwIGlmIHRoZSBhcnRib2FyZCBpcyBub3QgbG9hZGVkIHlldCBhbmQgYSBjdXN0b21cbiAgICAgICAgICogaGVpZ2h0IGhhcyBub3QgYmVlbiBzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERvIG5vdCBzZXQgdGhpcyB2YWx1ZSBtYW51YWxseSB3aGVuIHVzaW5nIHtAbGluayByZXNpemVEcmF3aW5nU3VyZmFjZVRvQ2FudmFzfVxuICAgICAgICAgKiB3aXRoIGEge0BsaW5rIExheW91dC5maXR9IG9mIHtAbGluayBGaXQuTGF5b3V0fSwgYXMgdGhlIGFydGJvYXJkIGhlaWdodCBpc1xuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHNldC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcnRib2FyZC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fYXJ0Ym9hcmRIZWlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcnRib2FyZEhlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFydGJvYXJkLmhlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGFydGJvYXJkIHNpemUgdG8gaXRzIG9yaWdpbmFsIHZhbHVlcy5cbiAgICAgKi9cbiAgICBSaXZlLnByb3RvdHlwZS5yZXNldEFydGJvYXJkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQpIHtcbiAgICAgICAgICAgIHRoaXMuYXJ0Ym9hcmQucmVzZXRBcnRib2FyZFNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2FydGJvYXJkV2lkdGggPSB0aGlzLmFydGJvYXJkLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5fYXJ0Ym9hcmRIZWlnaHQgPSB0aGlzLmFydGJvYXJkLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBhcnRib2FyZCBpc24ndCBsb2FkZWQsIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGN1c3RvbSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9hcnRib2FyZFdpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fYXJ0Ym9hcmRIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSaXZlLnByb3RvdHlwZSwgXCJkZXZpY2VQaXhlbFJhdGlvVXNlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGV2aWNlIHBpeGVsIHJhdGlvIHVzZWQgaW4gcmVuZGVyaW5nIGFuZCBjYW52YXMvYXJ0Ym9hcmQgcmVzaXppbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgdmFsdWUgd2lsbCBiZSBvdmVyaWRkZW4gYnkgdGhlIGRldmljZSBwaXhlbCByYXRpbyB1c2VkIGluXG4gICAgICAgICAqIHtAbGluayByZXNpemVEcmF3aW5nU3VyZmFjZVRvQ2FudmFzfS4gSWYgeW91IHVzZSB0aGF0IG1ldGhvZCwgZG8gbm90IHNldCB0aGlzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGV2aWNlUGl4ZWxSYXRpb1VzZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvVXNlZCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgZGF0YSBjb250ZXh0IHdpdGggdGhlIHZpZXcgbW9kZWwgaW5zdGFuY2UuXG4gICAgICovXG4gICAgUml2ZS5wcm90b3R5cGUuYmluZFZpZXdNb2RlbEluc3RhbmNlID0gZnVuY3Rpb24gKHZpZXdNb2RlbEluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuYXJ0Ym9hcmQgJiYgIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICBpZiAodmlld01vZGVsSW5zdGFuY2UgJiYgdmlld01vZGVsSW5zdGFuY2UucnVudGltZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmlld01vZGVsSW5zdGFuY2UuaW50ZXJuYWxJbmNyZW1lbnRSZWZlcmVuY2VDb3VudCgpO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlID0gdmlld01vZGVsSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnRib2FyZC5iaW5kVmlld01vZGVsSW5zdGFuY2Uodmlld01vZGVsSW5zdGFuY2UucnVudGltZUluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdG9yLnN0YXRlTWFjaGluZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVNYWNoaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZU1hY2hpbmUuYmluZFZpZXdNb2RlbEluc3RhbmNlKHZpZXdNb2RlbEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJpdmUucHJvdG90eXBlLCBcInZpZXdNb2RlbEluc3RhbmNlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld01vZGVsSW5zdGFuY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSaXZlLnByb3RvdHlwZS52aWV3TW9kZWxCeUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciB2aWV3TW9kZWwgPSB0aGlzLmZpbGUudmlld01vZGVsQnlJbmRleChpbmRleCk7XG4gICAgICAgIGlmICh2aWV3TW9kZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlld01vZGVsKHZpZXdNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBSaXZlLnByb3RvdHlwZS52aWV3TW9kZWxCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgdmlld01vZGVsID0gdGhpcy5maWxlLnZpZXdNb2RlbEJ5TmFtZShuYW1lKTtcbiAgICAgICAgaWYgKHZpZXdNb2RlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWwodmlld01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFJpdmUucHJvdG90eXBlLmVudW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YUVudW1zID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZGF0YUVudW1zID0gdGhpcy5maWxlLmVudW1zKCk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhRW51bXMgPSBkYXRhRW51bXMubWFwKGZ1bmN0aW9uIChkYXRhRW51bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUVudW0oZGF0YUVudW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFFbnVtcztcbiAgICB9O1xuICAgIFJpdmUucHJvdG90eXBlLmRlZmF1bHRWaWV3TW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFydGJvYXJkKSB7XG4gICAgICAgICAgICB2YXIgdmlld01vZGVsID0gdGhpcy5maWxlLmRlZmF1bHRBcnRib2FyZFZpZXdNb2RlbCh0aGlzLmFydGJvYXJkKTtcbiAgICAgICAgICAgIGlmICh2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdNb2RlbCh2aWV3TW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgbWlzc2luZyBzb3VyY2Ugb3IgYnVmZmVyXG4gICAgUml2ZS5taXNzaW5nRXJyb3JNZXNzYWdlID0gXCJSaXZlIHNvdXJjZSBmaWxlIG9yIGRhdGEgYnVmZmVyIHJlcXVpcmVkXCI7XG4gICAgLy8gRXJyb3IgbWVzc2FnZSBmb3IgcmVtb3ZlZCByaXZlIGZpbGVcbiAgICBSaXZlLmNsZWFudXBFcnJvck1lc3NhZ2UgPSBcIkF0dGVtcHQgdG8gdXNlIGZpbGUgYWZ0ZXIgY2FsbGluZyBjbGVhbnVwLlwiO1xuICAgIHJldHVybiBSaXZlO1xufSgpKTtcblxudmFyIFZpZXdNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3TW9kZWwodmlld01vZGVsKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbC5wcm90b3R5cGUsIFwiaW5zdGFuY2VDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdNb2RlbC5pbnN0YW5jZUNvdW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdNb2RlbC5uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld01vZGVsLnByb3RvdHlwZS5pbnN0YW5jZUJ5SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5fdmlld01vZGVsLmluc3RhbmNlQnlJbmRleChpbmRleCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWxJbnN0YW5jZShpbnN0YW5jZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBWaWV3TW9kZWwucHJvdG90eXBlLmluc3RhbmNlQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5fdmlld01vZGVsLmluc3RhbmNlQnlOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlld01vZGVsSW5zdGFuY2UoaW5zdGFuY2UsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVmlld01vZGVsLnByb3RvdHlwZS5kZWZhdWx0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydW50aW1lSW5zdGFuY2UgPSB0aGlzLl92aWV3TW9kZWwuZGVmYXVsdEluc3RhbmNlKCk7XG4gICAgICAgIGlmIChydW50aW1lSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlld01vZGVsSW5zdGFuY2UocnVudGltZUluc3RhbmNlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFZpZXdNb2RlbC5wcm90b3R5cGUuaW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBydW50aW1lSW5zdGFuY2UgPSB0aGlzLl92aWV3TW9kZWwuaW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKHJ1bnRpbWVJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWxJbnN0YW5jZShydW50aW1lSW5zdGFuY2UsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbC5wcm90b3R5cGUsIFwicHJvcGVydGllc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdNb2RlbC5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld01vZGVsLnByb3RvdHlwZSwgXCJpbnN0YW5jZU5hbWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld01vZGVsLmdldEluc3RhbmNlTmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBWaWV3TW9kZWw7XG59KCkpO1xuXG52YXIgRGF0YUVudW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YUVudW0oZGF0YUVudW0pIHtcbiAgICAgICAgdGhpcy5fZGF0YUVudW0gPSBkYXRhRW51bTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFFbnVtLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUVudW0ubmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhRW51bS5wcm90b3R5cGUsIFwidmFsdWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUVudW0udmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFFbnVtO1xufSgpKTtcblxudmFyIFZpZXdNb2RlbEluc3RhbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdNb2RlbEluc3RhbmNlKHJ1bnRpbWVJbnN0YW5jZSwgcm9vdCkge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzV2l0aENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3J1bnRpbWVJbnN0YW5jZSA9IHJ1bnRpbWVJbnN0YW5jZTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3QgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbEluc3RhbmNlLnByb3RvdHlwZSwgXCJydW50aW1lSW5zdGFuY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydW50aW1lSW5zdGFuY2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUuaGFuZGxlQ2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcGVydGllc1dpdGhDYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzV2l0aENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LmhhbmRsZUNhbGxiYWNrcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpZXdNb2RlbEluc3RhbmNlLnByb3RvdHlwZS5jbGVhckNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc1dpdGhDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5LmNsZWFyQ2FsbGJhY2tzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWV0aG9kIHRvIGFjY2VzcyBhIHByb3BlcnR5IGluc3RhbmNlIG9mIHR5cGUgbnVtYmVyIGJlbG9uZ2luZ1xuICAgICAqIHRvIHRoZSB2aWV3IG1vZGVsIGluc3RhbmNlIG9yIHRvIGEgbmVzdGVkIHZpZXcgbW9kZWwgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHBhdGggdG8gdGhlIG51bWJlciBwcm9wZXJ0eVxuICAgICAqL1xuICAgIFZpZXdNb2RlbEluc3RhbmNlLnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IChfYSA9IHRoaXMuX3J1bnRpbWVJbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm51bWJlcihwYXRoKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdNb2RlbEluc3RhbmNlTnVtYmVyKGluc3RhbmNlLCB0aGlzLl9yb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1ldGhvZCB0byBhY2Nlc3MgYSBwcm9wZXJ0eSBpbnN0YW5jZSBvZiB0eXBlIHN0cmluZyBiZWxvbmdpbmdcbiAgICAgKiB0byB0aGUgdmlldyBtb2RlbCBpbnN0YW5jZSBvciB0byBhIG5lc3RlZCB2aWV3IG1vZGVsIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHRoZSBudW1iZXIgcHJvcGVydHlcbiAgICAgKi9cbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSAoX2EgPSB0aGlzLl9ydW50aW1lSW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHJpbmcocGF0aCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWxJbnN0YW5jZVN0cmluZyhpbnN0YW5jZSwgdGhpcy5fcm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtZXRob2QgdG8gYWNjZXNzIGEgcHJvcGVydHkgaW5zdGFuY2Ugb2YgdHlwZSBib29sZWFuIGJlbG9uZ2luZ1xuICAgICAqIHRvIHRoZSB2aWV3IG1vZGVsIGluc3RhbmNlIG9yIHRvIGEgbmVzdGVkIHZpZXcgbW9kZWwgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHBhdGggdG8gdGhlIG51bWJlciBwcm9wZXJ0eVxuICAgICAqL1xuICAgIFZpZXdNb2RlbEluc3RhbmNlLnByb3RvdHlwZS5ib29sZWFuID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSAoX2EgPSB0aGlzLl9ydW50aW1lSW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib29sZWFuKHBhdGgpO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmlld01vZGVsSW5zdGFuY2VCb29sZWFuKGluc3RhbmNlLCB0aGlzLl9yb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1ldGhvZCB0byBhY2Nlc3MgYSBwcm9wZXJ0eSBpbnN0YW5jZSBvZiB0eXBlIGNvbG9yIGJlbG9uZ2luZ1xuICAgICAqIHRvIHRoZSB2aWV3IG1vZGVsIGluc3RhbmNlIG9yIHRvIGEgbmVzdGVkIHZpZXcgbW9kZWwgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHBhdGggdG8gdGhlIG51bWJlciBwcm9wZXJ0eVxuICAgICAqL1xuICAgIFZpZXdNb2RlbEluc3RhbmNlLnByb3RvdHlwZS5jb2xvciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gKF9hID0gdGhpcy5fcnVudGltZUluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29sb3IocGF0aCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWxJbnN0YW5jZUNvbG9yKGluc3RhbmNlLCB0aGlzLl9yb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIG1ldGhvZCB0byBhY2Nlc3MgYSBwcm9wZXJ0eSBpbnN0YW5jZSBvZiB0eXBlIHRyaWdnZXIgYmVsb25naW5nXG4gICAgICogdG8gdGhlIHZpZXcgbW9kZWwgaW5zdGFuY2Ugb3IgdG8gYSBuZXN0ZWQgdmlldyBtb2RlbCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBwYXRoIC0gcGF0aCB0byB0aGUgbnVtYmVyIHByb3BlcnR5XG4gICAgICovXG4gICAgVmlld01vZGVsSW5zdGFuY2UucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IChfYSA9IHRoaXMuX3J1bnRpbWVJbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyaWdnZXIocGF0aCk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWxJbnN0YW5jZVRyaWdnZXIoaW5zdGFuY2UsIHRoaXMuX3Jvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogbWV0aG9kIHRvIGFjY2VzcyBhIHByb3BlcnR5IGluc3RhbmNlIG9mIHR5cGUgZW51bSBiZWxvbmdpbmdcbiAgICAgKiB0byB0aGUgdmlldyBtb2RlbCBpbnN0YW5jZSBvciB0byBhIG5lc3RlZCB2aWV3IG1vZGVsIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHRoZSBudW1iZXIgcHJvcGVydHlcbiAgICAgKi9cbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gKF9hID0gdGhpcy5fcnVudGltZUluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW51bShwYXRoKTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdNb2RlbEluc3RhbmNlRW51bShpbnN0YW5jZSwgdGhpcy5fcm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtZXRob2QgdG8gYWNjZXNzIGEgdmlldyBtb2RlbCBwcm9wZXJ0eSBpbnN0YW5jZSBiZWxvbmdpbmdcbiAgICAgKiB0byB0aGUgdmlldyBtb2RlbCBpbnN0YW5jZSBvciB0byBhIG5lc3RlZCB2aWV3IG1vZGVsIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHRoZSBudW1iZXIgcHJvcGVydHlcbiAgICAgKi9cbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUudmlld01vZGVsID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgdmlld01vZGVsSW5zdGFuY2UgPSAoX2EgPSB0aGlzLl9ydW50aW1lSW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3TW9kZWwocGF0aCk7XG4gICAgICAgIGlmICh2aWV3TW9kZWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3TW9kZWxJbnN0YW5jZSh2aWV3TW9kZWxJbnN0YW5jZSwgdGhpcy5fcm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBtZXRob2QgdG8gcmVwbGFjZSBhIHZpZXcgbW9kZWwgcHJvcGVydHkgd2l0aCBhbm90aGVyIHZpZXcgbW9kZWwgdmFsdWVcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHBhdGggdG8gdGhlIHZpZXcgbW9kZWwgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSB2aWV3IG1vZGVsIHRoYXQgd2lsbCByZXBsYWNlIHRoZSBvcmlnaW5hbFxuICAgICAqL1xuICAgIFZpZXdNb2RlbEluc3RhbmNlLnByb3RvdHlwZS5yZXBsYWNlVmlld01vZGVsID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHZhbHVlLnJ1bnRpbWVJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICgoKF9hID0gdGhpcy5fcnVudGltZUluc3RhbmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZVZpZXdNb2RlbChwYXRoLCB2YWx1ZS5ydW50aW1lSW5zdGFuY2UpKSB8fFxuICAgICAgICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIG1ldGhvZCBmb3IgaW50ZXJuYWwgdXNlLCBpdCBzaG91bGRuJ3QgYmUgY2FsbGVkIGV4dGVybmFsbHlcbiAgICAgKi9cbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUuYWRkVG9DYWxsYmFja3MgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcm9wZXJ0aWVzV2l0aENhbGxiYWNrcy5pbmNsdWRlcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNXaXRoQ2FsbGJhY2tzLnB1c2gocHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxuICAgICAqIG1ldGhvZCBmb3IgaW50ZXJuYWwgdXNlLCBpdCBzaG91bGRuJ3QgYmUgY2FsbGVkIGV4dGVybmFsbHlcbiAgICAgKi9cbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUucmVtb3ZlRnJvbUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICBpZiAodGhpcy5fcHJvcGVydGllc1dpdGhDYWxsYmFja3MuaW5jbHVkZXMocHJvcGVydHkpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzV2l0aENhbGxiYWNrcyA9IHRoaXMuX3Byb3BlcnRpZXNXaXRoQ2FsbGJhY2tzLmZpbHRlcihmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcCAhPT0gcHJvcGVydHk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKlxuICAgICAqIG1ldGhvZCB0byBhZGQgb25lIHRvIHRoZSByZWZlcmVuY2UgY291bnRlciBvZiB0aGUgaW5zdGFuY2UuXG4gICAgICogVXNlIGlmIHRoZSBmaWxlIG93bmluZyB0aGUgcmVmZXJlbmNlIGlzIGRlc3Ryb3llZCBidXQgdGhlIGluc3RhbmNlIG5lZWRzIHRvIHN0YXkgYXJvdW5kXG4gICAgICovXG4gICAgVmlld01vZGVsSW5zdGFuY2UucHJvdG90eXBlLmluY3JlbWVudFJlZmVyZW5jZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50Kys7XG4gICAgICAgIChfYSA9IHRoaXMuX3J1bnRpbWVJbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY3JlbWVudFJlZmVyZW5jZUNvdW50KCk7XG4gICAgfTtcbiAgICAvKlxuICAgICAqIG1ldGhvZCB0byBzdWJ0cmFjdCBvbmUgdG8gdGhlIHJlZmVyZW5jZSBjb3VudGVyIG9mIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBVc2UgaWYgaW5jcmVtZW50UmVmZXJlbmNlQ291bnQgaGFzIGJlZW4gY2FsbGVkXG4gICAgICovXG4gICAgVmlld01vZGVsSW5zdGFuY2UucHJvdG90eXBlLmRlY3JlbWVudFJlZmVyZW5jZUNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50LS07XG4gICAgICAgIChfYSA9IHRoaXMuX3J1bnRpbWVJbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY3JlbWVudFJlZmVyZW5jZUNvdW50KCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld01vZGVsSW5zdGFuY2UucHJvdG90eXBlLCBcInByb3BlcnRpZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAoKChfYSA9IHRoaXMuX3J1bnRpbWVJbnN0YW5jZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFByb3BlcnRpZXMoKS5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIChfX2Fzc2lnbih7fSwgcHJvcCkpOyB9KSkgfHwgW10pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld01vZGVsSW5zdGFuY2UucHJvdG90eXBlLmludGVybmFsSW5jcmVtZW50UmVmZXJlbmNlQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlZmVyZW5jZUNvdW50Kys7XG4gICAgfTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZS5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVmZXJlbmNlQ291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX3JlZmVyZW5jZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bnRpbWVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzV2l0aENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld01vZGVsSW5zdGFuY2U7XG59KCkpO1xuXG52YXIgVmlld01vZGVsSW5zdGFuY2VWYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaWV3TW9kZWxJbnN0YW5jZVZhbHVlKGluc3RhbmNlLCByb290KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5fcm9vdFZpZXdNb2RlbCA9IHJvb3Q7XG4gICAgfVxuICAgIFZpZXdNb2RlbEluc3RhbmNlVmFsdWUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGNsZWFuIHRoZSBjaGFuZ2VkIGZsYWcgZm9yIHByb3BlcnRpZXMgdGhhdCBkb24ndCBoYXZlIGxpc3RlbmVycyxcbiAgICAgICAgLy8gd2UgY2xlYW4gaXQgdGhlIGZpcnN0IHRpbWUgd2UgYWRkIGEgbGlzdGVuZXIgdG8gaXRcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdmlld01vZGVsSW5zdGFuY2VWYWx1ZS5jbGVhckNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzLmluY2x1ZGVzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB0aGlzLl9yb290Vmlld01vZGVsLmFkZFRvQ2FsbGJhY2tzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZVZhbHVlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZmlsdGVyKGZ1bmN0aW9uIChjYikgeyByZXR1cm4gY2IgIT09IGNhbGxiYWNrOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Vmlld01vZGVsLnJlbW92ZUZyb21DYWxsYmFja3ModGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpZXdNb2RlbEluc3RhbmNlVmFsdWUucHJvdG90eXBlLmludGVybmFsSGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgfTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZVZhbHVlLnByb3RvdHlwZS5oYW5kbGVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLmhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUuY2xlYXJDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF90aGlzLmludGVybmFsSGFuZGxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpZXdNb2RlbEluc3RhbmNlVmFsdWUucHJvdG90eXBlLmNsZWFyQ2FsbGJhY2tzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbEluc3RhbmNlVmFsdWUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVmlld01vZGVsSW5zdGFuY2VWYWx1ZTtcbn0oKSk7XG5cbnZhciBWaWV3TW9kZWxJbnN0YW5jZVN0cmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlld01vZGVsSW5zdGFuY2VTdHJpbmcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld01vZGVsSW5zdGFuY2VTdHJpbmcoaW5zdGFuY2UsIHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluc3RhbmNlLCByb290KSB8fCB0aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld01vZGVsSW5zdGFuY2VTdHJpbmcucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld01vZGVsSW5zdGFuY2VWYWx1ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLnZhbHVlID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld01vZGVsSW5zdGFuY2VTdHJpbmcucHJvdG90eXBlLmludGVybmFsSGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld01vZGVsSW5zdGFuY2VTdHJpbmc7XG59KFZpZXdNb2RlbEluc3RhbmNlVmFsdWUpKTtcblxudmFyIFZpZXdNb2RlbEluc3RhbmNlTnVtYmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3TW9kZWxJbnN0YW5jZU51bWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3TW9kZWxJbnN0YW5jZU51bWJlcihpbnN0YW5jZSwgcm9vdCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5zdGFuY2UsIHJvb3QpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3TW9kZWxJbnN0YW5jZU51bWJlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZU51bWJlci5wcm90b3R5cGUuaW50ZXJuYWxIYW5kbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBWaWV3TW9kZWxJbnN0YW5jZU51bWJlcjtcbn0oVmlld01vZGVsSW5zdGFuY2VWYWx1ZSkpO1xuXG52YXIgVmlld01vZGVsSW5zdGFuY2VCb29sZWFuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3TW9kZWxJbnN0YW5jZUJvb2xlYW4sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld01vZGVsSW5zdGFuY2VCb29sZWFuKGluc3RhbmNlLCByb290KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbnN0YW5jZSwgcm9vdCkgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbEluc3RhbmNlQm9vbGVhbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZUJvb2xlYW4ucHJvdG90eXBlLmludGVybmFsSGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld01vZGVsSW5zdGFuY2VCb29sZWFuO1xufShWaWV3TW9kZWxJbnN0YW5jZVZhbHVlKSk7XG5cbnZhciBWaWV3TW9kZWxJbnN0YW5jZVRyaWdnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpZXdNb2RlbEluc3RhbmNlVHJpZ2dlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3TW9kZWxJbnN0YW5jZVRyaWdnZXIoaW5zdGFuY2UsIHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluc3RhbmNlLCByb290KSB8fCB0aGlzO1xuICAgIH1cbiAgICBWaWV3TW9kZWxJbnN0YW5jZVRyaWdnZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLnRyaWdnZXIoKTtcbiAgICB9O1xuICAgIFZpZXdNb2RlbEluc3RhbmNlVHJpZ2dlci5wcm90b3R5cGUuaW50ZXJuYWxIYW5kbGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdNb2RlbEluc3RhbmNlVHJpZ2dlcjtcbn0oVmlld01vZGVsSW5zdGFuY2VWYWx1ZSkpO1xuXG52YXIgVmlld01vZGVsSW5zdGFuY2VFbnVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWaWV3TW9kZWxJbnN0YW5jZUVudW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld01vZGVsSW5zdGFuY2VFbnVtKGluc3RhbmNlLCByb290KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbnN0YW5jZSwgcm9vdCkgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbEluc3RhbmNlRW51bS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld01vZGVsSW5zdGFuY2VFbnVtLnByb3RvdHlwZSwgXCJ2YWx1ZUluZGV4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld01vZGVsSW5zdGFuY2VWYWx1ZVxuICAgICAgICAgICAgICAgIC52YWx1ZUluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUudmFsdWVJbmRleCA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3TW9kZWxJbnN0YW5jZUVudW0ucHJvdG90eXBlLCBcInZhbHVlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUudmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld01vZGVsSW5zdGFuY2VFbnVtLnByb3RvdHlwZS5pbnRlcm5hbEhhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXdNb2RlbEluc3RhbmNlRW51bTtcbn0oVmlld01vZGVsSW5zdGFuY2VWYWx1ZSkpO1xuXG52YXIgVmlld01vZGVsSW5zdGFuY2VDb2xvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlld01vZGVsSW5zdGFuY2VDb2xvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBWaWV3TW9kZWxJbnN0YW5jZUNvbG9yKGluc3RhbmNlLCByb290KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbnN0YW5jZSwgcm9vdCkgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdNb2RlbEluc3RhbmNlQ29sb3IucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld01vZGVsSW5zdGFuY2VWYWx1ZS52YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLnZhbHVlID0gdmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVmlld01vZGVsSW5zdGFuY2VDb2xvci5wcm90b3R5cGUucmdiID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgdGhpcy5fdmlld01vZGVsSW5zdGFuY2VWYWx1ZS5yZ2IociwgZywgYik7XG4gICAgfTtcbiAgICBWaWV3TW9kZWxJbnN0YW5jZUNvbG9yLnByb3RvdHlwZS5yZ2JhID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICAgICAgdGhpcy5fdmlld01vZGVsSW5zdGFuY2VWYWx1ZS5hcmdiKGEsIHIsIGcsIGIpO1xuICAgIH07XG4gICAgVmlld01vZGVsSW5zdGFuY2VDb2xvci5wcm90b3R5cGUuYXJnYiA9IGZ1bmN0aW9uIChhLCByLCBnLCBiKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUuYXJnYihhLCByLCBnLCBiKTtcbiAgICB9O1xuICAgIC8vIFZhbHVlIDAgdG8gMjU1XG4gICAgVmlld01vZGVsSW5zdGFuY2VDb2xvci5wcm90b3R5cGUuYWxwaGEgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB0aGlzLl92aWV3TW9kZWxJbnN0YW5jZVZhbHVlLmFscGhhKGEpO1xuICAgIH07XG4gICAgLy8gVmFsdWUgMCB0byAxXG4gICAgVmlld01vZGVsSW5zdGFuY2VDb2xvci5wcm90b3R5cGUub3BhY2l0eSA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdNb2RlbEluc3RhbmNlVmFsdWUuYWxwaGEoTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvKSkgKiAyNTUpKTtcbiAgICB9O1xuICAgIFZpZXdNb2RlbEluc3RhbmNlQ29sb3IucHJvdG90eXBlLmludGVybmFsSGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld01vZGVsSW5zdGFuY2VDb2xvcjtcbn0oVmlld01vZGVsSW5zdGFuY2VWYWx1ZSkpO1xuXG4vLyBMb2FkcyBSaXZlIGRhdGEgZnJvbSBhIFVSSSB2aWEgZmV0Y2guXG52YXIgbG9hZFJpdmVGaWxlID0gZnVuY3Rpb24gKHNyYykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVxLCByZXMsIGJ1ZmZlcjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXEgPSBuZXcgUmVxdWVzdChzcmMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHJlcSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXMuYXJyYXlCdWZmZXIoKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBidWZmZXJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gdXRpbGl0eSBmdW5jdGlvbnNcbi8qXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGVuc3VyZSBhbiBvYmplY3QgaXMgYSBzdHJpbmcgYXJyYXlcbiAqL1xudmFyIG1hcFRvU3RyaW5nQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtvYmpdO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBJZiBvYmogaXMgdW5kZWZpbmVkLCByZXR1cm4gZW1wdHkgYXJyYXlcbiAgICByZXR1cm4gW107XG59O1xuLy8gI2VuZHJlZ2lvblxuLy8gI3JlZ2lvbiB0ZXN0aW5nIHV0aWxpdGllc1xuLy8gRXhwb3J0cyB0byBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzXG52YXIgVGVzdGluZyA9IHtcbiAgICBFdmVudE1hbmFnZXI6IEV2ZW50TWFuYWdlcixcbiAgICBUYXNrUXVldWVNYW5hZ2VyOiBUYXNrUXVldWVNYW5hZ2VyLFxufTtcbi8vICNlbmRyZWdpb25cbi8vICNyZWdpb24gYXNzZXQgbG9hZGVyc1xuLyoqXG4gKiBEZWNvZGVzIGJ5dGVzIGludG8gYW4gYXVkaW8gYXNzZXQuXG4gKlxuICogQmUgc3VyZSB0byBjYWxsIGAudW5yZWYoKWAgb24gdGhlIGF1ZGlvIG9uY2UgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gVGhpc1xuICogYWxsb3dzIHRoZSBlbmdpbmUgdG8gY2xlYW4gaXQgdXAgd2hlbiBpdCBpcyBub3QgdXNlZCBieSBhbnkgbW9yZSBhbmltYXRpb25zLlxuICovXG52YXIgZGVjb2RlQXVkaW8gPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuIFJ1bnRpbWVMb2FkZXIuZ2V0SW5zdGFuY2UoZnVuY3Rpb24gKHJpdmUpIHtcbiAgICAgICAgICAgIHJpdmUuZGVjb2RlQXVkaW8oYnl0ZXMsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIERlY29kZXMgYnl0ZXMgaW50byBhbiBpbWFnZS5cbiAqXG4gKiBCZSBzdXJlIHRvIGNhbGwgYC51bnJlZigpYCBvbiB0aGUgaW1hZ2Ugb25jZSBpdCBpcyBubyBsb25nZXIgbmVlZGVkLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGVuZ2luZSB0byBjbGVhbiBpdCB1cCB3aGVuIGl0IGlzIG5vdCB1c2VkIGJ5IGFueSBtb3JlIGFuaW1hdGlvbnMuXG4gKi9cbnZhciBkZWNvZGVJbWFnZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXR1cm4gUnVudGltZUxvYWRlci5nZXRJbnN0YW5jZShmdW5jdGlvbiAocml2ZSkge1xuICAgICAgICAgICAgcml2ZS5kZWNvZGVJbWFnZShieXRlcywgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogRGVjb2RlcyBieXRlcyBpbnRvIGEgZm9udC5cbiAqXG4gKiBCZSBzdXJlIHRvIGNhbGwgYC51bnJlZigpYCBvbiB0aGUgZm9udCBvbmNlIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQuIFRoaXNcbiAqIGFsbG93cyB0aGUgZW5naW5lIHRvIGNsZWFuIGl0IHVwIHdoZW4gaXQgaXMgbm90IHVzZWQgYnkgYW55IG1vcmUgYW5pbWF0aW9ucy5cbiAqL1xudmFyIGRlY29kZUZvbnQgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuIFJ1bnRpbWVMb2FkZXIuZ2V0SW5zdGFuY2UoZnVuY3Rpb24gKHJpdmUpIHtcbiAgICAgICAgICAgIHJpdmUuZGVjb2RlRm9udChieXRlcywgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8vICNlbmRyZWdpb25cblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cml2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rive-app/canvas/rive.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@rive-app/react-canvas/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@rive-app/react-canvas/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, \"__esModule\", ({value:!0}));var e=__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"),t=__webpack_require__(/*! @rive-app/canvas */ \"(ssr)/./node_modules/@rive-app/canvas/rive.js\");function n(e){return e&&\"object\"==typeof e&&\"default\"in e?e:{default:e}}var i=/*#__PURE__*/n(e),r=function(){return r=Object.assign||function(e){for(var t,n=1,i=arguments.length;n<i;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},r.apply(this,arguments)};function o(e,t){var n={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.indexOf(i)<0&&(n[i]=e[i]);if(null!=e&&\"function\"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(e);r<i.length;r++)t.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(e,i[r])&&(n[i[r]]=e[i[r]])}return n}function a(e,t,n,i){return new(n||(n=Promise))(function(r,o){function a(e){try{s(i.next(e))}catch(e){o(e)}}function u(e){try{s(i.throw(e))}catch(e){o(e)}}function s(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(a,u)}s((i=i.apply(e,t||[])).next())})}function u(e,t){var n,i,r,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]},a=Object.create((\"function\"==typeof Iterator?Iterator:Object).prototype);return a.next=u(0),a.throw=u(1),a.return=u(2),\"function\"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function u(u){return function(s){return function(u){if(n)throw new TypeError(\"Generator is already executing.\");for(;a&&(a=0,u[0]&&(o=0)),o;)try{if(n=1,i&&(r=2&u[0]?i.return:u[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,u[1])).done)return r;switch(i=0,r&&(u=[2&u[0],r.value]),u[0]){case 0:case 1:r=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,i=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(r=o.trys,(r=r.length>0&&r[r.length-1])||6!==u[0]&&2!==u[0])){o=0;continue}if(3===u[0]&&(!r||u[1]>r[0]&&u[1]<r[3])){o.label=u[1];break}if(6===u[0]&&o.label<r[1]){o.label=r[1],r=u;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(u);break}r[2]&&o.ops.pop(),o.trys.pop();continue}u=t.call(e,o)}catch(e){u=[6,e],i=0}finally{n=r=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([u,s])}}}function s(t){var n=t||c(),i=e.useState(n),r=i[0],o=i[1];return e.useEffect(function(){if(\"undefined\"!=typeof window&&\"matchMedia\"in window){var e=function(){var e=t||c();o(e)},n=window.matchMedia(\"screen and (resolution: \".concat(r,\"dppx)\"));return n.hasOwnProperty(\"addEventListener\")?n.addEventListener(\"change\",e):n.addListener(e),function(){n.hasOwnProperty(\"removeEventListener\")?n.removeEventListener(\"change\",e):n.removeListener(e)}}},[r,t]),r}function c(){var e=\"undefined\"!=typeof window&&\"number\"==typeof window.devicePixelRatio?window.devicePixelRatio:1;return Math.min(Math.max(1,e),3)}\"function\"==typeof SuppressedError&&SuppressedError;var l=function(){function e(){}return e.prototype.observe=function(){},e.prototype.unobserve=function(){},e.prototype.disconnect=function(){},e}();var f=globalThis.ResizeObserver||l,d=void 0!==globalThis.ResizeObserver,v=!d;function h(t,n){void 0===n&&(n=!0);var i=e.useState({width:0,height:0}),r=i[0],o=i[1];e.useEffect(function(){if(\"undefined\"!=typeof window&&n){var e=function(){o({width:window.innerWidth,height:window.innerHeight})};return v&&(e(),window.addEventListener(\"resize\",e)),function(){return window.removeEventListener(\"resize\",e)}}},[]);var a,u,s,c=e.useRef(new f((a=function(e){d&&o({width:e[e.length-1].contentRect.width,height:e[e.length-1].contentRect.height})},u=0,s=0,function(){for(var e=this,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];clearTimeout(s),s=window.setTimeout(function(){return a.apply(e,t)},u)})));return e.useEffect(function(){var e=c.current;if(n){var i=t.current;return t.current&&d&&e.observe(t.current),function(){e.disconnect(),i&&d&&e.unobserve(i)}}e.disconnect()},[t,c]),r}var p={useDevicePixelRatio:!0,fitCanvasToArtboardHeight:!1,useOffscreenRenderer:!0,shouldResizeCanvasToContainer:!0};function b(e){return Object.assign({},p,e)}function w(t){var n=t.riveLoaded,i=void 0!==n&&n,r=t.canvasElem,o=t.containerRef,a=t.options,u=void 0===a?{}:a,c=t.onCanvasHasResized,l=t.artboardBounds,f=b(u),d=e.useState({height:0,width:0}),v=d[0],p=v.height,w=v.width,y=d[1],g=e.useState({height:0,width:0}),m=g[0],R=m.height,C=m.width,E=g[1],O=e.useState(!0),x=O[0],T=O[1],P=f.fitCanvasToArtboardHeight,L=f.shouldResizeCanvasToContainer,S=f.useDevicePixelRatio,k=f.customDevicePixelRatio,M=h(o,L),j=s(k),z=null!=l?l:{},H=z.maxX,I=z.maxY,D=e.useCallback(function(){var e,t,n,i,r=null!==(t=null===(e=o.current)||void 0===e?void 0:e.clientWidth)&&void 0!==t?t:0,a=null!==(i=null===(n=o.current)||void 0===n?void 0:n.clientHeight)&&void 0!==i?i:0;return P&&l?{width:r,height:r*(l.maxY/l.maxX)}:{width:r,height:a}},[o,P,H,I]);e.useEffect(function(){if(L&&o.current&&i){var e=D(),t=e.width,n=e.height,a=!1;if(r){var u=t!==w||n!==p;if(f.fitCanvasToArtboardHeight&&u&&(o.current.style.height=n+\"px\",a=!0),f.useDevicePixelRatio){if(u||(t*j!==C||n*j!==R)){var s=j*t,l=j*n;r.width=s,r.height=l,r.style.width=t+\"px\",r.style.height=n+\"px\",E({width:s,height:l}),a=!0}}else u&&(r.width=t,r.height=n,E({width:t,height:n}),a=!0);y({width:t,height:n})}c&&(x||a)&&c&&c(),x&&T(!1)}},[r,o,M,j,D,x,T,R,C,p,w,c,L,P,S,i]),e.useEffect(function(){E({width:0,height:0})},[r])}var y,g=function(){function e(){}return e.prototype.observe=function(){},e.prototype.unobserve=function(){},e.prototype.disconnect=function(){},e}(),m=globalThis.IntersectionObserver||g,R=function(){function e(){var e=this;this.elementsMap=new Map,this.onObserved=function(t){t.forEach(function(t){var n=e.elementsMap.get(t.target);n&&n(t)})},this.observer=new m(this.onObserved)}return e.prototype.registerCallback=function(e,t){this.observer.observe(e),this.elementsMap.set(e,t)},e.prototype.removeCallback=function(e){this.observer.unobserve(e),this.elementsMap.delete(e)},e}(),C=function(){return y||(y=new R),y};function E(e){var t=e.setContainerRef,n=e.setCanvasRef,a=e.className,u=void 0===a?\"\":a,s=e.style,c=e.children,l=o(e,[\"setContainerRef\",\"setCanvasRef\",\"className\",\"style\",\"children\"]),f=r({width:\"100%\",height:\"100%\"},s);return i.default.createElement(\"div\",r({ref:t,className:u},!u&&{style:f}),i.default.createElement(\"canvas\",r({ref:n,style:{verticalAlign:\"top\",width:0,height:0}},l),c))}function O(n,o){void 0===o&&(o={});var a=e.useState(null),u=a[0],c=a[1],l=e.useRef(null),f=e.useState(null),d=f[0],v=f[1],h=Boolean(n),p=b(o),y=s(),g=e.useCallback(function(){if(d){if(d.layout&&d.layout.fit===t.Fit.Layout&&u){var e=y*d.layout.layoutScaleFactor;d.devicePixelRatioUsed=y,d.artboardWidth=(null==u?void 0:u.width)/e,d.artboardHeight=(null==u?void 0:u.height)/e}d.startRendering(),d.resizeToCanvas()}},[d,y]);w({riveLoaded:!!d,canvasElem:u,containerRef:l,options:p,onCanvasHasResized:g,artboardBounds:null==d?void 0:d.bounds});var m=e.useCallback(function(e){null===e&&u&&(u.height=0,u.width=0),c(e)},[]);e.useEffect(function(){if(u&&n){var e,i=null!=d;if(null==d){var o=p.useOffscreenRenderer;(e=new t.Rive(r(r({useOffscreenRenderer:o},n),{canvas:u}))).on(t.EventType.Load,function(){i=!0,u?v(e):e.cleanup()})}return function(){i||null==e||e.cleanup()}}},[u,h,d]);var R=e.useCallback(function(e){l.current=e},[]),O={observe:e.useCallback(function(e,t){C().registerCallback(e,t)},[]),unobserve:e.useCallback(function(e){C().removeCallback(e)},[])},x=O.observe,T=O.unobserve;e.useEffect(function(){var e,t=!1,n=function(){if(u&&t){var e=u.getBoundingClientRect();e.width>0&&e.height>0&&e.top<(window.innerHeight||document.documentElement.clientHeight)&&e.bottom>0&&e.left<(window.innerWidth||document.documentElement.clientWidth)&&e.right>0&&(null==d||d.startRendering(),t=!1)}};return u&&!1!==p.shouldUseIntersectionObserver&&x(u,function(i){i.isIntersecting?d&&d.startRendering():d&&d.stopRendering(),t=!i.isIntersecting,clearTimeout(e),i.isIntersecting||0!==i.boundingClientRect.width||(e=setTimeout(n,10))}),function(){u&&T(u)}},[x,T,d,u,p.shouldUseIntersectionObserver]),e.useEffect(function(){return function(){d&&(d.cleanup(),v(null))}},[d,u]);var P=null==n?void 0:n.animations;e.useEffect(function(){d&&P&&(d.isPlaying?(d.stop(d.animationNames),d.play(P)):d.isPaused&&(d.stop(d.animationNames),d.pause(P)))},[P,d]);var L=e.useCallback(function(e){return i.default.createElement(E,r({setContainerRef:R,setCanvasRef:m},e))},[m,R]);return{canvas:u,container:l.current,setCanvasRef:m,setContainerRef:R,rive:d,RiveComponent:L}}exports[\"default\"]=function(e){var t=e.src,n=e.artboard,a=e.animations,u=e.stateMachines,s=e.layout,c=e.useOffscreenRenderer,l=void 0===c||c,f=e.shouldDisableRiveListeners,d=void 0!==f&&f,v=e.shouldResizeCanvasToContainer,h=void 0===v||v,p=e.automaticallyHandleEvents,b=void 0!==p&&p,w=e.children,y=o(e,[\"src\",\"artboard\",\"animations\",\"stateMachines\",\"layout\",\"useOffscreenRenderer\",\"shouldDisableRiveListeners\",\"shouldResizeCanvasToContainer\",\"automaticallyHandleEvents\",\"children\"]),g=O({src:t,artboard:n,animations:a,layout:s,stateMachines:u,autoplay:!0,shouldDisableRiveListeners:d,automaticallyHandleEvents:b},{useOffscreenRenderer:l,shouldResizeCanvasToContainer:h}).RiveComponent;return i.default.createElement(g,r({},y),w)},exports.useResizeCanvas=w,exports.useRive=O,exports.useRiveFile=function(n){var i=this,r=e.useState(null),o=r[0],s=r[1],c=e.useState(\"idle\"),l=c[0],f=c[1];return e.useEffect(function(){var e=null;return a(i,void 0,void 0,function(){return u(this,function(i){try{f(\"loading\"),(e=new t.RiveFile(n)).init(),e.on(t.EventType.Load,function(){null==e||e.getInstance(),s(e),f(\"success\")}),e.on(t.EventType.LoadError,function(){f(\"failed\")}),s(e)}catch(e){console.error(e),f(\"failed\")}return[2]})}),function(){null==e||e.cleanup()}},[n.src,n.buffer]),{riveFile:o,status:l}},exports.useStateMachineInput=function(n,i,r,o){var a=e.useState(null),u=a[0],s=a[1];return e.useEffect(function(){function e(){if(n&&i&&r||s(null),n&&i&&r){var e=n.stateMachineInputs(i);if(e){var t=e.find(function(e){return e.name===r});void 0!==o&&t&&(t.value=o),s(t||null)}}else s(null)}e(),n&&n.on(t.EventType.Load,function(){e()})},[n]),u},Object.keys(t).forEach(function(e){\"default\"===e||exports.hasOwnProperty(e)||Object.defineProperty(exports,e,{enumerable:!0,get:function(){return t[e]}})});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJpdmUtYXBwL3JlYWN0LWNhbnZhcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDhDQUEyQyxDQUFDLFNBQVMsRUFBQyxDQUFDLE1BQU0sbUJBQU8sQ0FBQyx3R0FBTyxJQUFJLG1CQUFPLENBQUMsdUVBQWtCLEVBQUUsY0FBYywrQ0FBK0MsV0FBVyxxQ0FBcUMsb0NBQW9DLGlDQUFpQyxJQUFJLHVGQUF1RixTQUFTLDBCQUEwQixnQkFBZ0IsU0FBUyxzRkFBc0YsNkRBQTZELFFBQVEsc0NBQXNDLFdBQVcsNkZBQTZGLFNBQVMsb0JBQW9CLHlDQUF5QyxjQUFjLElBQUksYUFBYSxTQUFTLE1BQU0sY0FBYyxJQUFJLGNBQWMsU0FBUyxNQUFNLGNBQWMsTUFBTSxnRUFBZ0UsS0FBSyxhQUFhLCtCQUErQixFQUFFLGdCQUFnQixhQUFhLHdCQUF3QixxQkFBcUIsWUFBWSxnQkFBZ0IsMEVBQTBFLHdHQUF3RyxZQUFZLElBQUksY0FBYyxtQkFBbUIsbUJBQW1CLDREQUE0RCxLQUFLLHVCQUF1QixLQUFLLGtIQUFrSCx5Q0FBeUMsa0JBQWtCLE1BQU0seUJBQXlCLG9CQUFvQiw4QkFBOEIsU0FBUyxrQ0FBa0MsU0FBUywwRUFBMEUsSUFBSSxTQUFTLHlDQUF5QyxhQUFhLE1BQU0sMkJBQTJCLGlCQUFpQixNQUFNLG9CQUFvQiwyQkFBMkIsTUFBTSwrQkFBK0IsU0FBUyxjQUFjLFNBQVMsWUFBWSxRQUFRLE1BQU0scUJBQXFCLE9BQU8sZ0NBQWdDLFVBQVUsY0FBYywyQ0FBMkMsOEJBQThCLHNEQUFzRCxpQkFBaUIsYUFBYSxLQUFLLG1FQUFtRSx1R0FBdUcsZ0dBQWdHLFVBQVUsYUFBYSxxR0FBcUcsaUNBQWlDLG9EQUFvRCxpQkFBaUIsY0FBYyx1Q0FBdUMsbUNBQW1DLG9DQUFvQyxHQUFHLEdBQUcsNkVBQTZFLGdCQUFnQixtQkFBbUIsa0JBQWtCLGlCQUFpQixnQkFBZ0IsdUJBQXVCLGtDQUFrQyxpQkFBaUIsR0FBRyxrREFBa0QsR0FBRywrREFBK0QsZ0RBQWdELEtBQUssMENBQTBDLE1BQU0sOEVBQThFLEVBQUUsb0JBQW9CLHdCQUF3QixtQkFBbUIsc0JBQXNCLCtDQUErQyxvQkFBb0IsSUFBSSxJQUFJLDhCQUE4QixnQkFBZ0IsTUFBTSxnQkFBZ0IscURBQXFELHFDQUFxQyxlQUFlLFVBQVUsT0FBTyw4R0FBOEcsY0FBYyx1QkFBdUIsTUFBTSxjQUFjLDhGQUE4RixrRUFBa0UsaUJBQWlCLG1EQUFtRCxpQkFBaUIscU5BQXFOLDhDQUE4QyxtTEFBbUwsYUFBYSxpQ0FBaUMsRUFBRSxrQkFBa0IsWUFBWSx1QkFBdUIsb0JBQW9CLG9DQUFvQyxNQUFNLG1CQUFtQiwrRkFBK0YsMEJBQTBCLGdCQUFnQixtRUFBbUUsaUJBQWlCLFFBQVEsaUNBQWlDLGlCQUFpQixRQUFRLEdBQUcsaUJBQWlCLEVBQUUsNEJBQTRCLDJEQUEyRCxHQUFHLGlCQUFpQixFQUFFLE1BQU0sbUJBQW1CLGNBQWMsdUNBQXVDLG1DQUFtQyxvQ0FBb0MsR0FBRyxxREFBcUQsYUFBYSxXQUFXLHFEQUFxRCxzQkFBc0Isa0NBQWtDLFFBQVEsRUFBRSxzQ0FBc0Msa0RBQWtELG1EQUFtRCx3Q0FBd0Msc0RBQXNELEdBQUcsZ0JBQWdCLHVCQUF1QixjQUFjLDhLQUE4SywyQkFBMkIsSUFBSSx3Q0FBd0Msa0JBQWtCLE1BQU0sUUFBUSxzQ0FBc0MsYUFBYSxzQ0FBc0MsUUFBUSxnQkFBZ0IsaUJBQWlCLEVBQUUsNElBQTRJLE1BQU0sNkNBQTZDLG1DQUFtQyxpSEFBaUgsdUNBQXVDLFFBQVEsR0FBRyxpSEFBaUgsRUFBRSxnQ0FBZ0MseUNBQXlDLEtBQUssdUJBQXVCLFNBQVMsZ0JBQWdCLFlBQVksNkJBQTZCLG1CQUFtQix1QkFBdUIsS0FBSyxTQUFTLG1DQUFtQyx3QkFBd0IsRUFBRSxrQkFBa0IsMEJBQTBCLFVBQVUsZ0NBQWdDLFlBQVksUUFBUSxvQ0FBb0MsMEJBQTBCLHlDQUF5QyxzQkFBc0IsS0FBSywyQkFBMkIsdUJBQXVCLHdCQUF3QixTQUFTLGdDQUFnQyx3TkFBd04sZ0VBQWdFLHVLQUF1SyxhQUFhLFNBQVMsbUVBQW1FLGtCQUFrQiwwQkFBMEIsUUFBUSxrQ0FBa0MsdUJBQXVCLDJHQUEyRyxRQUFRLGdDQUFnQyxvQ0FBb0MsaUNBQWlDLEtBQUssUUFBUSxPQUFPLHNGQUFzRixrQkFBZSxhQUFhLDBjQUEwYyw0SEFBNEgsRUFBRSx1REFBdUQsZ0JBQWdCLHFDQUFxQyxPQUFPLENBQUMsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixhQUFhLCtFQUErRSw4QkFBOEIsV0FBVyxvQ0FBb0MsMEJBQTBCLElBQUksMkVBQTJFLDJDQUEyQyx3Q0FBd0MsWUFBWSxPQUFPLFNBQVMsNkJBQTZCLFVBQVUsRUFBRSxhQUFhLHNCQUFzQixvQkFBb0IscUJBQXFCLENBQUMsNEJBQTRCLG1CQUFtQixxQ0FBcUMsOEJBQThCLGFBQWEsNkJBQTZCLDhCQUE4QixNQUFNLHlCQUF5QixrQkFBa0IsRUFBRSx1Q0FBdUMsYUFBYSx3Q0FBd0MsSUFBSSxFQUFFLFFBQVEsb0NBQW9DLDJFQUEyRSw2QkFBNkIsYUFBYSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGhpc2huY2xpY2stZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHJpdmUtYXBwL3JlYWN0LWNhbnZhcy9kaXN0L2luZGV4LmpzP2VlNjciXSwic291cmNlc0NvbnRlbnQiOlsiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGU9cmVxdWlyZShcInJlYWN0XCIpLHQ9cmVxdWlyZShcIkByaXZlLWFwcC9jYW52YXNcIik7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lOntkZWZhdWx0OmV9fXZhciBpPS8qI19fUFVSRV9fKi9uKGUpLHI9ZnVuY3Rpb24oKXtyZXR1cm4gcj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQsbj0xLGk9YXJndW1lbnRzLmxlbmd0aDtuPGk7bisrKWZvcih2YXIgciBpbiB0PWFyZ3VtZW50c1tuXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKGVbcl09dFtyXSk7cmV0dXJuIGV9LHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtmdW5jdGlvbiBvKGUsdCl7dmFyIG49e307Zm9yKHZhciBpIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsaSkmJnQuaW5kZXhPZihpKTwwJiYobltpXT1lW2ldKTtpZihudWxsIT1lJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj0wO2ZvcihpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7cjxpLmxlbmd0aDtyKyspdC5pbmRleE9mKGlbcl0pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLGlbcl0pJiYobltpW3JdXT1lW2lbcl1dKX1yZXR1cm4gbn1mdW5jdGlvbiBhKGUsdCxuLGkpe3JldHVybiBuZXcobnx8KG49UHJvbWlzZSkpKGZ1bmN0aW9uKHIsbyl7ZnVuY3Rpb24gYShlKXt0cnl7cyhpLm5leHQoZSkpfWNhdGNoKGUpe28oZSl9fWZ1bmN0aW9uIHUoZSl7dHJ5e3MoaS50aHJvdyhlKSl9Y2F0Y2goZSl7byhlKX19ZnVuY3Rpb24gcyhlKXt2YXIgdDtlLmRvbmU/cihlLnZhbHVlKToodD1lLnZhbHVlLHQgaW5zdGFuY2VvZiBuP3Q6bmV3IG4oZnVuY3Rpb24oZSl7ZSh0KX0pKS50aGVuKGEsdSl9cygoaT1pLmFwcGx5KGUsdHx8W10pKS5uZXh0KCkpfSl9ZnVuY3Rpb24gdShlLHQpe3ZhciBuLGkscixvPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJnJbMF0pdGhyb3cgclsxXTtyZXR1cm4gclsxXX0sdHJ5czpbXSxvcHM6W119LGE9T2JqZWN0LmNyZWF0ZSgoXCJmdW5jdGlvblwiPT10eXBlb2YgSXRlcmF0b3I/SXRlcmF0b3I6T2JqZWN0KS5wcm90b3R5cGUpO3JldHVybiBhLm5leHQ9dSgwKSxhLnRocm93PXUoMSksYS5yZXR1cm49dSgyKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihhW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGE7ZnVuY3Rpb24gdSh1KXtyZXR1cm4gZnVuY3Rpb24ocyl7cmV0dXJuIGZ1bmN0aW9uKHUpe2lmKG4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDthJiYoYT0wLHVbMF0mJihvPTApKSxvOyl0cnl7aWYobj0xLGkmJihyPTImdVswXT9pLnJldHVybjp1WzBdP2kudGhyb3d8fCgocj1pLnJldHVybikmJnIuY2FsbChpKSwwKTppLm5leHQpJiYhKHI9ci5jYWxsKGksdVsxXSkpLmRvbmUpcmV0dXJuIHI7c3dpdGNoKGk9MCxyJiYodT1bMiZ1WzBdLHIudmFsdWVdKSx1WzBdKXtjYXNlIDA6Y2FzZSAxOnI9dTticmVhaztjYXNlIDQ6cmV0dXJuIG8ubGFiZWwrKyx7dmFsdWU6dVsxXSxkb25lOiExfTtjYXNlIDU6by5sYWJlbCsrLGk9dVsxXSx1PVswXTtjb250aW51ZTtjYXNlIDc6dT1vLm9wcy5wb3AoKSxvLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKHI9by50cnlzLChyPXIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0pfHw2IT09dVswXSYmMiE9PXVbMF0pKXtvPTA7Y29udGludWV9aWYoMz09PXVbMF0mJighcnx8dVsxXT5yWzBdJiZ1WzFdPHJbM10pKXtvLmxhYmVsPXVbMV07YnJlYWt9aWYoNj09PXVbMF0mJm8ubGFiZWw8clsxXSl7by5sYWJlbD1yWzFdLHI9dTticmVha31pZihyJiZvLmxhYmVsPHJbMl0pe28ubGFiZWw9clsyXSxvLm9wcy5wdXNoKHUpO2JyZWFrfXJbMl0mJm8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZX11PXQuY2FsbChlLG8pfWNhdGNoKGUpe3U9WzYsZV0saT0wfWZpbmFsbHl7bj1yPTB9aWYoNSZ1WzBdKXRocm93IHVbMV07cmV0dXJue3ZhbHVlOnVbMF0/dVsxXTp2b2lkIDAsZG9uZTohMH19KFt1LHNdKX19fWZ1bmN0aW9uIHModCl7dmFyIG49dHx8YygpLGk9ZS51c2VTdGF0ZShuKSxyPWlbMF0sbz1pWzFdO3JldHVybiBlLnVzZUVmZmVjdChmdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwibWF0Y2hNZWRpYVwiaW4gd2luZG93KXt2YXIgZT1mdW5jdGlvbigpe3ZhciBlPXR8fGMoKTtvKGUpfSxuPXdpbmRvdy5tYXRjaE1lZGlhKFwic2NyZWVuIGFuZCAocmVzb2x1dGlvbjogXCIuY29uY2F0KHIsXCJkcHB4KVwiKSk7cmV0dXJuIG4uaGFzT3duUHJvcGVydHkoXCJhZGRFdmVudExpc3RlbmVyXCIpP24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLGUpOm4uYWRkTGlzdGVuZXIoZSksZnVuY3Rpb24oKXtuLmhhc093blByb3BlcnR5KFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiKT9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlKTpuLnJlbW92ZUxpc3RlbmVyKGUpfX19LFtyLHRdKSxyfWZ1bmN0aW9uIGMoKXt2YXIgZT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZcIm51bWJlclwiPT10eXBlb2Ygd2luZG93LmRldmljZVBpeGVsUmF0aW8/d2luZG93LmRldmljZVBpeGVsUmF0aW86MTtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoMSxlKSwzKX1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTdXBwcmVzc2VkRXJyb3ImJlN1cHByZXNzZWRFcnJvcjt2YXIgbD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUucHJvdG90eXBlLm9ic2VydmU9ZnVuY3Rpb24oKXt9LGUucHJvdG90eXBlLnVub2JzZXJ2ZT1mdW5jdGlvbigpe30sZS5wcm90b3R5cGUuZGlzY29ubmVjdD1mdW5jdGlvbigpe30sZX0oKTt2YXIgZj1nbG9iYWxUaGlzLlJlc2l6ZU9ic2VydmVyfHxsLGQ9dm9pZCAwIT09Z2xvYmFsVGhpcy5SZXNpemVPYnNlcnZlcix2PSFkO2Z1bmN0aW9uIGgodCxuKXt2b2lkIDA9PT1uJiYobj0hMCk7dmFyIGk9ZS51c2VTdGF0ZSh7d2lkdGg6MCxoZWlnaHQ6MH0pLHI9aVswXSxvPWlbMV07ZS51c2VFZmZlY3QoZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZuKXt2YXIgZT1mdW5jdGlvbigpe28oe3dpZHRoOndpbmRvdy5pbm5lcldpZHRoLGhlaWdodDp3aW5kb3cuaW5uZXJIZWlnaHR9KX07cmV0dXJuIHYmJihlKCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixlKSksZnVuY3Rpb24oKXtyZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixlKX19fSxbXSk7dmFyIGEsdSxzLGM9ZS51c2VSZWYobmV3IGYoKGE9ZnVuY3Rpb24oZSl7ZCYmbyh7d2lkdGg6ZVtlLmxlbmd0aC0xXS5jb250ZW50UmVjdC53aWR0aCxoZWlnaHQ6ZVtlLmxlbmd0aC0xXS5jb250ZW50UmVjdC5oZWlnaHR9KX0sdT0wLHM9MCxmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLHQ9W10sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuXT1hcmd1bWVudHNbbl07Y2xlYXJUaW1lb3V0KHMpLHM9d2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShlLHQpfSx1KX0pKSk7cmV0dXJuIGUudXNlRWZmZWN0KGZ1bmN0aW9uKCl7dmFyIGU9Yy5jdXJyZW50O2lmKG4pe3ZhciBpPXQuY3VycmVudDtyZXR1cm4gdC5jdXJyZW50JiZkJiZlLm9ic2VydmUodC5jdXJyZW50KSxmdW5jdGlvbigpe2UuZGlzY29ubmVjdCgpLGkmJmQmJmUudW5vYnNlcnZlKGkpfX1lLmRpc2Nvbm5lY3QoKX0sW3QsY10pLHJ9dmFyIHA9e3VzZURldmljZVBpeGVsUmF0aW86ITAsZml0Q2FudmFzVG9BcnRib2FyZEhlaWdodDohMSx1c2VPZmZzY3JlZW5SZW5kZXJlcjohMCxzaG91bGRSZXNpemVDYW52YXNUb0NvbnRhaW5lcjohMH07ZnVuY3Rpb24gYihlKXtyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxwLGUpfWZ1bmN0aW9uIHcodCl7dmFyIG49dC5yaXZlTG9hZGVkLGk9dm9pZCAwIT09biYmbixyPXQuY2FudmFzRWxlbSxvPXQuY29udGFpbmVyUmVmLGE9dC5vcHRpb25zLHU9dm9pZCAwPT09YT97fTphLGM9dC5vbkNhbnZhc0hhc1Jlc2l6ZWQsbD10LmFydGJvYXJkQm91bmRzLGY9Yih1KSxkPWUudXNlU3RhdGUoe2hlaWdodDowLHdpZHRoOjB9KSx2PWRbMF0scD12LmhlaWdodCx3PXYud2lkdGgseT1kWzFdLGc9ZS51c2VTdGF0ZSh7aGVpZ2h0OjAsd2lkdGg6MH0pLG09Z1swXSxSPW0uaGVpZ2h0LEM9bS53aWR0aCxFPWdbMV0sTz1lLnVzZVN0YXRlKCEwKSx4PU9bMF0sVD1PWzFdLFA9Zi5maXRDYW52YXNUb0FydGJvYXJkSGVpZ2h0LEw9Zi5zaG91bGRSZXNpemVDYW52YXNUb0NvbnRhaW5lcixTPWYudXNlRGV2aWNlUGl4ZWxSYXRpbyxrPWYuY3VzdG9tRGV2aWNlUGl4ZWxSYXRpbyxNPWgobyxMKSxqPXMoayksej1udWxsIT1sP2w6e30sSD16Lm1heFgsST16Lm1heFksRD1lLnVzZUNhbGxiYWNrKGZ1bmN0aW9uKCl7dmFyIGUsdCxuLGkscj1udWxsIT09KHQ9bnVsbD09PShlPW8uY3VycmVudCl8fHZvaWQgMD09PWU/dm9pZCAwOmUuY2xpZW50V2lkdGgpJiZ2b2lkIDAhPT10P3Q6MCxhPW51bGwhPT0oaT1udWxsPT09KG49by5jdXJyZW50KXx8dm9pZCAwPT09bj92b2lkIDA6bi5jbGllbnRIZWlnaHQpJiZ2b2lkIDAhPT1pP2k6MDtyZXR1cm4gUCYmbD97d2lkdGg6cixoZWlnaHQ6cioobC5tYXhZL2wubWF4WCl9Ont3aWR0aDpyLGhlaWdodDphfX0sW28sUCxILEldKTtlLnVzZUVmZmVjdChmdW5jdGlvbigpe2lmKEwmJm8uY3VycmVudCYmaSl7dmFyIGU9RCgpLHQ9ZS53aWR0aCxuPWUuaGVpZ2h0LGE9ITE7aWYocil7dmFyIHU9dCE9PXd8fG4hPT1wO2lmKGYuZml0Q2FudmFzVG9BcnRib2FyZEhlaWdodCYmdSYmKG8uY3VycmVudC5zdHlsZS5oZWlnaHQ9bitcInB4XCIsYT0hMCksZi51c2VEZXZpY2VQaXhlbFJhdGlvKXtpZih1fHwodCpqIT09Q3x8bipqIT09Uikpe3ZhciBzPWoqdCxsPWoqbjtyLndpZHRoPXMsci5oZWlnaHQ9bCxyLnN0eWxlLndpZHRoPXQrXCJweFwiLHIuc3R5bGUuaGVpZ2h0PW4rXCJweFwiLEUoe3dpZHRoOnMsaGVpZ2h0Omx9KSxhPSEwfX1lbHNlIHUmJihyLndpZHRoPXQsci5oZWlnaHQ9bixFKHt3aWR0aDp0LGhlaWdodDpufSksYT0hMCk7eSh7d2lkdGg6dCxoZWlnaHQ6bn0pfWMmJih4fHxhKSYmYyYmYygpLHgmJlQoITEpfX0sW3IsbyxNLGosRCx4LFQsUixDLHAsdyxjLEwsUCxTLGldKSxlLnVzZUVmZmVjdChmdW5jdGlvbigpe0Uoe3dpZHRoOjAsaGVpZ2h0OjB9KX0sW3JdKX12YXIgeSxnPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUub2JzZXJ2ZT1mdW5jdGlvbigpe30sZS5wcm90b3R5cGUudW5vYnNlcnZlPWZ1bmN0aW9uKCl7fSxlLnByb3RvdHlwZS5kaXNjb25uZWN0PWZ1bmN0aW9uKCl7fSxlfSgpLG09Z2xvYmFsVGhpcy5JbnRlcnNlY3Rpb25PYnNlcnZlcnx8ZyxSPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3ZhciBlPXRoaXM7dGhpcy5lbGVtZW50c01hcD1uZXcgTWFwLHRoaXMub25PYnNlcnZlZD1mdW5jdGlvbih0KXt0LmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49ZS5lbGVtZW50c01hcC5nZXQodC50YXJnZXQpO24mJm4odCl9KX0sdGhpcy5vYnNlcnZlcj1uZXcgbSh0aGlzLm9uT2JzZXJ2ZWQpfXJldHVybiBlLnByb3RvdHlwZS5yZWdpc3RlckNhbGxiYWNrPWZ1bmN0aW9uKGUsdCl7dGhpcy5vYnNlcnZlci5vYnNlcnZlKGUpLHRoaXMuZWxlbWVudHNNYXAuc2V0KGUsdCl9LGUucHJvdG90eXBlLnJlbW92ZUNhbGxiYWNrPWZ1bmN0aW9uKGUpe3RoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKGUpLHRoaXMuZWxlbWVudHNNYXAuZGVsZXRlKGUpfSxlfSgpLEM9ZnVuY3Rpb24oKXtyZXR1cm4geXx8KHk9bmV3IFIpLHl9O2Z1bmN0aW9uIEUoZSl7dmFyIHQ9ZS5zZXRDb250YWluZXJSZWYsbj1lLnNldENhbnZhc1JlZixhPWUuY2xhc3NOYW1lLHU9dm9pZCAwPT09YT9cIlwiOmEscz1lLnN0eWxlLGM9ZS5jaGlsZHJlbixsPW8oZSxbXCJzZXRDb250YWluZXJSZWZcIixcInNldENhbnZhc1JlZlwiLFwiY2xhc3NOYW1lXCIsXCJzdHlsZVwiLFwiY2hpbGRyZW5cIl0pLGY9cih7d2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwifSxzKTtyZXR1cm4gaS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixyKHtyZWY6dCxjbGFzc05hbWU6dX0sIXUmJntzdHlsZTpmfSksaS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIixyKHtyZWY6bixzdHlsZTp7dmVydGljYWxBbGlnbjpcInRvcFwiLHdpZHRoOjAsaGVpZ2h0OjB9fSxsKSxjKSl9ZnVuY3Rpb24gTyhuLG8pe3ZvaWQgMD09PW8mJihvPXt9KTt2YXIgYT1lLnVzZVN0YXRlKG51bGwpLHU9YVswXSxjPWFbMV0sbD1lLnVzZVJlZihudWxsKSxmPWUudXNlU3RhdGUobnVsbCksZD1mWzBdLHY9ZlsxXSxoPUJvb2xlYW4obikscD1iKG8pLHk9cygpLGc9ZS51c2VDYWxsYmFjayhmdW5jdGlvbigpe2lmKGQpe2lmKGQubGF5b3V0JiZkLmxheW91dC5maXQ9PT10LkZpdC5MYXlvdXQmJnUpe3ZhciBlPXkqZC5sYXlvdXQubGF5b3V0U2NhbGVGYWN0b3I7ZC5kZXZpY2VQaXhlbFJhdGlvVXNlZD15LGQuYXJ0Ym9hcmRXaWR0aD0obnVsbD09dT92b2lkIDA6dS53aWR0aCkvZSxkLmFydGJvYXJkSGVpZ2h0PShudWxsPT11P3ZvaWQgMDp1LmhlaWdodCkvZX1kLnN0YXJ0UmVuZGVyaW5nKCksZC5yZXNpemVUb0NhbnZhcygpfX0sW2QseV0pO3coe3JpdmVMb2FkZWQ6ISFkLGNhbnZhc0VsZW06dSxjb250YWluZXJSZWY6bCxvcHRpb25zOnAsb25DYW52YXNIYXNSZXNpemVkOmcsYXJ0Ym9hcmRCb3VuZHM6bnVsbD09ZD92b2lkIDA6ZC5ib3VuZHN9KTt2YXIgbT1lLnVzZUNhbGxiYWNrKGZ1bmN0aW9uKGUpe251bGw9PT1lJiZ1JiYodS5oZWlnaHQ9MCx1LndpZHRoPTApLGMoZSl9LFtdKTtlLnVzZUVmZmVjdChmdW5jdGlvbigpe2lmKHUmJm4pe3ZhciBlLGk9bnVsbCE9ZDtpZihudWxsPT1kKXt2YXIgbz1wLnVzZU9mZnNjcmVlblJlbmRlcmVyOyhlPW5ldyB0LlJpdmUocihyKHt1c2VPZmZzY3JlZW5SZW5kZXJlcjpvfSxuKSx7Y2FudmFzOnV9KSkpLm9uKHQuRXZlbnRUeXBlLkxvYWQsZnVuY3Rpb24oKXtpPSEwLHU/dihlKTplLmNsZWFudXAoKX0pfXJldHVybiBmdW5jdGlvbigpe2l8fG51bGw9PWV8fGUuY2xlYW51cCgpfX19LFt1LGgsZF0pO3ZhciBSPWUudXNlQ2FsbGJhY2soZnVuY3Rpb24oZSl7bC5jdXJyZW50PWV9LFtdKSxPPXtvYnNlcnZlOmUudXNlQ2FsbGJhY2soZnVuY3Rpb24oZSx0KXtDKCkucmVnaXN0ZXJDYWxsYmFjayhlLHQpfSxbXSksdW5vYnNlcnZlOmUudXNlQ2FsbGJhY2soZnVuY3Rpb24oZSl7QygpLnJlbW92ZUNhbGxiYWNrKGUpfSxbXSl9LHg9Ty5vYnNlcnZlLFQ9Ty51bm9ic2VydmU7ZS51c2VFZmZlY3QoZnVuY3Rpb24oKXt2YXIgZSx0PSExLG49ZnVuY3Rpb24oKXtpZih1JiZ0KXt2YXIgZT11LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2Uud2lkdGg+MCYmZS5oZWlnaHQ+MCYmZS50b3A8KHdpbmRvdy5pbm5lckhlaWdodHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkmJmUuYm90dG9tPjAmJmUubGVmdDwod2luZG93LmlubmVyV2lkdGh8fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkmJmUucmlnaHQ+MCYmKG51bGw9PWR8fGQuc3RhcnRSZW5kZXJpbmcoKSx0PSExKX19O3JldHVybiB1JiYhMSE9PXAuc2hvdWxkVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXImJngodSxmdW5jdGlvbihpKXtpLmlzSW50ZXJzZWN0aW5nP2QmJmQuc3RhcnRSZW5kZXJpbmcoKTpkJiZkLnN0b3BSZW5kZXJpbmcoKSx0PSFpLmlzSW50ZXJzZWN0aW5nLGNsZWFyVGltZW91dChlKSxpLmlzSW50ZXJzZWN0aW5nfHwwIT09aS5ib3VuZGluZ0NsaWVudFJlY3Qud2lkdGh8fChlPXNldFRpbWVvdXQobiwxMCkpfSksZnVuY3Rpb24oKXt1JiZUKHUpfX0sW3gsVCxkLHUscC5zaG91bGRVc2VJbnRlcnNlY3Rpb25PYnNlcnZlcl0pLGUudXNlRWZmZWN0KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZCYmKGQuY2xlYW51cCgpLHYobnVsbCkpfX0sW2QsdV0pO3ZhciBQPW51bGw9PW4/dm9pZCAwOm4uYW5pbWF0aW9ucztlLnVzZUVmZmVjdChmdW5jdGlvbigpe2QmJlAmJihkLmlzUGxheWluZz8oZC5zdG9wKGQuYW5pbWF0aW9uTmFtZXMpLGQucGxheShQKSk6ZC5pc1BhdXNlZCYmKGQuc3RvcChkLmFuaW1hdGlvbk5hbWVzKSxkLnBhdXNlKFApKSl9LFtQLGRdKTt2YXIgTD1lLnVzZUNhbGxiYWNrKGZ1bmN0aW9uKGUpe3JldHVybiBpLmRlZmF1bHQuY3JlYXRlRWxlbWVudChFLHIoe3NldENvbnRhaW5lclJlZjpSLHNldENhbnZhc1JlZjptfSxlKSl9LFttLFJdKTtyZXR1cm57Y2FudmFzOnUsY29udGFpbmVyOmwuY3VycmVudCxzZXRDYW52YXNSZWY6bSxzZXRDb250YWluZXJSZWY6UixyaXZlOmQsUml2ZUNvbXBvbmVudDpMfX1leHBvcnRzLmRlZmF1bHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcmMsbj1lLmFydGJvYXJkLGE9ZS5hbmltYXRpb25zLHU9ZS5zdGF0ZU1hY2hpbmVzLHM9ZS5sYXlvdXQsYz1lLnVzZU9mZnNjcmVlblJlbmRlcmVyLGw9dm9pZCAwPT09Y3x8YyxmPWUuc2hvdWxkRGlzYWJsZVJpdmVMaXN0ZW5lcnMsZD12b2lkIDAhPT1mJiZmLHY9ZS5zaG91bGRSZXNpemVDYW52YXNUb0NvbnRhaW5lcixoPXZvaWQgMD09PXZ8fHYscD1lLmF1dG9tYXRpY2FsbHlIYW5kbGVFdmVudHMsYj12b2lkIDAhPT1wJiZwLHc9ZS5jaGlsZHJlbix5PW8oZSxbXCJzcmNcIixcImFydGJvYXJkXCIsXCJhbmltYXRpb25zXCIsXCJzdGF0ZU1hY2hpbmVzXCIsXCJsYXlvdXRcIixcInVzZU9mZnNjcmVlblJlbmRlcmVyXCIsXCJzaG91bGREaXNhYmxlUml2ZUxpc3RlbmVyc1wiLFwic2hvdWxkUmVzaXplQ2FudmFzVG9Db250YWluZXJcIixcImF1dG9tYXRpY2FsbHlIYW5kbGVFdmVudHNcIixcImNoaWxkcmVuXCJdKSxnPU8oe3NyYzp0LGFydGJvYXJkOm4sYW5pbWF0aW9uczphLGxheW91dDpzLHN0YXRlTWFjaGluZXM6dSxhdXRvcGxheTohMCxzaG91bGREaXNhYmxlUml2ZUxpc3RlbmVyczpkLGF1dG9tYXRpY2FsbHlIYW5kbGVFdmVudHM6Yn0se3VzZU9mZnNjcmVlblJlbmRlcmVyOmwsc2hvdWxkUmVzaXplQ2FudmFzVG9Db250YWluZXI6aH0pLlJpdmVDb21wb25lbnQ7cmV0dXJuIGkuZGVmYXVsdC5jcmVhdGVFbGVtZW50KGcscih7fSx5KSx3KX0sZXhwb3J0cy51c2VSZXNpemVDYW52YXM9dyxleHBvcnRzLnVzZVJpdmU9TyxleHBvcnRzLnVzZVJpdmVGaWxlPWZ1bmN0aW9uKG4pe3ZhciBpPXRoaXMscj1lLnVzZVN0YXRlKG51bGwpLG89clswXSxzPXJbMV0sYz1lLnVzZVN0YXRlKFwiaWRsZVwiKSxsPWNbMF0sZj1jWzFdO3JldHVybiBlLnVzZUVmZmVjdChmdW5jdGlvbigpe3ZhciBlPW51bGw7cmV0dXJuIGEoaSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7cmV0dXJuIHUodGhpcyxmdW5jdGlvbihpKXt0cnl7ZihcImxvYWRpbmdcIiksKGU9bmV3IHQuUml2ZUZpbGUobikpLmluaXQoKSxlLm9uKHQuRXZlbnRUeXBlLkxvYWQsZnVuY3Rpb24oKXtudWxsPT1lfHxlLmdldEluc3RhbmNlKCkscyhlKSxmKFwic3VjY2Vzc1wiKX0pLGUub24odC5FdmVudFR5cGUuTG9hZEVycm9yLGZ1bmN0aW9uKCl7ZihcImZhaWxlZFwiKX0pLHMoZSl9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKSxmKFwiZmFpbGVkXCIpfXJldHVyblsyXX0pfSksZnVuY3Rpb24oKXtudWxsPT1lfHxlLmNsZWFudXAoKX19LFtuLnNyYyxuLmJ1ZmZlcl0pLHtyaXZlRmlsZTpvLHN0YXR1czpsfX0sZXhwb3J0cy51c2VTdGF0ZU1hY2hpbmVJbnB1dD1mdW5jdGlvbihuLGkscixvKXt2YXIgYT1lLnVzZVN0YXRlKG51bGwpLHU9YVswXSxzPWFbMV07cmV0dXJuIGUudXNlRWZmZWN0KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2lmKG4mJmkmJnJ8fHMobnVsbCksbiYmaSYmcil7dmFyIGU9bi5zdGF0ZU1hY2hpbmVJbnB1dHMoaSk7aWYoZSl7dmFyIHQ9ZS5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWU9PT1yfSk7dm9pZCAwIT09byYmdCYmKHQudmFsdWU9bykscyh0fHxudWxsKX19ZWxzZSBzKG51bGwpfWUoKSxuJiZuLm9uKHQuRXZlbnRUeXBlLkxvYWQsZnVuY3Rpb24oKXtlKCl9KX0sW25dKSx1fSxPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe1wiZGVmYXVsdFwiPT09ZXx8ZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShlKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsZSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtlXX19KX0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@rive-app/react-canvas/dist/index.js\n");

/***/ })

};
;